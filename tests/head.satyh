
let gray x = Gray(x)
let rgb r g b = RGB(r, g, b)

let black = gray 1.
let red = rgb 1. 0. 0.

let font-size-normal  = 12pt
let font-size-title   = 36pt
let font-size-author  = 16pt
let font-size-section = 18pt

let font-ratio-latin = 1.
let font-ratio-cjk = 0.88

let font-latin-roman  = font `Arno`   font-ratio-latin
let font-latin-italic = font `ArnoIt` font-ratio-latin
let font-latin-sans   = font `Hlv`    font-ratio-latin
let font-cjk-mincho   = font `KozMin` font-ratio-cjk
let font-cjk-gothic   = font `Osaka`  font-ratio-cjk

let-row ctx \emph inner =
  let ctx-emph =
    ctx |> set-font Latin          font-latin-italic
        |> set-font HanIdeographic font-cjk-gothic
        |> set-font Kana           font-cjk-gothic
        |> set-text-color (CMYK(1., 0., 0., 0.)) %(RGB(0., 0., 0.75))
  in
    lex-row ctx-emph inner

let-mutable ref-title <- {}
let-mutable ref-author <- {}

let-col ctx +document rcd inner =
  let title = rcd#title in
  let author = rcd#author in
  let ctx-doc =
    ctx |> set-font Latin font-latin-roman
        |> set-dominant-script Latin
  in
  (
    ref-title <- title before
    ref-author <- author before
    lex-col ctx-doc inner
  )

let title-frame =
  let pads = (5pt, 5pt, 10pt, 10pt) in
  let cx = 12pt in
  let cy = 8pt in
  let deco (x, y) wid hgt dpt =
    let xL = x in
    let xR = x +' wid in
    let yT = y +' hgt in
    let yB = y -' dpt in
    let path =
      start-path (xL, yT)
        |> line-to (xR, yT)
        |> bezier-to (xR +' cx, yT -' cy) (xR +' cx, yB +' cy) (xR, yB)
        |> line-to (xL, yB)
        |> close-with-bezier (xL -' cx, yB +' cy) (xL -' cx, yT -' cy)
    in
      [
        fill (rgb 1. 0.75 0.75) path;
        dashed-stroke 5pt (25pt, 3pt, 5pt) red path;
      ]
  in
    outer-frame-block pads deco

let-col ctx +make-title =
%  let title = get-title ctx in
  let ctx-title =
    ctx |> set-font-size font-size-title
        |> set-font Latin font-latin-roman
  in
  let ctx-author =
    ctx |> set-font-size font-size-author
        |> set-font Latin font-latin-roman
  in
  let br-title = lex-row ctx-title (!ref-title) in
  let br-author = lex-row ctx-author (!ref-author) in
  let bc-title = form-paragraph ctx-title (title-frame (outer-fil ++ br-title ++ outer-fil)) in
  let bc-author = form-paragraph ctx-author (outer-fil ++ br-author) in
    bc-title +++ bc-author

let indent = fixed-empty 24pt

let indent-jp = fixed-empty 10pt

let-mutable needs-indentation-ref <- true

let-col ctx +p inner =
  let needs-indentation =
    if !needs-indentation-ref then
      true
    else
      let () = needs-indentation-ref <- true in
        false
  in

  let br = lex-row ctx inner in
  let br-parag =
    if needs-indentation then
      indent ++ br ++ outer-fil
    else
      br ++ outer-fil
  in
    form-paragraph ctx br-parag

let-col ctx +frame inner =
  let () = needs-indentation-ref <- false in
    col-frame ctx (function ctx ->
      lex-col ctx inner)

let-col ctx +p-jp inner =
  let ctx-jp =
    ctx |> set-font HanIdeographic font-cjk-mincho
        |> set-font Kana           font-cjk-mincho
        |> set-dominant-script HanIdeographic
  in
  let () = needs-indentation-ref <- true in
  let br = lex-row ctx-jp inner in
    form-paragraph ctx (indent-jp ++ br ++ outer-fil)

let-mutable num-section <- 0

let-col ctx +section title inner =
  let ctx-title =
    ctx |> set-font-size font-size-section
        |> set-font Latin          font-latin-sans
        |> set-font HanIdeographic font-cjk-gothic
        |> set-font Kana           font-cjk-gothic
  in
  let () = num-section <- !num-section + 1 in
  let () = needs-indentation-ref <- false in
  let br-num = lex-row ctx-title (embed ((arabic (!num-section)) ^ `.`)) in
  let br-title = lex-row ctx-title title in
  let bc-title = form-paragraph ctx (br-num ++ (fixed-empty 10pt) ++ br-title ++ (outer-fil)) in
  let bc-inner = lex-col ctx inner in
    bc-title +++ bc-inner

let-row ctx \expand-spaces inner =
  let ctx-inner = set-space-ratio 1.0 ctx in
    lex-row ctx-inner inner

let-col-detailed ctx +px inner =
  let br = lex-row ctx inner in
  let bc = form-paragraph ctx (indent ++ br ++ outer-fil) in
  let ctx-after = set-font Latin font-latin-italic ctx in
    (ctx-after, bc)

let simple-decoset =
  let frame-stroke = stroke 1pt red in
  let margin-x = 2pt in
  let margin-y = 2pt in
  let decoS (x, y) wid hgt dpt =
    let xb = x +' margin-x in
    let widb = wid -' (margin-x *' 2.) in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [ frame-stroke <[ (xb, y -' dptb) -- (xb, y +' hgtb)
          -- (xb +' widb, y +' hgtb) -- (xb +' widb, y -' dptb) -- cycle ]>; ]
  in
  let decoH (x, y) wid hgt dpt =
    let xb = x +' margin-x in
    let widb = wid -' margin-x in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [ frame-stroke <[ (xb +' widb, y -' dptb) -- (xb, y -' dptb)
          -- (xb, y +' hgtb) -- (xb +' widb, y +' hgtb) ]>; ]
  in
  let decoT (x, y) wid hgt dpt =
    let xb = x in
    let widb = wid -' margin-x in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [ frame-stroke <[ (xb, y -' dptb) -- (xb +' widb, y -' dptb)
          -- (xb +' widb, y +' hgtb) -- (xb, y +' hgtb) ]>; ]
  in
  let decoM (x, y) wid hgt dpt =
    let xb = x in
    let widb = wid in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [
        frame-stroke <[ (xb, y -' dptb) -- (xb +' widb, y -' dptb) ]>;
        frame-stroke <[ (xb, y +' hgtb) -- (xb +' widb, y +' hgtb) ]>;
      ]
  in
    (decoS, decoH, decoM, decoT)

let-row ctx \inline-frame inner =
  let pads = (5pt, 5pt, 5pt, 5pt) in
  let br = lex-row ctx inner in
    (outer-frame-inline pads simple-decoset br)

let-col ctx +simple-replacement-test = lex-col ctx
  '< +p {Replaced text} >

module List
: sig
    val map : ('a -> 'b) -> 'a list -> 'b list
    val fold-left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
  end
= struct
    let map
      | f []        = []
      | f (x :: xs) = (f x) :: map f xs

    let fold-left
      | f init []        = init
      | f init (x :: xs) = fold-left f (f init x) xs
  end

let (+++>) = List.fold-left (+++)

let item-indent = 16pt

let circle (cx, cy) r =
  let t = r *' 0.55228 in
    start-path (cx -' r, cy)
      |> bezier-to (cx -' r, cy +' t) (cx -' t, cy +' r) (cx, cy +' r)
      |> bezier-to (cx +' t, cy +' r) (cx +' r, cy +' t) (cx +' r, cy)
      |> bezier-to (cx +' r, cy -' t) (cx +' t, cy -' r) (cx, cy -' r)
      |> close-with-bezier (cx -' t, cy -' r) (cx -' r, cy -' t)

let bullet (x, y) =
  let cx = x +' 4pt in
  let cy = y +' 4pt in
  let r = 2pt in
    [ fill (Gray(0.)) (circle (cx, cy) r); ]

let item : context -> int -> itemize -> box-col
  | ctx depth (Item(parent, children)) =
      let br-bullet = (inline-graphics 8pt 8pt 0pt bullet) ++ (fixed-empty 8pt) in
      let bullet-width = get-natural-width br-bullet in
      let parent-indent = item-indent *' (float depth) in
      let br-parent =
        pbox-top ctx ((get-text-width ctx) -' parent-indent -' bullet-width) (function ctx ->
          form-paragraph ctx ((lex-row ctx parent) ++ outer-fil)
        )
      in
      let bc-parent =
        form-paragraph ctx
          ((fixed-empty parent-indent) ++ br-bullet ++ br-parent)
      in
      let bclst-children = List.map (item ctx (depth + 1)) children in
        bc-parent +++> bclst-children

let-col ctx +listing (Item(_, itmzlst)) =
  let bclst = List.map (item ctx 0) itmzlst in
    col-nil +++> bclst

let-col ctx +expand-leading inner =
  lex-col (ctx |> set-leading 32pt) inner

let-row ctx \parbox-top wid inner =
  pbox-top ctx wid (function ctx -> lex-col ctx inner)

let-col ctx +repeat n inner =
  let bc = lex-col ctx inner in
  let repeat acc i =
    if i >= n then acc else
      repeat (bc +++ acc) (i + 1)
  in
    repeat col-nil 0

let description ctx pairlst =
  let indent = 24pt in
  let bclst =
    pairlst |> List.map (function pair -> (
      match pair with
      | (item, descr) ->
          let br-item =
            let ctx-item =
              ctx |> set-font Latin font-latin-sans
            in
              lex-row ctx-item item
          in
          let br-descr = lex-row ctx descr in
          let br-pbox =
            pbox-top ctx ((get-text-width ctx) -' indent) (function ctx ->
              form-paragraph ctx ((fixed-empty (0pt -' indent)) ++ br-item ++ (fixed-empty 12pt) ++ br-descr ++ outer-fil)
            )
          in
            form-paragraph ctx ((fixed-empty indent) ++ br-pbox)
    ))
  in
    col-nil +++> bclst

let-col ctx +description pairlst =
  description ctx pairlst

let decoset-underline =
  let distance = 4pt in
  let deco (x, y) wid _ _ =
    [ stroke 1pt (RGB(0., 0.5, 0.)) <[ (x, y -' distance) -- (x +' wid, y -' distance) ]>; ]
  in
    (deco, deco, deco, deco)

let-row ctx \underline inner =
  let pads = (0pt, 0pt, 0pt, 0pt) in
  let br = lex-row ctx inner in
    outer-frame-inline pads decoset-underline br

let donut-path (cx, cy) r1 r2 =
  unite-path (circle (cx, cy) r1) (circle (cx, cy) r2)

let-row ctx \donut =
  let wid = 14pt in
  let chgt = 4pt in
  let r1 = 6pt in
  let r2 = 3pt in
    inline-graphics wid 12pt 0pt (function (x, y) -> (
      let cx = x +' wid *' 0.5 in
      let cy = y +' chgt in
        [ fill (RGB(0.8, 0.5, 0.)) (donut-path (cx, cy) r1 r2); ]
    ))

let-row ctx \donuts =
  let r1 = 6pt in
  let r2 = 3pt in
    inline-graphics 18pt 12pt 0pt (function (x, y) -> (
      let cp1 = (x +' 7pt, y +' 4pt) in
      let cp2 = (x +' 11pt, y +' 1pt) in
        [
          fill (RGB(0.7, 0.4, 0.)) (donut-path cp2 r1 r2);
          fill (RGB(0.8, 0.5, 0.)) (donut-path cp1 r1 r2);
        ]
    ))
