let-row ctx \emph inner =
  let ctx-emph =
    ctx |> set-font Latin (font `ArnoIt` 12pt)
        |> set-font HanIdeographic (font `Osaka` 10pt)
        |> set-font Kana (font `Osaka` 10pt)
        |> set-text-color (CMYK(1., 0., 0., 0.)) %(RGB(0., 0., 0.75))
  in
    lex-row ctx-emph inner

let-mutable ref-title <- {}
let-mutable ref-author <- {}

let-col ctx +document rcd inner =
  let title = rcd#title in
  let author = rcd#author in
  let ctx-doc =
    ctx |> set-font Latin (font `Arno` 12pt)
%        |> set-title title
        |> set-dominant-script Latin
  in
  (
    ref-title <- title before
    ref-author <- author before
    lex-col ctx-doc inner
  )

let gctx-title-frame =
  default-graphics-context
    |> set-line-width 5pt
    |> set-line-dash (Some(25pt, 3pt, 5pt))
    |> set-stroke-color (RGB(1., 0., 0.))
    |> set-fill-color (RGB(1., 0.75, 0.75))

let title-frame =
  let pads = (5pt, 5pt, 10pt, 10pt) in
  let cx = 12pt in
  let cy = 8pt in
  let deco (x, y) wid hgt dpt =
    let xL = x in
    let xR = x +' wid in
    let yT = y +' hgt in
    let yB = y -' dpt in
    let path =
%      <[ (xL, yT)
%           -- (xR, yT)
%           .. controls (xR +' cx, yT -' cy) and (xR +' cx, yB +' cy)
%           .. (xR, yB)
%           -- (xL, yB)
%           .. controls (xL -' cx, yB +' cy) and (xL -' cx, yT -' cy)
%           .. cycle ]>
      start-path (xL, yT)
        |> line-to (xR, yT)
        |> bezier-to (xR +' cx, yT -' cy) (xR +' cx, yB +' cy) (xR, yB)
        |> line-to (xL, yB)
        |> close-with-bezier (xL -' cx, yB +' cy) (xL -' cx, yT -' cy)
    in
      [
        fill gctx-title-frame path;
        stroke gctx-title-frame path;
      ]
  in
    outer-frame-block pads deco

let-col ctx +make-title =
%  let title = get-title ctx in
  let ctx-title = ctx |> set-font Latin (font `Arno` 36pt) in
  let ctx-author = ctx |> set-font Latin (font `Arno` 16pt) in
  let br-title = lex-row ctx-title (!ref-title) in
  let br-author = lex-row ctx-author (!ref-author) in
  let bc-title = form-paragraph ctx-title (title-frame (outer-fil ++ br-title ++ outer-fil)) in
  let bc-author = form-paragraph ctx-author (outer-fil ++ br-author) in
    bc-title +++ bc-author

let indent = fixed-empty 24pt

let indent-jp = fixed-empty 10pt

let-mutable needs-indentation-ref <- true

let-col ctx +p inner =
  let needs-indentation =
    if !needs-indentation-ref then
      true
    else
      let () = needs-indentation-ref <- true in
        false
  in

  let br = lex-row ctx inner in
  let br-parag =
    if needs-indentation then
      indent ++ br ++ outer-fil
    else
      br ++ outer-fil
  in
    form-paragraph ctx br-parag

let-col ctx +frame inner =
  let () = needs-indentation-ref <- false in
    col-frame ctx (function ctx ->
      lex-col ctx inner)

let-col ctx +p-jp inner =
  let ctx-jp =
    ctx |> set-font HanIdeographic (font `KozMin` 10pt)
        |> set-font Kana (font `KozMin` 10pt)
        |> set-dominant-script HanIdeographic
  in
  let () = needs-indentation-ref <- true in
  let br = lex-row ctx-jp inner in
    form-paragraph ctx (indent-jp ++ br ++ outer-fil)

let-mutable num-section <- 0

let-col ctx +section title inner =
  let ctx-title =
    ctx |> set-font Latin (font `Hlv` 18pt)
        |> set-font HanIdeographic (font `Osaka` 16pt)
        |> set-font Kana (font `Osaka` 16pt)
  in
  let () = num-section <- !num-section + 1 in
  let () = needs-indentation-ref <- false in
  let br-num = lex-row ctx-title (embed ((arabic (!num-section)) ^ `.`)) in
  let br-title = lex-row ctx-title title in
  let bc-title = form-paragraph ctx (br-num ++ (fixed-empty 10pt) ++ br-title ++ (outer-fil)) in
  let bc-inner = lex-col ctx inner in
    bc-title +++ bc-inner

let-row ctx \expand-spaces inner =
  let ctx-inner = set-space-ratio 1.0 ctx in
    lex-row ctx-inner inner

let-col-detailed ctx +px inner =
  let br = lex-row ctx inner in
  let bc = form-paragraph ctx (indent ++ br ++ outer-fil) in
  let ctx-after = set-font Latin (font `ArnoIt` 12pt) ctx in
    (ctx-after, bc)

let simple-decoset =
  let margin-x = 2pt in
  let margin-y = 2pt in
  let gctx = default-graphics-context |> set-stroke-color (RGB(1., 0., 0.)) in
  let decoS (x, y) wid hgt dpt =
    let xb = x +' margin-x in
    let widb = wid -' (margin-x *' 2.) in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [ stroke gctx <[ (xb, y -' dptb) -- (xb, y +' hgtb)
          -- (xb +' widb, y +' hgtb) -- (xb +' widb, y -' dptb) -- cycle ]>; ]
  in
  let decoH (x, y) wid hgt dpt =
    let xb = x +' margin-x in
    let widb = wid -' margin-x in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [ stroke gctx <[ (xb +' widb, y -' dptb) -- (xb, y -' dptb)
          -- (xb, y +' hgtb) -- (xb +' widb, y +' hgtb) ]>; ]
  in
  let decoT (x, y) wid hgt dpt =
    let xb = x in
    let widb = wid -' margin-x in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [ stroke gctx <[ (xb, y -' dptb) -- (xb +' widb, y -' dptb)
          -- (xb +' widb, y +' hgtb) -- (xb, y +' hgtb) ]>; ]
  in
  let decoM (x, y) wid hgt dpt =
    let xb = x in
    let widb = wid in
    let hgtb = hgt -' margin-y in
    let dptb = dpt -' margin-y in
      [
        stroke gctx <[ (xb, y -' dptb) -- (xb +' widb, y -' dptb) ]>;
        stroke gctx <[ (xb, y +' hgtb) -- (xb +' widb, y +' hgtb) ]>;
      ]
  in
    (decoS, decoH, decoM, decoT)

let-row ctx \inline-frame inner =
  let pads = (5pt, 5pt, 5pt, 5pt) in
  let br = lex-row ctx inner in
    (outer-frame-inline pads simple-decoset br)

let-col ctx +simple-replacement-test = lex-col ctx
  '< +p {Replaced text} >

module List
: sig
    val map : ('a -> 'b) -> 'a list -> 'b list
    val fold-left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
  end
= struct
    let map
      | f []        = []
      | f (x :: xs) = (f x) :: map f xs

    let fold-left
      | f init []        = init
      | f init (x :: xs) = fold-left f (f init x) xs
  end

let (+++>) = List.fold-left (+++)

let item-indent = 16pt

let bullet (x, y) =
  let cx = x +' 4pt in
  let cy = y +' 4pt in
  let r = 2pt in
  let t = r *' 0.5 in
  [
    fill default-graphics-context <[
      (cx -' r, cy)
      .. controls (cx -' r, cy +' t) and (cx -' t, cy +' r) ..
      (cx, cy +' r)
      .. controls (cx +' t, cy +' r) and (cx +' r, cy +' t) ..
      (cx +' r, cy)
      .. controls (cx +' r, cy -' t) and (cx +' t, cy -' r) ..
      (cx, cy -' r)
      .. controls (cx -' t, cy -' r) and (cx -' r, cy -' t) ..
      cycle
    ]>;
  ]

let item : context -> int -> itemize -> box-col
  | ctx depth (Item(parent, children)) =
      let br-bullet = (inline-graphics 8pt 8pt 0pt bullet) ++ (fixed-empty 8pt) in
      let bullet-width = get-natural-width br-bullet in
      let parent-indent = item-indent *' (float depth) in
      let br-parent =
        pbox-top ctx ((get-text-width ctx) -' parent-indent -' bullet-width) (function ctx ->
          form-paragraph ctx ((lex-row ctx parent) ++ outer-fil)
        )
      in
      let bc-parent =
        form-paragraph ctx
          ((fixed-empty parent-indent) ++ br-bullet ++ br-parent)
      in
      let bclst-children = List.map (item ctx (depth + 1)) children in
        bc-parent +++> bclst-children

let-col ctx +listing (Item(_, itmzlst)) =
  let bclst = List.map (item ctx 0) itmzlst in
    col-nil +++> bclst

let-col ctx +expand-leading inner =
  lex-col (ctx |> set-leading 32pt) inner

let-row ctx \parbox-top wid inner =
  pbox-top ctx wid (function ctx -> lex-col ctx inner)

let-col ctx +repeat n inner =
  let bc = lex-col ctx inner in
  let repeat acc i =
    if i >= n then acc else
      repeat (bc +++ acc) (i + 1)
  in
    repeat col-nil 0

let description ctx pairlst =
  let indent = 24pt in
  let bclst =
    pairlst |> List.map (function pair -> (
      match pair with
      | (item, descr) ->
          let br-item =
            let ctx-item =
              ctx |> set-font Latin (font `Hlv` 12pt)
            in
              lex-row ctx-item item
          in
          let br-descr = lex-row ctx descr in
          let br-pbox =
            pbox-top ctx ((get-text-width ctx) -' indent) (function ctx ->
              form-paragraph ctx ((fixed-empty (0pt -' indent)) ++ br-item ++ (fixed-empty 12pt) ++ br-descr ++ outer-fil)
            )
          in
            form-paragraph ctx ((fixed-empty indent) ++ br-pbox)
    ))
  in
    col-nil +++> bclst

let-col ctx +description pairlst =
  description ctx pairlst

let decoset-underline =
  let distance = 4pt in
  let gctx = default-graphics-context |> set-stroke-color (RGB(0., .5, 0.)) in
  let deco (x, y) wid _ _ =
    [ stroke gctx <[ (x, y -' distance) -- (x +' wid, y -' distance) ]>; ]
  in
    (deco, deco, deco, deco)

let-row ctx \underline inner =
  let pads = (0pt, 0pt, 0pt, 0pt) in
  let br = lex-row ctx inner in
    outer-frame-inline pads decoset-underline br
