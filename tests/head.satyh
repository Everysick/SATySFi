let-row ctx \emph inner =
  let ctx-emph =
    ctx |> set-font Latin (font `ArnoIt` 12pt)
        |> set-font HanIdeographic (font `Osaka` 10pt)
        |> set-font Kana (font `Osaka` 10pt)
        |> set-text-color (CMYK(1., 0., 0., 0.)) %(RGB(0., 0., 0.75))
  in
    lex-row ctx-emph inner

let-mutable ref-title <- {}
let-mutable ref-author <- {}

let-col ctx +document rcd inner =
  let title = rcd#title in
  let author = rcd#author in
  let ctx-doc =
    ctx |> set-font Latin (font `Arno` 12pt)
%        |> set-title title
        |> set-dominant-script Latin
  in
  (
    ref-title <- title before
    ref-author <- author before
    lex-col ctx-doc inner
  )

let gctx-title-frame =
  default-graphics-context
    |> set-line-width 5pt
    |> set-line-dash (Some(25pt, 3pt, 5pt))
    |> set-stroke-color (RGB(1., 0., 0.))
    |> set-fill-color (RGB(1., 0.75, 0.75))

let title-frame =
  let pads = (5pt, 5pt, 10pt, 10pt) in
  let cx = 12pt in
  let cy = 8pt in
  let deco (x, y) wid hgt dpt =
    let xL = x in
    let xR = x +' wid in
    let yT = y +' hgt in
    let yB = y +' dpt in
    let path =
      <[ (xL, yT)
           -- (xR, yT)
           .. controls (xR +' cx, yT -' cy) and (xR +' cx, yB +' cy)
           .. (xR, yB)
           -- (xL, yB)
           .. controls (xL -' cx, yB +' cy) and (xL -' cx, yT -' cy)
           .. cycle ]>
    in
      [
        fill gctx-title-frame path;
        stroke gctx-title-frame path;
      ]
  in
    outer-frame-block pads deco

let-col ctx +make-title =
%  let title = get-title ctx in
  let ctx-title = ctx |> set-font Latin (font `Arno` 36pt) in
  let ctx-author = ctx |> set-font Latin (font `Arno` 16pt) in
  let br-title = lex-row ctx-title (!ref-title) in
  let br-author = lex-row ctx-author (!ref-author) in
  let bc-title = form-paragraph ctx-title (title-frame (outer-fil ++ br-title ++ outer-fil)) in
  let bc-author = form-paragraph ctx-author (outer-fil ++ br-author) in
    bc-title +++ bc-author

let indent = fixed-empty 24pt

let indent-jp = fixed-empty 10pt

let-mutable needs-indentation <- true

let-col ctx +p inner =
  let br = lex-row ctx inner in
  let br-parag =
    if !needs-indentation then
      indent ++ br ++ outer-fil
    else
      let () = needs-indentation <- true in
        br ++ outer-fil
  in
    form-paragraph ctx br-parag

let-col ctx +frame inner =
    col-frame ctx (function ctx ->
      lex-col ctx inner)

let-col ctx +p-jp inner =
  let ctx-jp =
    ctx |> set-font HanIdeographic (font `KozMin` 10pt)
        |> set-font Kana (font `KozMin` 10pt)
        |> set-dominant-script HanIdeographic
  in
  let () = needs-indentation <- true in
  let br = lex-row ctx-jp inner in
    form-paragraph ctx (indent-jp ++ br ++ outer-fil)

let-mutable num-section <- 0

let-col ctx +section title inner =
  let ctx-title =
    ctx |> set-font Latin (font `Hlv` 18pt)
        |> set-font HanIdeographic (font `Osaka` 16pt)
        |> set-font Kana (font `Osaka` 16pt)
  in
  let () = num-section <- !num-section + 1 in
  let () = needs-indentation <- false in
  let br-num = lex-row ctx-title (embed ((arabic (!num-section)) ^ `.`)) in
  let br-title = lex-row ctx-title title in
  let bc-title = form-paragraph ctx (br-num ++ (fixed-empty 10pt) ++ br-title ++ (outer-fil)) in
  let bc-inner = lex-col ctx inner in
    bc-title +++ bc-inner

let-row ctx \expand-spaces inner =
  let ctx-inner = set-space-ratio 1.0 ctx in
    lex-row ctx-inner inner

let-col-detailed ctx +px inner =
  let br = lex-row ctx inner in
  let bc = form-paragraph ctx (indent ++ br ++ outer-fil) in
  let ctx-after = set-font Latin (font `ArnoIt` 12pt) ctx in
    (ctx-after, bc)

let simple-decoset =
  let margin-x = 2pt in
  let margin-y = 2pt in
  let gctx = default-graphics-context |> set-stroke-color (RGB(1., 0., 0.)) in
  let decoS (x, y) wid hgt dpt =
    let xb = x +' margin-x in
    let widb = wid -' (margin-x *' 2.) in
    let hgtb = hgt -' margin-y in
    let dptb = dpt +' margin-y in
      [ stroke gctx <[ (xb, y +' dptb) -- (xb, y +' hgtb)
          -- (xb +' widb, y +' hgtb) -- (xb +' widb, y +' dptb) -- cycle ]>; ]
  in
  let decoH (x, y) wid hgt dpt =
    let xb = x +' margin-x in
    let widb = wid -' margin-x in
    let hgtb = hgt -' margin-y in
    let dptb = dpt +' margin-y in
      [ stroke gctx <[ (xb +' widb, y +' dptb) -- (xb, y +' dptb)
          -- (xb, y +' hgtb) -- (xb +' widb, y +' hgtb) ]>; ]
  in
  let decoT (x, y) wid hgt dpt =
    let xb = x in
    let widb = wid -' margin-x in
    let hgtb = hgt -' margin-y in
    let dptb = dpt +' margin-y in
      [ stroke gctx <[ (xb, y +' dptb) -- (xb +' widb, y +' dptb)
          -- (xb +' widb, y +' hgtb) -- (xb, y +' hgtb) ]>; ]
  in
  let decoM (x, y) wid hgt dpt =
    let xb = x in
    let widb = wid in
    let hgtb = hgt -' margin-y in
    let dptb = dpt +' margin-y in
      [
        stroke gctx <[ (xb, y +' dptb) -- (xb +' widb, y +' dptb) ]>;
        stroke gctx <[ (xb, y +' hgtb) -- (xb +' widb, y +' hgtb) ]>;
      ]
  in
    (decoS, decoH, decoM, decoT)

let-row ctx \inline-frame inner =
  let pads = (5pt, 5pt, 5pt, 5pt) in
  let br = lex-row ctx inner in
    (outer-frame-inline pads simple-decoset br)

let-col ctx +simple-replacement-test = lex-col ctx
  '< +p {Replaced text} >

module List
: sig
    val map : ('a -> 'b) -> 'a list -> 'b list
    val fold-left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
  end
= struct
    let map
      | f []        = []
      | f (x :: xs) = (f x) :: map f xs

    let fold-left
      | f init []        = init
      | f init (x :: xs) = fold-left f (f init x) xs
  end

let (+++>) = List.fold-left (+++)

let item-indent = 16pt

let item : context -> int -> itemize -> box-col
  | ctx depth (Item(parent, children)) =
      let br-bullet = (lex-row ctx {\*}) ++ (fixed-empty 8pt) in
      let br-parent = lex-row ctx parent in
      let bc-parent =
        form-paragraph ctx
          ((fixed-empty (item-indent *' (float depth))) ++ br-bullet ++ br-parent ++ outer-fil)
      in
      let bclst-children = List.map (item ctx (depth + 1)) children in
        bc-parent +++> bclst-children

let-col ctx +listing (Item(_, itmzlst)) =
  let bclst = List.map (item ctx 1) itmzlst in
    col-nil +++> bclst

let-col ctx +expand-leading inner =
  lex-col (ctx |> set-leading 32pt) inner

let-row ctx \parbox-top wid inner =
  pbox-top ctx wid (function ctx -> lex-col ctx inner)

let-col ctx +repeat n inner =
  let bc = lex-col ctx inner in
  let repeat acc i =
    if i >= n then acc else
      repeat (bc +++ acc) (i + 1)
  in
    repeat col-nil 0
