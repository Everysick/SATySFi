// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions");
var Pervasives              = require("bs-platform/lib/js/pervasives");
var Hashtbl                 = require("bs-platform/lib/js/hashtbl");
var Display                 = require("./display");
var $$String                = require("bs-platform/lib/js/string");
var Types                   = require("./types");

var IllegalOut = Caml_exceptions.create("Out.IllegalOut");

function string_of_break_and_indent(indent) {
  return "\n" + (
          indent > 0 ? $$String.make((indent << 1), /* " " */32) : ""
        );
}

function main(value) {
  return stringify(0, erase_soft_break(flatten(value)));
}

function flatten(_value) {
  while(true) {
    var value = _value;
    var exit = 0;
    if (typeof value === "number") {
      switch (value) {
        case 0 : 
            return /* [] */0;
        case 2 : 
            return /* :: */[
                    /* OBreakAndIndent */0,
                    /* [] */0
                  ];
        case 3 : 
            return /* :: */[
                    /* OSoftBreakAndIndent */1,
                    /* [] */0
                  ];
        default:
          exit = 1;
      }
    }
    else {
      switch (value.tag | 0) {
        case 2 : 
            return /* :: */[
                    /* OString */[value[0]],
                    /* [] */0
                  ];
        case 3 : 
            return Pervasives.$at(/* :: */[
                        /* ODeepen */2,
                        /* [] */0
                      ], Pervasives.$at(flatten(value[0]), /* :: */[
                            /* OShallow */3,
                            /* [] */0
                          ]));
        case 4 : 
            var o1 = flatten(value[0]);
            var o2 = flatten(value[1]);
            if (o1) {
              var match = o1[0];
              if (typeof match === "number") {
                return Pervasives.$at(o1, o2);
              }
              else if (o1[1]) {
                return Pervasives.$at(o1, o2);
              }
              else if (o2) {
                var match$1 = o2[0];
                if (typeof match$1 === "number") {
                  return Pervasives.$at(o1, o2);
                }
                else {
                  return /* :: */[
                          /* OString */[match[0] + match$1[0]],
                          o2[1]
                        ];
                }
              }
              else {
                return Pervasives.$at(o1, o2);
              }
            }
            else {
              return Pervasives.$at(o1, o2);
            }
            break;
        case 26 : 
            var str_key = out(0, value[0]);
            try {
              var match$2 = Hashtbl.find(Types.global_hash_env, str_key)[0];
              var exit$1 = 0;
              if (typeof match$2 === "number") {
                exit$1 = 2;
              }
              else if (match$2.tag === 22) {
                _value = match$2[0][0];
                continue ;
                
              }
              else {
                exit$1 = 2;
              }
              if (exit$1 === 2) {
                Pervasives.print_string('!!!! reference key "' + (str_key + '" contains non-mutable value'));
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "../src/out.ml",
                        37,
                        18
                      ]
                    ];
              }
              
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                throw [
                      IllegalOut,
                      'undefined reference key "' + (str_key + '"')
                    ];
              }
              else {
                throw exn;
              }
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      Pervasives.print_string("!!!! cannot output\n\n    " + Display.string_of_ast(value));
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "../src/out.ml",
              45,
              8
            ]
          ];
    }
    
  };
}

function erase_soft_break(_opu) {
  while(true) {
    var opu = _opu;
    if (opu) {
      var head = opu[0];
      var exit = 0;
      if (typeof head === "number") {
        if (head !== 1) {
          if (head !== 0) {
            exit = 1;
          }
          else {
            var match = opu[1];
            if (match) {
              var match$1 = match[0];
              if (typeof match$1 === "number") {
                if (match$1 !== 1) {
                  exit = 1;
                }
                else {
                  _opu = /* :: */[
                    /* OBreakAndIndent */0,
                    match[1]
                  ];
                  continue ;
                  
                }
              }
              else {
                exit = 1;
              }
            }
            else {
              exit = 1;
            }
          }
        }
        else {
          var match$2 = opu[1];
          if (match$2) {
            var match$3 = match$2[0];
            if (typeof match$3 === "number") {
              switch (match$3) {
                case 0 : 
                    _opu = /* :: */[
                      /* OBreakAndIndent */0,
                      match$2[1]
                    ];
                    continue ;
                    case 1 : 
                    _opu = /* :: */[
                      /* OSoftBreakAndIndent */1,
                      match$2[1]
                    ];
                    continue ;
                    case 2 : 
                    exit = 1;
                    break;
                case 3 : 
                    _opu = /* :: */[
                      /* OShallow */3,
                      match$2[1]
                    ];
                    continue ;
                    
              }
            }
            else {
              exit = 1;
            }
          }
          else {
            exit = 1;
          }
        }
      }
      else {
        exit = 1;
      }
      if (exit === 1) {
        return /* :: */[
                head,
                erase_soft_break(opu[1])
              ];
      }
      
    }
    else {
      return /* [] */0;
    }
  };
}

function stringify(_indent, _opu) {
  while(true) {
    var opu = _opu;
    var indent = _indent;
    var exit = 0;
    var tail;
    if (opu) {
      var match = opu[0];
      if (typeof match === "number") {
        switch (match) {
          case 0 : 
              var tail$1 = opu[1];
              if (tail$1) {
                var match$1 = tail$1[0];
                if (typeof match$1 === "number") {
                  if (match$1 >= 3) {
                    tail = tail$1[1];
                    exit = 1;
                  }
                  else {
                    return string_of_break_and_indent(indent) + stringify(indent, tail$1);
                  }
                }
                else {
                  return string_of_break_and_indent(indent) + stringify(indent, tail$1);
                }
              }
              else {
                return string_of_break_and_indent(indent) + stringify(indent, tail$1);
              }
              break;
          case 1 : 
              var tail$2 = opu[1];
              if (tail$2) {
                var match$2 = tail$2[0];
                if (typeof match$2 === "number") {
                  if (match$2 >= 3) {
                    tail = tail$2[1];
                    exit = 1;
                  }
                  else {
                    return string_of_break_and_indent(indent) + stringify(indent, tail$2);
                  }
                }
                else {
                  return string_of_break_and_indent(indent) + stringify(indent, tail$2);
                }
              }
              else {
                return string_of_break_and_indent(indent) + stringify(indent, tail$2);
              }
              break;
          case 2 : 
              _opu = opu[1];
              _indent = indent + 1 | 0;
              continue ;
              case 3 : 
              _opu = opu[1];
              _indent = indent - 1 | 0;
              continue ;
              
        }
      }
      else {
        return match[0] + stringify(indent, opu[1]);
      }
    }
    else {
      return "";
    }
    if (exit === 1) {
      return string_of_break_and_indent(indent - 1 | 0) + stringify(indent - 1 | 0, tail);
    }
    
  };
}

function out(indent, value) {
  var exit = 0;
  if (typeof value === "number") {
    switch (value) {
      case 0 : 
          return "";
      case 2 : 
          throw [
                IllegalOut,
                "invalid string for reference key; it contains break"
              ];
      case 3 : 
          throw [
                IllegalOut,
                "invalid string for reference key; it contains soft break"
              ];
      default:
        exit = 1;
    }
  }
  else {
    switch (value.tag | 0) {
      case 2 : 
          return value[0];
      case 3 : 
          throw [
                IllegalOut,
                "invalid string for reference key; it contains 'deeper' operation"
              ];
      case 4 : 
          return out(indent, value[0]) + out(indent, value[1]);
      case 26 : 
          throw [
                IllegalOut,
                "invalid string for reference key; it contains '!!' operation"
              ];
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    Pervasives.print_string("!!!! cannot output\n\n    " + Display.string_of_ast(value));
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "../src/out.ml",
            101,
            28
          ]
        ];
  }
  
}

exports.IllegalOut = IllegalOut;
exports.main       = main;
/* Hashtbl Not a pure module */
