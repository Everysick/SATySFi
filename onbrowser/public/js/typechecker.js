// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Variantenv              = require("./variantenv");
var Range                   = require("./range");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions");
var Block                   = require("bs-platform/lib/js/block");
var Typeenv                 = require("./typeenv");
var Display                 = require("./display");
var Tyvarid                 = require("./tyvarid");
var Assoc                   = require("./assoc");
var Kindenv                 = require("./kindenv");
var Subst                   = require("./subst");
var List                    = require("bs-platform/lib/js/list");
var Types                   = require("./types");

var $$Error = Caml_exceptions.create("Typechecker.Error");

var final_tyenv = [Typeenv.empty];

var final_varntenv = [Variantenv.empty];

var final_kdenv = [Kindenv.empty];

function report_error_with_range(rng, msg) {
  throw [
        $$Error,
        "at " + (Range.to_string(rng) + (":\n    " + msg))
      ];
}

function typecheck(qtfbl, varntenv, kdenv, tyenv, param) {
  var utastmain = param[1];
  var rng = param[0];
  var typecheck_iter = function ($staropt$star, $staropt$star$1, k, t) {
    var q = $staropt$star ? $staropt$star[0] : qtfbl;
    var v = $staropt$star$1 ? $staropt$star$1[0] : varntenv;
    return function (param) {
      return typecheck(q, v, k, t, param);
    };
  };
  if (typeof utastmain === "number") {
    switch (utastmain) {
      case 0 : 
          return /* tuple */[
                  /* StringEmpty */0,
                  /* tuple */[
                    rng,
                    /* StringType */2
                  ],
                  Subst.empty,
                  kdenv
                ];
      case 1 : 
          return /* tuple */[
                  /* UnitConstant */1,
                  /* tuple */[
                    rng,
                    /* UnitType */0
                  ],
                  Subst.empty,
                  kdenv
                ];
      case 2 : 
          return /* tuple */[
                  /* SoftBreakAndIndent */3,
                  /* tuple */[
                    rng,
                    /* StringType */2
                  ],
                  Subst.empty,
                  kdenv
                ];
      case 3 : 
          var tvid = Tyvarid.fresh(qtfbl);
          var beta_001 = /* TypeVariable */Block.__(4, [tvid]);
          var beta = /* tuple */[
            rng,
            beta_001
          ];
          return /* tuple */[
                  /* EndOfList */4,
                  /* tuple */[
                    rng,
                    /* ListType */Block.__(1, [beta])
                  ],
                  Subst.empty,
                  Kindenv.add(kdenv, tvid, /* UniversalKind */0)
                ];
      case 4 : 
          return /* tuple */[
                  /* EndOfTuple */5,
                  /* tuple */[
                    rng,
                    /* ProductType */Block.__(3, [/* [] */0])
                  ],
                  Subst.empty,
                  kdenv
                ];
      case 5 : 
          final_tyenv[0] = tyenv;
          final_varntenv[0] = varntenv;
          final_kdenv[0] = kdenv;
          return /* tuple */[
                  /* FinishHeaderFile */6,
                  /* tuple */[
                    Range.dummy("finish-header-file"),
                    /* UnitType */0
                  ],
                  Subst.empty,
                  kdenv
                ];
      
    }
  }
  else {
    switch (utastmain.tag | 0) {
      case 0 : 
          return /* tuple */[
                  /* NumericConstant */Block.__(0, [utastmain[0]]),
                  /* tuple */[
                    rng,
                    /* IntType */1
                  ],
                  Subst.empty,
                  kdenv
                ];
      case 1 : 
          return /* tuple */[
                  /* BooleanConstant */Block.__(1, [utastmain[0]]),
                  /* tuple */[
                    rng,
                    /* BoolType */3
                  ],
                  Subst.empty,
                  kdenv
                ];
      case 2 : 
          return /* tuple */[
                  /* StringConstant */Block.__(2, [utastmain[0]]),
                  /* tuple */[
                    rng,
                    /* StringType */2
                  ],
                  Subst.empty,
                  kdenv
                ];
      case 3 : 
          var utast2 = utastmain[1];
          var utast1 = utastmain[0];
          var match = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utast1);
          var match$1 = Subst.unify(match[3], match[1], /* tuple */[
                Types.get_range(utast1),
                /* StringType */2
              ]);
          var thetaU1 = Subst.compose(match$1[0], match[2]);
          var match$2 = typecheck_iter(/* None */0, /* None */0, match$1[1], Subst.apply_to_type_environment(thetaU1, tyenv))(utast2);
          var kdenv2 = match$2[3];
          var match$3 = Subst.unify(kdenv2, match$2[1], /* tuple */[
                Types.get_range(utast2),
                /* StringType */2
              ]);
          return /* tuple */[
                  /* Concat */Block.__(4, [
                      match[0],
                      match$2[0]
                    ]),
                  /* tuple */[
                    rng,
                    /* StringType */2
                  ],
                  Subst.compose(match$3[0], Subst.compose(match$2[2], thetaU1)),
                  kdenv2
                ];
      case 4 : 
          var match$4 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[0]);
          var thetaH = match$4[2];
          var tyH = match$4[1];
          var match$5 = typecheck_iter(/* None */0, /* None */0, match$4[3], Subst.apply_to_type_environment(thetaH, tyenv))(utastmain[1]);
          var thetaT = match$5[2];
          var match$6 = Subst.unify(match$5[3], match$5[1], /* tuple */[
                Range.dummy("list-cons"),
                /* ListType */Block.__(1, [tyH])
              ]);
          var thetaU = match$6[0];
          var tyres_001 = /* ListType */Block.__(1, [Subst.apply_to_type_struct(Subst.compose(thetaU, thetaT), tyH)]);
          var tyres = /* tuple */[
            rng,
            tyres_001
          ];
          return /* tuple */[
                  /* ListCons */Block.__(7, [
                      match$4[0],
                      match$5[0]
                    ]),
                  tyres,
                  Subst.compose(thetaU, Subst.compose(thetaT, thetaH)),
                  match$6[1]
                ];
      case 5 : 
          var match$7 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[0]);
          var thetaH$1 = match$7[2];
          var match$8 = typecheck_iter(/* None */0, /* None */0, match$7[3], Subst.apply_to_type_environment(thetaH$1, tyenv))(utastmain[1]);
          var match$9 = match$8[1][1];
          var tyres$1;
          if (typeof match$9 === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "../src/typechecker.ml",
                    232,
                    38
                  ]
                ];
          }
          else if (match$9.tag === 3) {
            tyres$1 = /* tuple */[
              rng,
              /* ProductType */Block.__(3, [/* :: */[
                    match$7[1],
                    match$9[0]
                  ]])
            ];
          }
          else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "../src/typechecker.ml",
                    232,
                    38
                  ]
                ];
          }
          return /* tuple */[
                  /* TupleCons */Block.__(8, [
                      match$7[0],
                      match$8[0]
                    ]),
                  tyres$1,
                  Subst.compose(match$8[2], thetaH$1),
                  match$8[3]
                ];
      case 6 : 
          var qtfbl$1 = qtfbl;
          var varntenv$1 = varntenv;
          var kdenv$1 = kdenv;
          var tyenv$1 = tyenv;
          var flutlst = utastmain[0];
          var rng$1 = rng;
          var aux = function (_kdenv, _tyenv, _lst, _accelst, _acctylst, _acctheta) {
            while(true) {
              var acctheta = _acctheta;
              var acctylst = _acctylst;
              var accelst = _accelst;
              var lst = _lst;
              var tyenv = _tyenv;
              var kdenv = _kdenv;
              if (lst) {
                var match = lst[0];
                var fldnmX = match[0];
                var match$1 = typecheck(qtfbl$1, varntenv$1, kdenv, tyenv, match[1]);
                var thetaX = match$1[2];
                _acctheta = Subst.compose(thetaX, acctheta);
                _acctylst = /* :: */[
                  /* tuple */[
                    fldnmX,
                    match$1[1]
                  ],
                  acctylst
                ];
                _accelst = /* :: */[
                  /* tuple */[
                    fldnmX,
                    match$1[0]
                  ],
                  accelst
                ];
                _lst = lst[1];
                _tyenv = Subst.apply_to_type_environment(thetaX, tyenv);
                _kdenv = match$1[3];
                continue ;
                
              }
              else {
                return /* tuple */[
                        List.rev(accelst),
                        List.rev(acctylst),
                        acctheta,
                        kdenv
                      ];
              }
            };
          };
          var match$10 = aux(kdenv$1, tyenv$1, flutlst, /* [] */0, /* [] */0, Subst.empty);
          var thetares = match$10[2];
          var tylstfinal = List.map(function (param) {
                return /* tuple */[
                        param[0],
                        Subst.apply_to_type_struct(thetares, param[1])
                      ];
              }, match$10[1]);
          return /* tuple */[
                  /* Record */Block.__(9, [Assoc.of_list(/* None */0, match$10[0])]),
                  /* tuple */[
                    rng$1,
                    /* RecordType */Block.__(9, [Assoc.of_list(/* None */0, tylstfinal)])
                  ],
                  thetares,
                  match$10[3]
                ];
      case 7 : 
          var fldnm = utastmain[1];
          var utast1$1 = utastmain[0];
          var match$11 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utast1$1);
          var tvid1 = Tyvarid.fresh(qtfbl);
          var beta1_000 = Types.get_range(utast1$1);
          var beta1_001 = /* TypeVariable */Block.__(4, [tvid1]);
          var beta1 = /* tuple */[
            beta1_000,
            beta1_001
          ];
          var tvidF = Tyvarid.fresh(qtfbl);
          var betaF_001 = /* TypeVariable */Block.__(4, [tvidF]);
          var betaF = /* tuple */[
            rng,
            betaF_001
          ];
          var kdenvnew = Kindenv.add(Kindenv.add(kdenv, tvidF, /* UniversalKind */0), tvid1, /* RecordKind */[Assoc.of_list(/* None */0, /* :: */[
                      /* tuple */[
                        fldnm,
                        betaF
                      ],
                      /* [] */0
                    ])]);
          "#Kinds(access) " + (Display.string_of_kind_environment(kdenvnew) + "\n");
          var match$12 = Subst.unify(kdenvnew, beta1, match$11[1]);
          var thetaU$1 = match$12[0];
          return /* tuple */[
                  /* AccessField */Block.__(10, [
                      match$11[0],
                      fldnm
                    ]),
                  Subst.apply_to_type_struct(thetaU$1, betaF),
                  Subst.compose(thetaU$1, match$11[2]),
                  match$12[1]
                ];
      case 8 : 
          var varnm = utastmain[0];
          try {
            var tyforall = Typeenv.find(tyenv, varnm);
            var match$13 = Typeenv.make_bounded_free(qtfbl, kdenv, tyforall);
            var kdenvfree = match$13[2];
            var tyres$2 = Typeenv.overwrite_range_of_type(match$13[0], rng);
            "#Content " + (varnm + (" : " + (Display.string_of_type_struct_basic(tyforall) + (" = " + (Display.string_of_type_struct_basic(tyres$2) + (" (" + (Range.to_string(rng) + ")\n")))))));
            "#Kinds(old) " + (Display.string_of_kind_environment(kdenv) + "\n");
            "#Kinds(new) " + (Display.string_of_kind_environment(kdenvfree) + "\n");
            return /* tuple */[
                    /* ContentOf */Block.__(12, [varnm]),
                    tyres$2,
                    Subst.empty,
                    kdenvfree
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return report_error_with_range(rng, "undefined variable '" + (varnm + "'"));
            }
            else {
              throw exn;
            }
          }
          break;
      case 9 : 
          var utast1$2 = utastmain[0];
          var match$14 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utast1$2);
          var theta1 = match$14[2];
          var ty1 = match$14[1];
          var e1 = match$14[0];
          var match$15 = typecheck_iter(/* None */0, /* None */0, match$14[3], Subst.apply_to_type_environment(theta1, tyenv))(utastmain[1]);
          var kdenv2$1 = match$15[3];
          var theta2 = match$15[2];
          var ty2 = match$15[1];
          var e2 = match$15[0];
          var ty1new = Subst.apply_to_type_struct(theta2, ty1);
          var match$16 = ty1new[1];
          var exit = 0;
          if (typeof match$16 === "number") {
            exit = 1;
          }
          else if (match$16.tag) {
            exit = 1;
          }
          else {
            var tycod = match$16[1];
            var match$17 = Subst.unify(kdenv2$1, match$16[0], ty2);
            var thetaU$2 = match$17[0];
            "1 " + (Display.string_of_ast(/* Apply */Block.__(15, [
                      e1,
                      e2
                    ])) + (" : " + (Display.string_of_type_struct_basic(Subst.apply_to_type_struct(thetaU$2, tycod)) + "\n")));
            Subst.string_of_subst(Subst.compose(thetaU$2, Subst.compose(theta2, theta1))) + "\n";
            return /* tuple */[
                    /* Apply */Block.__(15, [
                        e1,
                        e2
                      ]),
                    Subst.apply_to_type_struct(thetaU$2, tycod),
                    Subst.compose(thetaU$2, Subst.compose(theta2, theta1)),
                    match$17[1]
                  ];
          }
          if (exit === 1) {
            var tvid$1 = Tyvarid.fresh(qtfbl);
            var beta_001$1 = /* TypeVariable */Block.__(4, [tvid$1]);
            var beta$1 = /* tuple */[
              rng,
              beta_001$1
            ];
            var match$18 = Subst.unify(Kindenv.add(kdenv2$1, tvid$1, /* UniversalKind */0), Subst.apply_to_type_struct(theta2, ty1), /* tuple */[
                  Types.get_range(utast1$2),
                  /* FuncType */Block.__(0, [
                      ty2,
                      beta$1
                    ])
                ]);
            var thetaU$3 = match$18[0];
            "2 " + (Display.string_of_ast(/* Apply */Block.__(15, [
                      e1,
                      e2
                    ])) + (" : " + (Display.string_of_type_struct_basic(beta$1) + (" = " + (Display.string_of_type_struct_basic(Subst.apply_to_type_struct(thetaU$3, beta$1)) + "\n")))));
            Subst.string_of_subst(Subst.compose(thetaU$3, Subst.compose(theta2, theta1))) + "\n";
            return /* tuple */[
                    /* Apply */Block.__(15, [
                        e1,
                        e2
                      ]),
                    Subst.apply_to_type_struct(thetaU$3, beta$1),
                    Subst.compose(thetaU$3, Subst.compose(theta2, theta1)),
                    match$18[1]
                  ];
          }
          break;
      case 10 : 
          var match$19 = make_type_environment_by_let(qtfbl, varntenv, kdenv, tyenv, utastmain[0]);
          var match$20 = typecheck_iter(/* None */0, /* None */0, match$19[0], match$19[1])(utastmain[1]);
          return /* tuple */[
                  /* LetIn */Block.__(11, [
                      match$19[3],
                      match$20[0]
                    ]),
                  match$20[1],
                  Subst.compose(match$20[2], match$19[4]),
                  match$20[3]
                ];
      case 11 : 
          var match$21 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[0]);
          var match$22 = Subst.unify(match$21[3], match$21[1], /* tuple */[
                Range.dummy("if-bool"),
                /* BoolType */3
              ]);
          var thetaUB = Subst.compose(match$22[0], match$21[2]);
          var match$23 = typecheck_iter(/* None */0, /* None */0, match$22[1], Subst.apply_to_type_environment(thetaUB, tyenv))(utastmain[1]);
          var ty1$1 = match$23[1];
          var theta1UB = Subst.compose(match$23[2], thetaUB);
          var match$24 = typecheck_iter(/* None */0, /* None */0, match$23[3], Subst.apply_to_type_environment(theta1UB, tyenv))(utastmain[2]);
          var theta2$1 = match$24[2];
          var match$25 = Subst.unify(match$24[3], match$24[1], ty1$1);
          var thetaV = match$25[0];
          return /* tuple */[
                  /* IfThenElse */Block.__(13, [
                      match$21[0],
                      match$23[0],
                      match$24[0]
                    ]),
                  Subst.apply_to_type_struct(Subst.compose(thetaV, theta2$1), ty1$1),
                  Subst.compose(thetaV, Subst.compose(theta2$1, theta1UB)),
                  match$25[1]
                ];
      case 12 : 
          var varnm$1 = utastmain[1];
          var tvid$2 = Tyvarid.fresh(qtfbl);
          var beta_000 = utastmain[0];
          var beta_001$2 = /* TypeVariable */Block.__(4, [tvid$2]);
          var beta$2 = /* tuple */[
            beta_000,
            beta_001$2
          ];
          var match$26 = typecheck_iter(/* None */0, /* None */0, Kindenv.add(kdenv, tvid$2, /* UniversalKind */0), Typeenv.add(tyenv, varnm$1, beta$2))(utastmain[2]);
          var theta1$1 = match$26[2];
          var tydom = Subst.apply_to_type_struct(theta1$1, beta$2);
          return /* tuple */[
                  /* LambdaAbstract */Block.__(14, [
                      varnm$1,
                      match$26[0]
                    ]),
                  /* tuple */[
                    rng,
                    /* FuncType */Block.__(0, [
                        tydom,
                        match$26[1]
                      ])
                  ],
                  theta1$1,
                  match$26[3]
                ];
      case 13 : 
          var match$27 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[0]);
          var thetaO = match$27[2];
          var tvid$3 = Tyvarid.fresh(qtfbl);
          var beta_000$1 = Range.dummy("ut-pattern-match");
          var beta_001$3 = /* TypeVariable */Block.__(4, [tvid$3]);
          var beta$3 = /* tuple */[
            beta_000$1,
            beta_001$3
          ];
          var match$28 = typecheck_pattern_match_cons(qtfbl, varntenv, Kindenv.add(match$27[3], tvid$3, /* UniversalKind */0), Subst.apply_to_type_environment(thetaO, tyenv), utastmain[1], match$27[1], thetaO, beta$3);
          return /* tuple */[
                  /* PatternMatch */Block.__(16, [
                      match$27[0],
                      match$28[0]
                    ]),
                  match$28[1],
                  Subst.compose(match$28[2], thetaO),
                  match$28[3]
                ];
      case 14 : 
          var constrnm = utastmain[0];
          try {
            var match$29 = Variantenv.find(varntenv, constrnm);
            var match$30 = Typeenv.make_bounded_free(qtfbl, kdenv, match$29[1]);
            var match$31 = typecheck_iter(/* None */0, /* None */0, match$30[2], tyenv)(utastmain[1]);
            var match$32 = Subst.unify(match$31[3], match$31[1], match$30[0]);
            var thetaU1$1 = Subst.compose(match$32[0], match$31[2]);
            var tyres$3 = Typeenv.overwrite_range_of_type(Subst.apply_to_type_struct(thetaU1$1, /* tuple */[
                      rng,
                      /* VariantType */Block.__(6, [
                          match$30[1],
                          match$29[0]
                        ])
                    ]), rng);
            return /* tuple */[
                    /* Constructor */Block.__(17, [
                        constrnm,
                        match$31[0]
                      ]),
                    tyres$3,
                    thetaU1$1,
                    match$32[1]
                  ];
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return report_error_with_range(rng, "undefined constructor '" + (constrnm + "'"));
            }
            else {
              throw exn$1;
            }
          }
          break;
      case 15 : 
          var varntenvnew = Variantenv.add_mutual_cons(/* GlobalScope */0, varntenv, utastmain[0]);
          return typecheck_iter(/* None */0, /* Some */[varntenvnew], kdenv, tyenv)(utastmain[1]);
      case 16 : 
          throw [
                Caml_builtin_exceptions.match_failure,
                [
                  "../src/typechecker.ml",
                  27,
                  2
                ]
              ];
      case 17 : 
          var varnm$2 = utastmain[1];
          var match$33 = make_type_environment_by_let_mutable(varntenv, kdenv, tyenv, utastmain[0], varnm$2, utastmain[2]);
          var match$34 = typecheck_iter(/* None */0, /* None */0, match$33[4], match$33[0])(utastmain[3]);
          return /* tuple */[
                  /* LetMutableIn */Block.__(18, [
                      varnm$2,
                      match$33[1],
                      match$34[0]
                    ]),
                  match$34[1],
                  Subst.compose(match$34[2], match$33[3]),
                  match$34[3]
                ];
      case 18 : 
          var utast1$3 = utastmain[0];
          var match$35 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utast1$3);
          var match$36 = Subst.unify(match$35[3], match$35[1], /* tuple */[
                Types.get_range(utast1$3),
                /* UnitType */0
              ]);
          var thetaU1$2 = Subst.compose(match$36[0], match$35[2]);
          var match$37 = typecheck_iter(/* None */0, /* None */0, match$36[1], Subst.apply_to_type_environment(thetaU1$2, tyenv))(utastmain[1]);
          return /* tuple */[
                  /* Sequential */Block.__(19, [
                      match$35[0],
                      match$37[0]
                    ]),
                  match$37[1],
                  Subst.compose(match$37[2], thetaU1$2),
                  match$37[3]
                ];
      case 19 : 
          var utastC = utastmain[1];
          var utastB = utastmain[0];
          var match$38 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastB);
          var match$39 = Subst.unify(match$38[3], match$38[1], /* tuple */[
                Types.get_range(utastB),
                /* BoolType */3
              ]);
          var thetaUB$1 = Subst.compose(match$39[0], match$38[2]);
          var match$40 = typecheck_iter(/* None */0, /* None */0, match$39[1], Subst.apply_to_type_environment(thetaUB$1, tyenv))(utastC);
          var kdenvC = match$40[3];
          var match$41 = Subst.unify(kdenvC, match$40[1], /* tuple */[
                Types.get_range(utastC),
                /* UnitType */0
              ]);
          return /* tuple */[
                  /* WhileDo */Block.__(20, [
                      match$38[0],
                      match$40[0]
                    ]),
                  /* tuple */[
                    rng,
                    /* UnitType */0
                  ],
                  Subst.compose(match$41[0], Subst.compose(match$40[2], thetaUB$1)),
                  kdenvC
                ];
      case 20 : 
          var utastI = utastmain[1];
          var utastK = utastmain[0];
          var match$42 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastK);
          var match$43 = Subst.unify(match$42[3], match$42[1], /* tuple */[
                Types.get_range(utastK),
                /* StringType */2
              ]);
          var thetaUK = Subst.compose(match$43[0], match$42[2]);
          var match$44 = typecheck_iter(/* None */0, /* None */0, match$43[1], Subst.apply_to_type_environment(thetaUK, tyenv))(utastI);
          var match$45 = Subst.unify(match$44[3], match$44[1], /* tuple */[
                Types.get_range(utastI),
                /* StringType */2
              ]);
          return /* tuple */[
                  /* DeclareGlobalHash */Block.__(24, [
                      match$42[0],
                      match$44[0]
                    ]),
                  /* tuple */[
                    rng,
                    /* UnitType */0
                  ],
                  Subst.compose(match$45[0], Subst.compose(match$44[2], thetaUK)),
                  match$45[1]
                ];
      case 21 : 
          var utastN = utastmain[1];
          var utastK$1 = utastmain[0];
          var match$46 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastK$1);
          var match$47 = Subst.unify(match$46[3], match$46[1], /* tuple */[
                Types.get_range(utastK$1),
                /* StringType */2
              ]);
          var thetaUK$1 = Subst.compose(match$47[0], match$46[2]);
          var match$48 = typecheck_iter(/* None */0, /* None */0, match$47[1], Subst.apply_to_type_environment(thetaUK$1, tyenv))(utastN);
          var match$49 = Subst.unify(match$48[3], match$48[1], /* tuple */[
                Types.get_range(utastN),
                /* StringType */2
              ]);
          return /* tuple */[
                  /* OverwriteGlobalHash */Block.__(25, [
                      match$46[0],
                      match$48[0]
                    ]),
                  /* tuple */[
                    rng,
                    /* UnitType */0
                  ],
                  Subst.compose(match$49[0], Subst.compose(match$48[2], thetaUK$1)),
                  match$49[1]
                ];
      case 22 : 
          var utastN$1 = utastmain[2];
          var varnm$3 = utastmain[1];
          var match$50 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(/* tuple */[
                utastmain[0],
                /* UTContentOf */Block.__(8, [varnm$3])
              ]);
          var match$51 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastN$1);
          var match$52 = Subst.unify(match$51[3], match$50[1], /* tuple */[
                Types.get_range(utastN$1),
                /* RefType */Block.__(2, [match$51[1]])
              ]);
          return /* tuple */[
                  /* Overwrite */Block.__(21, [
                      varnm$3,
                      match$51[0]
                    ]),
                  /* tuple */[
                    rng,
                    /* UnitType */0
                  ],
                  Subst.compose(match$52[0], match$51[2]),
                  match$52[1]
                ];
      case 23 : 
          var match$53 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[0]);
          var match$54 = Subst.unify(match$53[3], match$53[1], /* tuple */[
                rng,
                /* StringType */2
              ]);
          return /* tuple */[
                  /* ReferenceFinal */Block.__(26, [match$53[0]]),
                  /* tuple */[
                    rng,
                    /* StringType */2
                  ],
                  Subst.compose(match$54[0], match$53[2]),
                  match$54[1]
                ];
      case 24 : 
          var match$55 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[0]);
          return /* tuple */[
                  /* LazyContent */Block.__(27, [match$55[0]]),
                  match$55[1],
                  match$55[2],
                  match$55[3]
                ];
      case 25 : 
          var match$56 = typecheck_itemize(qtfbl, varntenv, kdenv, tyenv, utastmain[0], Subst.empty);
          return /* tuple */[
                  match$56[0],
                  /* tuple */[
                    rng,
                    /* VariantType */Block.__(6, [
                        /* [] */0,
                        "itemize"
                      ])
                  ],
                  match$56[1],
                  match$56[2]
                ];
      case 26 : 
          var dr = Range.dummy("ut-apply-class-and-id");
          var tyenv1 = Typeenv.add(tyenv, "class-name", /* tuple */[
                dr,
                /* VariantType */Block.__(6, [
                    /* :: */[
                      /* tuple */[
                        dr,
                        /* StringType */2
                      ],
                      /* [] */0
                    ],
                    "maybe"
                  ])
              ]);
          var tyenv_new = Typeenv.add(tyenv1, "id-name", /* tuple */[
                dr,
                /* VariantType */Block.__(6, [
                    /* :: */[
                      /* tuple */[
                        dr,
                        /* StringType */2
                      ],
                      /* [] */0
                    ],
                    "maybe"
                  ])
              ]);
          var match$57 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[0]);
          var match$58 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv)(utastmain[1]);
          var match$59 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv_new)(utastmain[2]);
          return /* tuple */[
                  /* ApplyClassAndID */Block.__(29, [
                      match$57[0],
                      match$58[0],
                      match$59[0]
                    ]),
                  match$59[1],
                  match$59[2],
                  match$59[3]
                ];
      case 27 : 
          var dr$1 = Range.dummy("ut-class-and-id-region");
          var tyenv1$1 = Typeenv.add(tyenv, "class-name", /* tuple */[
                dr$1,
                /* VariantType */Block.__(6, [
                    /* :: */[
                      /* tuple */[
                        dr$1,
                        /* StringType */2
                      ],
                      /* [] */0
                    ],
                    "maybe"
                  ])
              ]);
          var tyenv_new$1 = Typeenv.add(tyenv1$1, "id-name", /* tuple */[
                dr$1,
                /* VariantType */Block.__(6, [
                    /* :: */[
                      /* tuple */[
                        dr$1,
                        /* StringType */2
                      ],
                      /* [] */0
                    ],
                    "maybe"
                  ])
              ]);
          var match$60 = typecheck_iter(/* None */0, /* None */0, kdenv, tyenv_new$1)(utastmain[0]);
          return /* tuple */[
                  match$60[0],
                  match$60[1],
                  match$60[2],
                  match$60[3]
                ];
      
    }
  }
}

function typecheck_itemize(qtfbl, varntenv, kdenv, tyenv, param, acctheta) {
  var tyenv1 = Subst.apply_to_type_environment(acctheta, tyenv);
  var match = typecheck(qtfbl, varntenv, kdenv, tyenv1, param[0]);
  var match$1 = Subst.unify(match[3], match[1], /* tuple */[
        Range.dummy("typecheck_itemize_string"),
        /* StringType */2
      ]);
  var thetaU1a = Subst.compose(match$1[0], Subst.compose(match[2], acctheta));
  var match$2 = typecheck_itemize_list(qtfbl, varntenv, match$1[1], Subst.apply_to_type_environment(thetaU1a, tyenv1), param[1], thetaU1a);
  return /* tuple */[
          /* Constructor */Block.__(17, [
              "Item",
              /* TupleCons */Block.__(8, [
                  match[0],
                  /* TupleCons */Block.__(8, [
                      match$2[0],
                      /* EndOfTuple */5
                    ])
                ])
            ]),
          match$2[1],
          match$2[2]
        ];
}

function typecheck_itemize_list(qtfbl, varntenv, kdenv, tyenv, utitmzlst, acctheta) {
  if (utitmzlst) {
    var match = typecheck_itemize(qtfbl, varntenv, kdenv, tyenv, utitmzlst[0], acctheta);
    var thetahd = match[1];
    var match$1 = typecheck_itemize_list(qtfbl, varntenv, match[2], Subst.apply_to_type_environment(thetahd, tyenv), utitmzlst[1], thetahd);
    return /* tuple */[
            /* ListCons */Block.__(7, [
                match[0],
                match$1[0]
              ]),
            match$1[1],
            match$1[2]
          ];
  }
  else {
    return /* tuple */[
            /* EndOfList */4,
            acctheta,
            kdenv
          ];
  }
}

function typecheck_pattern_match_cons(qtfbl, varntenv, kdenv, tyenv, utpmcons, tyobj, acctheta, tyres) {
  var iter = function (param, param$1, param$2, param$3, param$4, param$5) {
    return typecheck_pattern_match_cons(qtfbl, varntenv, param, param$1, param$2, param$3, param$4, param$5);
  };
  if (typeof utpmcons === "number") {
    return /* tuple */[
            /* EndOfPatternMatch */0,
            tyres,
            acctheta,
            kdenv
          ];
  }
  else if (utpmcons.tag) {
    var match = typecheck_pattern(qtfbl, varntenv, kdenv, tyenv, utpmcons[0]);
    var tyenvpat = match[2];
    var match$1 = Subst.unify(match[3], match[1], tyobj);
    var match$2 = typecheck(qtfbl, varntenv, match$1[1], tyenvpat, utpmcons[1]);
    var match$3 = Subst.unify(match$2[3], match$2[1], /* tuple */[
          Range.dummy("pattern-match-cons-when"),
          /* BoolType */3
        ]);
    var thetaWBUa = Subst.compose(match$3[0], Subst.compose(match$2[2], Subst.compose(match$1[0], acctheta)));
    var match$4 = typecheck(qtfbl, varntenv, match$3[1], Subst.apply_to_type_environment(thetaWBUa, tyenvpat), utpmcons[2]);
    var match$5 = Subst.unify(match$4[3], match$4[1], tyres);
    var thetaV1WBUa = Subst.compose(match$5[0], Subst.compose(match$4[2], thetaWBUa));
    var match$6 = iter(match$5[1], Subst.apply_to_type_environment(thetaV1WBUa, tyenv), utpmcons[3], Subst.apply_to_type_struct(thetaV1WBUa, tyobj), thetaV1WBUa, Subst.apply_to_type_struct(thetaV1WBUa, tyres));
    return /* tuple */[
            /* PatternMatchConsWhen */Block.__(1, [
                match[0],
                match$2[0],
                match$4[0],
                match$6[0]
              ]),
            match$6[1],
            match$6[2],
            match$6[3]
          ];
  }
  else {
    var match$7 = typecheck_pattern(qtfbl, varntenv, kdenv, tyenv, utpmcons[0]);
    var match$8 = Subst.unify(match$7[3], match$7[1], tyobj);
    var thetaUa = Subst.compose(match$8[0], acctheta);
    var match$9 = typecheck(qtfbl, varntenv, match$8[1], Subst.apply_to_type_environment(thetaUa, match$7[2]), utpmcons[1]);
    var match$10 = Subst.unify(match$9[3], match$9[1], tyres);
    var thetaV1Ua = Subst.compose(match$10[0], Subst.compose(match$9[2], thetaUa));
    var match$11 = iter(match$10[1], Subst.apply_to_type_environment(thetaV1Ua, tyenv), utpmcons[2], Subst.apply_to_type_struct(thetaV1Ua, tyobj), thetaV1Ua, Subst.apply_to_type_struct(thetaV1Ua, tyres));
    return /* tuple */[
            /* PatternMatchCons */Block.__(0, [
                match$7[0],
                match$9[0],
                match$11[0]
              ]),
            match$11[1],
            match$11[2],
            match$11[3]
          ];
  }
}

function typecheck_pattern(qtfbl, varntenv, kdenv, tyenv, param) {
  var utpatmain = param[1];
  var rng = param[0];
  var iter = function (param, param$1, param$2) {
    return typecheck_pattern(qtfbl, varntenv, param, param$1, param$2);
  };
  if (typeof utpatmain === "number") {
    switch (utpatmain) {
      case 0 : 
          return /* tuple */[
                  /* PUnitConstant */0,
                  /* tuple */[
                    rng,
                    /* UnitType */0
                  ],
                  tyenv,
                  kdenv
                ];
      case 1 : 
          var tvid = Tyvarid.fresh(qtfbl);
          var beta_001 = /* TypeVariable */Block.__(4, [tvid]);
          var beta = /* tuple */[
            rng,
            beta_001
          ];
          return /* tuple */[
                  /* PEndOfList */1,
                  /* tuple */[
                    rng,
                    /* ListType */Block.__(1, [beta])
                  ],
                  tyenv,
                  Kindenv.add(kdenv, tvid, /* UniversalKind */0)
                ];
      case 2 : 
          return /* tuple */[
                  /* PEndOfTuple */2,
                  /* tuple */[
                    rng,
                    /* ProductType */Block.__(3, [/* [] */0])
                  ],
                  tyenv,
                  kdenv
                ];
      case 3 : 
          var tvid$1 = Tyvarid.fresh(qtfbl);
          var beta_001$1 = /* TypeVariable */Block.__(4, [tvid$1]);
          var beta$1 = /* tuple */[
            rng,
            beta_001$1
          ];
          return /* tuple */[
                  /* PWildCard */3,
                  beta$1,
                  tyenv,
                  Kindenv.add(kdenv, tvid$1, /* UniversalKind */0)
                ];
      
    }
  }
  else {
    switch (utpatmain.tag | 0) {
      case 0 : 
          return /* tuple */[
                  /* PNumericConstant */Block.__(0, [utpatmain[0]]),
                  /* tuple */[
                    rng,
                    /* IntType */1
                  ],
                  tyenv,
                  kdenv
                ];
      case 1 : 
          return /* tuple */[
                  /* PBooleanConstant */Block.__(1, [utpatmain[0]]),
                  /* tuple */[
                    rng,
                    /* BoolType */3
                  ],
                  tyenv,
                  kdenv
                ];
      case 2 : 
          var match = typecheck(qtfbl, varntenv, kdenv, tyenv, utpatmain[0]);
          var match$1 = Subst.unify(match[3], /* tuple */[
                Range.dummy("pattern-string-constant"),
                /* StringType */2
              ], match[1]);
          var thetaU1 = Subst.compose(match$1[0], match[2]);
          return /* tuple */[
                  /* PStringConstant */Block.__(2, [match[0]]),
                  /* tuple */[
                    rng,
                    /* StringType */2
                  ],
                  Subst.apply_to_type_environment(thetaU1, tyenv),
                  match$1[1]
                ];
      case 3 : 
          var match$2 = iter(kdenv, tyenv, utpatmain[0]);
          var match$3 = iter(match$2[3], match$2[2], utpatmain[1]);
          var typat2 = match$3[1];
          var match$4 = Subst.unify(match$3[3], typat2, /* tuple */[
                Range.dummy("pattern-list-cons"),
                /* ListType */Block.__(1, [match$2[1]])
              ]);
          var thetaU = match$4[0];
          return /* tuple */[
                  /* PListCons */Block.__(3, [
                      match$2[0],
                      match$3[0]
                    ]),
                  Subst.apply_to_type_struct(thetaU, typat2),
                  Subst.apply_to_type_environment(thetaU, match$3[2]),
                  match$4[1]
                ];
      case 4 : 
          var match$5 = iter(kdenv, tyenv, utpatmain[0]);
          var match$6 = iter(match$5[3], match$5[2], utpatmain[1]);
          var typat2$1 = match$6[1];
          var match$7 = typat2$1[1];
          var tyres;
          if (typeof match$7 === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "../src/typechecker.ml",
                    432,
                    40
                  ]
                ];
          }
          else if (match$7.tag === 3) {
            tyres = /* tuple */[
              typat2$1[0],
              /* ProductType */Block.__(3, [/* :: */[
                    match$5[1],
                    match$7[0]
                  ]])
            ];
          }
          else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "../src/typechecker.ml",
                    432,
                    40
                  ]
                ];
          }
          return /* tuple */[
                  /* PTupleCons */Block.__(4, [
                      match$5[0],
                      match$6[0]
                    ]),
                  tyres,
                  match$6[2],
                  match$6[3]
                ];
      case 5 : 
          var varnm = utpatmain[0];
          var tvid$2 = Tyvarid.fresh(qtfbl);
          var beta_001$2 = /* TypeVariable */Block.__(4, [tvid$2]);
          var beta$2 = /* tuple */[
            rng,
            beta_001$2
          ];
          return /* tuple */[
                  /* PVariable */Block.__(5, [varnm]),
                  beta$2,
                  Typeenv.add(tyenv, varnm, beta$2),
                  Kindenv.add(kdenv, tvid$2, /* UniversalKind */0)
                ];
      case 6 : 
          var varnm$1 = utpatmain[0];
          var tvid$3 = Tyvarid.fresh(qtfbl);
          var beta_001$3 = /* TypeVariable */Block.__(4, [tvid$3]);
          var beta$3 = /* tuple */[
            rng,
            beta_001$3
          ];
          var match$8 = iter(Kindenv.add(kdenv, tvid$3, /* UniversalKind */0), tyenv, utpatmain[1]);
          return /* tuple */[
                  /* PAsVariable */Block.__(6, [
                      varnm$1,
                      match$8[0]
                    ]),
                  match$8[1],
                  Typeenv.add(tyenv, varnm$1, beta$3),
                  match$8[3]
                ];
      case 7 : 
          var constrnm = utpatmain[0];
          try {
            var match$9 = Variantenv.find(varntenv, constrnm);
            var match$10 = Typeenv.make_bounded_free(qtfbl, kdenv, match$9[1]);
            var match$11 = iter(match$10[2], tyenv, utpatmain[1]);
            var match$12 = Subst.unify(match$11[3], match$10[0], match$11[1]);
            var thetaU$1 = match$12[0];
            return /* tuple */[
                    /* PConstructor */Block.__(7, [
                        constrnm,
                        match$11[0]
                      ]),
                    Subst.apply_to_type_struct(thetaU$1, /* tuple */[
                          rng,
                          /* VariantType */Block.__(6, [
                              match$10[1],
                              match$9[0]
                            ])
                        ]),
                    Subst.apply_to_type_environment(thetaU$1, match$11[2]),
                    match$12[1]
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return report_error_with_range(rng, "undefined constructor '" + (constrnm + "'"));
            }
            else {
              throw exn;
            }
          }
          break;
      
    }
  }
}

function make_type_environment_by_let(qtfbl, varntenv, kdenv, tyenv, utmutletcons) {
  var add_mutual_variables = function (acckdenv, acctyenv, mutletcons) {
    if (mutletcons) {
      var varnm = mutletcons[1];
      var tvid = Tyvarid.fresh(qtfbl);
      var beta_000 = Types.get_range(mutletcons[2]);
      var beta_001 = /* TypeVariable */Block.__(4, [tvid]);
      var beta = /* tuple */[
        beta_000,
        beta_001
      ];
      "#AddMutualVar " + (varnm + (" : " + (Tyvarid.show_direct(tvid) + " :: U\n")));
      "#Kinds(old) " + (Display.string_of_kind_environment(acckdenv) + "\n");
      var match = add_mutual_variables(Kindenv.add(acckdenv, tvid, /* UniversalKind */0), Typeenv.add(acctyenv, varnm, beta), mutletcons[3]);
      return /* tuple */[
              match[0],
              match[1],
              /* :: */[
                /* tuple */[
                  varnm,
                  beta
                ],
                match[2]
              ]
            ];
    }
    else {
      return /* tuple */[
              acckdenv,
              acctyenv,
              /* [] */0
            ];
    }
  };
  var typecheck_mutual_contents = function (kdenvforrec, tyenvforrec, utmutletcons, tvtylst, accthetain, accthetaout, acctvtylstout) {
    if (utmutletcons) {
      if (tvtylst) {
        var tvtytail = tvtylst[1];
        var beta = tvtylst[0][1];
        var tailcons = utmutletcons[3];
        var varnm = utmutletcons[1];
        var tyopt = utmutletcons[0];
        var match = typecheck(qtfbl, varntenv, kdenvforrec, tyenvforrec, utmutletcons[2]);
        var kdenv1 = match[3];
        var theta1 = match[2];
        var ty1 = match[1];
        var e1 = match[0];
        var theta1a = Subst.compose(theta1, accthetain);
        if (tyopt) {
          var match$1 = Variantenv.fix_manual_type_for_inner_and_outer(qtfbl, varntenv, tyopt[0]);
          var match$2 = Subst.unify(kdenv1, ty1, Subst.apply_to_type_struct(theta1a, beta));
          var thetaU1a = Subst.compose(match$2[0], theta1a);
          var match$3 = Subst.unify(match$2[1], match$1[0], Subst.apply_to_type_struct(thetaU1a, beta));
          var theta1in = Subst.compose(match$3[0], thetaU1a);
          var theta1out = Subst.compose(theta1, accthetaout);
          var match$4 = typecheck_mutual_contents(match$3[1], Subst.apply_to_type_environment(theta1in, tyenvforrec), tailcons, tvtytail, theta1in, theta1out, /* :: */[
                /* tuple */[
                  varnm,
                  beta
                ],
                acctvtylstout
              ]);
          return /* tuple */[
                  match$4[0],
                  match$4[1],
                  /* MutualLetCons */[
                    varnm,
                    e1,
                    match$4[2]
                  ],
                  match$4[3],
                  match$4[4],
                  match$4[5]
                ];
        }
        else {
          var match$5 = Subst.unify(kdenv1, ty1, Subst.apply_to_type_struct(theta1a, beta));
          var theta1in$1 = Subst.compose(match$5[0], theta1a);
          var theta1out$1 = Subst.compose(theta1, accthetaout);
          var match$6 = typecheck_mutual_contents(match$5[1], Subst.apply_to_type_environment(theta1in$1, tyenvforrec), tailcons, tvtytail, theta1in$1, theta1out$1, /* :: */[
                /* tuple */[
                  varnm,
                  beta
                ],
                acctvtylstout
              ]);
          return /* tuple */[
                  match$6[0],
                  match$6[1],
                  /* MutualLetCons */[
                    varnm,
                    e1,
                    match$6[2]
                  ],
                  match$6[3],
                  match$6[4],
                  match$6[5]
                ];
        }
      }
      else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "../src/typechecker.ml",
                512,
                11
              ]
            ];
      }
    }
    else if (tvtylst) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "../src/typechecker.ml",
              512,
              11
            ]
          ];
    }
    else {
      return /* tuple */[
              kdenvforrec,
              tyenvforrec,
              /* EndOfMutualLet */0,
              accthetain,
              accthetaout,
              List.rev(acctvtylstout)
            ];
    }
  };
  var make_forall_type_mutual = function (kdenv, _tyenv, tyenv_before_let, theta, _tvtylst, _tvtylst_forall) {
    while(true) {
      var tvtylst_forall = _tvtylst_forall;
      var tvtylst = _tvtylst;
      var tyenv = _tyenv;
      if (tvtylst) {
        var match = tvtylst[0];
        var varnm = match[0];
        var prety = Subst.apply_to_type_struct(theta, match[1]);
        Subst.string_of_subst(theta);
        "#MakeForall " + (varnm + (" : " + (Display.string_of_type_struct_basic(prety) + "\n")));
        "#Kinds " + (Display.string_of_kind_environment(kdenv) + "\n");
        var forallty = Types.erase_range_of_type(Typeenv.make_forall_type(prety, tyenv_before_let, kdenv));
        var tvtylst_forall_new_000 = /* tuple */[
          varnm,
          forallty
        ];
        var tvtylst_forall_new = /* :: */[
          tvtylst_forall_new_000,
          tvtylst_forall
        ];
        _tvtylst_forall = tvtylst_forall_new;
        _tvtylst = tvtylst[1];
        _tyenv = Typeenv.add(tyenv, varnm, forallty);
        continue ;
        
      }
      else {
        return /* tuple */[
                kdenv,
                tyenv,
                tvtylst_forall
              ];
      }
    };
  };
  var match = add_mutual_variables(kdenv, tyenv, utmutletcons);
  var kdenvforrec = match[0];
  "#Kinds(forrec) " + (Display.string_of_kind_environment(kdenvforrec) + "\n");
  var match$1 = typecheck_mutual_contents(kdenvforrec, match[1], utmutletcons, match[2], Subst.empty, Subst.empty, /* [] */0);
  var thetain = match$1[3];
  var kdenv_new = match$1[0];
  "#Kinds(before) " + (Display.string_of_kind_environment(kdenv_new) + "\n");
  var match$2 = make_forall_type_mutual(kdenv_new, match$1[1], tyenv, thetain, match$1[5], /* [] */0);
  return /* tuple */[
          match$2[0],
          match$2[1],
          match$2[2],
          match$1[2],
          thetain,
          match$1[4]
        ];
}

function make_type_environment_by_let_mutable(varntenv, kdenv, tyenv, varrng, varnm, utastI) {
  var match = typecheck(/* Unquantifiable */1, varntenv, kdenv, tyenv, utastI);
  var thetaI = match[2];
  var tyI = match[1];
  var tyenvI = Subst.apply_to_type_environment(thetaI, Typeenv.add(tyenv, varnm, /* tuple */[
            varrng,
            /* RefType */Block.__(2, [tyI])
          ]));
  return /* tuple */[
          tyenvI,
          match[0],
          tyI,
          thetaI,
          match[3]
        ];
}

function main(varntenv, kdenv, tyenv, utast) {
  final_varntenv[0] = varntenv;
  final_tyenv[0] = tyenv;
  final_kdenv[0] = kdenv;
  var match = typecheck(/* Quantifiable */0, varntenv, Kindenv.empty, tyenv, utast);
  return /* tuple */[
          match[1],
          final_varntenv[0],
          final_kdenv[0],
          final_tyenv[0],
          match[0]
        ];
}

exports.$$Error = $$Error;
exports.main    = main;
/* Variantenv Not a pure module */
