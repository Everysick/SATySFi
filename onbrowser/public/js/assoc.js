// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_obj                = require("bs-platform/lib/js/caml_obj");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Curry                   = require("bs-platform/lib/js/curry");
var List                    = require("bs-platform/lib/js/list");

function add($staropt$star, asc, key, value) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  if (asc) {
    var tail = asc[1];
    var match = asc[0];
    var k = match[0];
    if (Curry._2(eq, k, key)) {
      return /* :: */[
              /* tuple */[
                key,
                value
              ],
              tail
            ];
    }
    else {
      return /* :: */[
              /* tuple */[
                k,
                match[1]
              ],
              add(/* Some */[eq], tail, key, value)
            ];
    }
  }
  else {
    return /* :: */[
            /* tuple */[
              key,
              value
            ],
            /* [] */0
          ];
  }
}

function find(_$staropt$star, _asc, key) {
  while(true) {
    var asc = _asc;
    var $staropt$star = _$staropt$star;
    var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
    if (asc) {
      var match = asc[0];
      if (Curry._2(eq, match[0], key)) {
        return match[1];
      }
      else {
        _asc = asc[1];
        _$staropt$star = /* None */0;
        continue ;
        
      }
    }
    else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function to_list(asc) {
  return asc;
}

function of_list($staropt$star, lst) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  return List.fold_right(function (param, a) {
              return add(/* Some */[eq], a, param[0], param[1]);
            }, /* [] */0, lst);
}

function map_value(f, asc) {
  return List.map(function (param) {
              return /* tuple */[
                      param[0],
                      Curry._1(f, param[1])
                    ];
            }, asc);
}

function fold_value(f, init, asc) {
  return List.fold_left(function (x, param) {
              return Curry._2(f, x, param[1]);
            }, init, asc);
}

function to_value_list(asc) {
  return List.map(function (param) {
              return param[1];
            }, asc);
}

var fold = List.fold_left

function mem(_$staropt$star, key, _asc) {
  while(true) {
    var asc = _asc;
    var $staropt$star = _$staropt$star;
    var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
    if (asc) {
      if (Curry._2(eq, asc[0][0], key)) {
        return /* true */1;
      }
      else {
        _asc = asc[1];
        _$staropt$star = /* Some */[eq];
        continue ;
        
      }
    }
    else {
      return /* false */0;
    }
  };
}

function domain_included($staropt$star, asc1, asc2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  return List.fold_left(function (b, param) {
              if (b) {
                return mem(/* Some */[eq], param[0], asc2);
              }
              else {
                return /* false */0;
              }
            }, /* true */1, asc1);
}

function domain_same($staropt$star, asc1, asc2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  if (domain_included(/* Some */[eq], asc1, asc2)) {
    return domain_included(/* Some */[eq], asc2, asc1);
  }
  else {
    return /* false */0;
  }
}

function combine_value($staropt$star, asc1, asc2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var _asc1 = asc1;
  var _acclst = /* [] */0;
  while(true) {
    var acclst = _acclst;
    var asc1$1 = _asc1;
    if (asc1$1) {
      var match = asc1$1[0];
      _acclst = /* :: */[
        /* tuple */[
          match[1],
          find(/* Some */[eq], asc2, match[0])
        ],
        acclst
      ];
      _asc1 = asc1$1[1];
      continue ;
      
    }
    else {
      return List.rev(acclst);
    }
  };
}

function intersection($staropt$star, asc1, asc2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var _asc1 = asc1;
  var _acclst = /* [] */0;
  while(true) {
    var acclst = _acclst;
    var asc1$1 = _asc1;
    if (asc1$1) {
      var tail = asc1$1[1];
      var match = asc1$1[0];
      var k = match[0];
      if (mem(/* Some */[eq], k, asc2)) {
        _acclst = /* :: */[
          /* tuple */[
            match[1],
            find(/* Some */[eq], asc2, k)
          ],
          acclst
        ];
        _asc1 = tail;
        continue ;
        
      }
      else {
        _asc1 = tail;
        continue ;
        
      }
    }
    else {
      return List.rev(acclst);
    }
  };
}

function union($staropt$star, asc1, asc2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var _asc1 = asc1;
  var _accasc = asc2;
  while(true) {
    var accasc = _accasc;
    var asc1$1 = _asc1;
    if (asc1$1) {
      var tail = asc1$1[1];
      var match = asc1$1[0];
      var k = match[0];
      if (mem(/* Some */[eq], k, accasc)) {
        _asc1 = tail;
        continue ;
        
      }
      else {
        _accasc = /* :: */[
          /* tuple */[
            k,
            match[1]
          ],
          accasc
        ];
        _asc1 = tail;
        continue ;
        
      }
    }
    else {
      return List.rev(accasc);
    }
  };
}

var empty = /* [] */0;

exports.empty           = empty;
exports.add             = add;
exports.find            = find;
exports.to_list         = to_list;
exports.of_list         = of_list;
exports.map_value       = map_value;
exports.fold_value      = fold_value;
exports.to_value_list   = to_value_list;
exports.fold            = fold;
exports.mem             = mem;
exports.domain_included = domain_included;
exports.domain_same     = domain_same;
exports.combine_value   = combine_value;
exports.intersection    = intersection;
exports.union           = union;
/* No side effect */
