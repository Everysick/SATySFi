// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_obj                = require("bs-platform/lib/js/caml_obj");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Range                   = require("./range");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions");
var Pervasives              = require("bs-platform/lib/js/pervasives");
var Block                   = require("bs-platform/lib/js/block");
var Display                 = require("./display");
var Typeenv                 = require("./typeenv");
var Tyvarid                 = require("./tyvarid");
var Assoc                   = require("./assoc");
var List                    = require("bs-platform/lib/js/list");

var $$Error = Caml_exceptions.create("Variantenv.Error");

function append_module_name(mdlnm, varntnm) {
  if (mdlnm === "") {
    return varntnm;
  }
  else {
    return mdlnm + ("." + varntnm);
  }
}

function add(varntenv, constrnm, tystr, varntnm) {
  var aux = function (varntenvmain, constrnm, tystr, varntnm) {
    if (varntenvmain) {
      var tail = varntenvmain[1];
      var match = varntenvmain[0];
      var c = match[0];
      if (Caml_obj.caml_equal(c, constrnm)) {
        return /* :: */[
                /* tuple */[
                  constrnm,
                  varntnm,
                  tystr
                ],
                tail
              ];
      }
      else {
        return /* :: */[
                /* tuple */[
                  c,
                  match[1],
                  match[2]
                ],
                aux(tail, constrnm, tystr, varntnm)
              ];
      }
    }
    else {
      return /* :: */[
              /* tuple */[
                constrnm,
                varntnm,
                tystr
              ],
              /* [] */0
            ];
    }
  };
  return /* tuple */[
          varntenv[0],
          aux(varntenv[1], constrnm, tystr, varntnm)
        ];
}

function add_list(param, param$1) {
  return List.fold_left(function (ve, param) {
              return add(ve, param[0], param[1], param[2]);
            }, param, param$1);
}

function find_definition_kind(_defedtylst, tynm) {
  while(true) {
    var defedtylst = _defedtylst;
    if (defedtylst) {
      var match = defedtylst[0];
      if (match[0] === tynm) {
        return match[1];
      }
      else {
        _defedtylst = defedtylst[1];
        continue ;
        
      }
    }
    else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function is_defined_type_argument(_tyargcons, tyargnm) {
  while(true) {
    var tyargcons = _tyargcons;
    if (tyargcons) {
      if (tyargcons[1] === tyargnm) {
        return /* true */1;
      }
      else {
        _tyargcons = tyargcons[2];
        continue ;
        
      }
    }
    else {
      return /* false */0;
    }
  };
}

function fix_manual_type_general(mode, varntenv, tyargmode, tystr) {
  var tymain = tystr[1];
  var rng = tystr[0];
  var iter = function (param) {
    return fix_manual_type_general(mode, varntenv, tyargmode, param);
  };
  var error = function (param, param$1, param$2) {
    var rng$1 = rng;
    var tynm = param;
    var len_expected = param$1;
    var len = param$2;
    throw [
          $$Error,
          "at " + (Range.to_string(rng$1) + (":\n    '" + (tynm + ("' is expected to have " + (Pervasives.string_of_int(len_expected) + (" type argument(s),\n    but it has " + (Pervasives.string_of_int(len) + " type argument(s) here")))))))
        ];
  };
  var tymainnew;
  var exit = 0;
  if (typeof tymain === "number") {
    exit = 1;
  }
  else {
    switch (tymain.tag | 0) {
      case 0 : 
          tymainnew = /* FuncType */Block.__(0, [
              iter(tymain[0]),
              iter(tymain[1])
            ]);
          break;
      case 3 : 
          tymainnew = /* ProductType */Block.__(3, [List.map(iter, tymain[0])]);
          break;
      case 6 : 
          var tyarglist = tymain[0];
          var exit$1 = 0;
          if (tyarglist) {
            if (tyarglist[1]) {
              exit$1 = 2;
            }
            else {
              var tyarg = tyarglist[0];
              switch (tymain[1]) {
                case "list" : 
                    tymainnew = /* ListType */Block.__(1, [tyarg]);
                    break;
                case "ref" : 
                    tymainnew = /* RefType */Block.__(2, [tyarg]);
                    break;
                default:
                  exit$1 = 2;
              }
            }
          }
          else {
            switch (tymain[1]) {
              case "bool" : 
                  tymainnew = /* BoolType */3;
                  break;
              case "int" : 
                  tymainnew = /* IntType */1;
                  break;
              case "string" : 
                  tymainnew = /* StringType */2;
                  break;
              case "unit" : 
                  tymainnew = /* UnitType */0;
                  break;
              default:
                exit$1 = 2;
            }
          }
          if (exit$1 === 2) {
            var tynm = tymain[1];
            switch (tynm) {
              case "bool" : 
                  tymainnew = error("bool", 0, List.length(tyarglist));
                  break;
              case "int" : 
                  tymainnew = error("int", 0, List.length(tyarglist));
                  break;
              case "list" : 
                  tymainnew = error("list", 1, List.length(tyarglist));
                  break;
              case "ref" : 
                  tymainnew = error("ref", 1, List.length(tyarglist));
                  break;
              case "string" : 
                  tymainnew = error("string", 0, List.length(tyarglist));
                  break;
              case "unit" : 
                  tymainnew = error("unit", 0, List.length(tyarglist));
                  break;
              default:
                try {
                  var match = find_definition_kind(varntenv[0], tynm);
                  switch (match.tag | 0) {
                    case 0 : 
                        var argnum = match[0];
                        var len = List.length(tyarglist);
                        tymainnew = argnum !== len ? error(tynm, argnum, len) : /* VariantType */Block.__(6, [
                              List.map(iter, tyarglist),
                              tynm
                            ]);
                        break;
                    case 1 : 
                        var argnum$1 = match[0];
                        var len$1 = List.length(tyarglist);
                        tymainnew = argnum$1 !== len$1 ? error(tynm, argnum$1, len$1) : /* TypeSynonym */Block.__(5, [
                              List.map(iter, tyarglist),
                              tynm,
                              match[1]
                            ]);
                        break;
                    case 2 : 
                        var argnum$2 = match[1];
                        var len$2 = List.length(tyarglist);
                        tymainnew = argnum$2 !== len$2 ? error(tynm, argnum$2, len$2) : (
                            mode !== 0 ? /* VariantType */Block.__(6, [
                                  List.map(iter, tyarglist),
                                  append_module_name(match[0], tynm)
                                ]) : /* TypeSynonym */Block.__(5, [
                                  List.map(iter, tyarglist),
                                  tynm,
                                  match[2]
                                ])
                          );
                        break;
                    
                  }
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    throw [
                          $$Error,
                          "at " + (Range.to_string(rng) + (":\n    undefined type '" + (tynm + "'")))
                        ];
                  }
                  else {
                    throw exn;
                  }
                }
            }
          }
          break;
      case 8 : 
          var tyargnm = tymain[0];
          if (tyargmode.tag) {
            var reftyarglst = tyargmode[0];
            if (!List.mem(tyargnm, reftyarglst[0])) {
              reftyarglst[0] = /* :: */[
                tyargnm,
                reftyarglst[0]
              ];
            }
            tymainnew = /* TypeArgument */Block.__(8, [tyargnm]);
          }
          else if (is_defined_type_argument(tyargmode[0], tyargnm)) {
            tymainnew = /* TypeArgument */Block.__(8, [tyargnm]);
          }
          else {
            throw [
                  $$Error,
                  "at " + (Range.to_string(rng) + (":\n    undefined type argument '" + (tyargnm + "'")))
                ];
          }
          break;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    console.log("OTHER: " + Display.string_of_type_struct_basic(/* tuple */[
              rng,
              tymain
            ]));
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "../src/variantenv.ml",
            128,
            10
          ]
        ];
  }
  return /* tuple */[
          rng,
          tymainnew
        ];
}

function make_type_argument_numbered(var_id, tyargnm, tystr) {
  var iter = function (param) {
    return make_type_argument_numbered(var_id, tyargnm, param);
  };
  var tymain = tystr[1];
  var tymainnew;
  if (typeof tymain === "number") {
    tymainnew = tymain;
  }
  else {
    switch (tymain.tag | 0) {
      case 0 : 
          tymainnew = /* FuncType */Block.__(0, [
              make_type_argument_numbered(var_id, tyargnm, tymain[0]),
              make_type_argument_numbered(var_id, tyargnm, tymain[1])
            ]);
          break;
      case 1 : 
          tymainnew = /* ListType */Block.__(1, [make_type_argument_numbered(var_id, tyargnm, tymain[0])]);
          break;
      case 2 : 
          tymainnew = /* RefType */Block.__(2, [make_type_argument_numbered(var_id, tyargnm, tymain[0])]);
          break;
      case 3 : 
          tymainnew = /* ProductType */Block.__(3, [List.map(iter, tymain[0])]);
          break;
      case 5 : 
          tymainnew = /* TypeSynonym */Block.__(5, [
              List.map(iter, tymain[0]),
              tymain[1],
              tymain[2]
            ]);
          break;
      case 6 : 
          tymainnew = /* VariantType */Block.__(6, [
              List.map(iter, tymain[0]),
              tymain[1]
            ]);
          break;
      case 7 : 
          tymainnew = /* ForallType */Block.__(7, [
              tymain[0],
              tymain[1],
              make_type_argument_numbered(var_id, tyargnm, tymain[2])
            ]);
          break;
      case 8 : 
          tymainnew = tymain[0] === tyargnm ? /* TypeVariable */Block.__(4, [var_id]) : tymain;
          break;
      case 9 : 
          tymainnew = /* RecordType */Block.__(9, [Assoc.map_value(iter, tymain[0])]);
          break;
      default:
        tymainnew = tymain;
    }
  }
  return /* tuple */[
          tystr[0],
          tymainnew
        ];
}

function fix_manual_type(varntenv, tyargcons, tystr) {
  return fix_manual_type_general(/* InnerMode */0, varntenv, /* StrictMode */Block.__(0, [tyargcons]), tystr);
}

var free_type_argument_list = [/* [] */0];

function make_type_argument_into_type_variable(qtfbl, _tyarglist, _tystr) {
  while(true) {
    var tystr = _tystr;
    var tyarglist = _tyarglist;
    if (tyarglist) {
      var ntv = Tyvarid.fresh(qtfbl);
      var tystr_new = make_type_argument_numbered(ntv, tyarglist[0], tystr);
      _tystr = tystr_new;
      _tyarglist = tyarglist[1];
      continue ;
      
    }
    else {
      return tystr;
    }
  };
}

function fix_manual_type_for_inner_and_outer(qtfbl, varntenv, tystr) {
  free_type_argument_list[0] = /* [] */0;
  var tystrin = fix_manual_type_general(/* InnerMode */0, varntenv, /* FreeMode */Block.__(1, [free_type_argument_list]), tystr);
  var tystrout = fix_manual_type_general(/* OuterMode */1, varntenv, /* FreeMode */Block.__(1, [free_type_argument_list]), tystr);
  var tystrin_result = make_type_argument_into_type_variable(qtfbl, free_type_argument_list[0], tystrin);
  var tystrout_result = make_type_argument_into_type_variable(qtfbl, free_type_argument_list[0], tystrout);
  return /* tuple */[
          tystrin_result,
          tystrout_result
        ];
}

function make_type_argument_quantified(_tyargcons, _tystr) {
  while(true) {
    var tystr = _tystr;
    var tyargcons = _tyargcons;
    if (tyargcons) {
      var tvidqtf = Tyvarid.fresh(/* Quantifiable */0);
      var tystr_new_000 = Range.dummy("make_type_argument_quantified");
      var tystr_new_001 = /* ForallType */Block.__(7, [
          tvidqtf,
          /* UniversalKind */0,
          make_type_argument_numbered(tvidqtf, tyargcons[1], tystr)
        ]);
      var tystr_new = /* tuple */[
        tystr_new_000,
        tystr_new_001
      ];
      _tystr = tystr_new;
      _tyargcons = tyargcons[2];
      continue ;
      
    }
    else {
      return tystr;
    }
  };
}

function type_argument_length(tyargcons) {
  if (tyargcons) {
    return 1 + type_argument_length(tyargcons[2]) | 0;
  }
  else {
    return 0;
  }
}

function register_variant(varntenv, len, tynm) {
  return /* tuple */[
          /* :: */[
            /* tuple */[
              tynm,
              /* Data */Block.__(0, [len])
            ],
            varntenv[0]
          ],
          varntenv[1]
        ];
}

function register_variant_list(param, param$1) {
  return List.fold_left(function (ve, param) {
              return register_variant(ve, param[0], param[1]);
            }, param, param$1);
}

function add_synonym(scope, varntenv, tyargcons, tysynnm, tystr) {
  var len = type_argument_length(tyargcons);
  var defkind;
  if (scope) {
    var tystr_new = fix_manual_type(varntenv, tyargcons, tystr);
    var tystr_forall = make_type_argument_quantified(tyargcons, tystr_new);
    defkind = /* LocalSynonym */Block.__(2, [
        scope[0],
        len,
        tystr_forall
      ]);
  }
  else {
    var tystr_new$1 = fix_manual_type(varntenv, tyargcons, tystr);
    var tystr_forall$1 = make_type_argument_quantified(tyargcons, tystr_new$1);
    defkind = /* Synonym */Block.__(1, [
        len,
        tystr_forall$1
      ]);
  }
  return /* tuple */[
          /* :: */[
            /* tuple */[
              tysynnm,
              defkind
            ],
            varntenv[0]
          ],
          varntenv[1]
        ];
}

function apply_to_type_synonym(_tyarglist, _tystr_forall) {
  while(true) {
    var tystr_forall = _tystr_forall;
    var tyarglist = _tyarglist;
    if (tyarglist) {
      var match = tystr_forall[1];
      if (typeof match === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "../src/variantenv.ml",
                229,
                59
              ]
            ];
      }
      else if (match.tag === 7) {
        var tystr_forall_new = Typeenv.replace_id(/* :: */[
              /* tuple */[
                match[0],
                tyarglist[0]
              ],
              /* [] */0
            ], match[2]);
        _tystr_forall = tystr_forall_new;
        _tyarglist = tyarglist[1];
        continue ;
        
      }
      else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "../src/variantenv.ml",
                229,
                59
              ]
            ];
      }
    }
    else {
      var $js = tystr_forall[1];
      if (typeof $js === "number") {
        return tystr_forall;
      }
      else if ($js.tag === 7) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "../src/variantenv.ml",
                227,
                59
              ]
            ];
      }
      else {
        return tystr_forall;
      }
    }
  };
}

function add_variant_cons(mdlnm, varntenv, tyargcons, varntnm, utvc) {
  var mdlvarntnm = append_module_name(mdlnm, varntnm);
  var tyarglen = type_argument_length(tyargcons);
  var mdlnm$1 = mdlnm;
  var _varntenv = register_variant(varntenv, tyarglen, mdlvarntnm);
  var tyargcons$1 = tyargcons;
  var varntnm$1 = varntnm;
  var _utvc = utvc;
  while(true) {
    var utvc$1 = _utvc;
    var varntenv$1 = _varntenv;
    var utvcmain = utvc$1[1];
    if (utvcmain) {
      var tystr_new = fix_manual_type(varntenv$1, tyargcons$1, utvcmain[1]);
      var tystr_forall = make_type_argument_quantified(tyargcons$1, tystr_new);
      var varntenv_new = add(varntenv$1, utvcmain[0], tystr_forall, append_module_name(mdlnm$1, varntnm$1));
      _utvc = utvcmain[2];
      _varntenv = varntenv_new;
      continue ;
      
    }
    else {
      return varntenv$1;
    }
  };
}

function add_mutual_cons(scope, varntenv, mutvarntcons) {
  var varntenv_mem = memo_variant_name("", varntenv, mutvarntcons);
  var varntenv_syn = read_synonym_spec(scope, varntenv_mem, mutvarntcons);
  var _varntenv = varntenv_syn;
  var _mutvarntcons = mutvarntcons;
  while(true) {
    var mutvarntcons$1 = _mutvarntcons;
    var varntenv$1 = _varntenv;
    if (typeof mutvarntcons$1 === "number") {
      return varntenv$1;
    }
    else if (mutvarntcons$1.tag) {
      _mutvarntcons = mutvarntcons$1[3];
      continue ;
      
    }
    else {
      var varntenv_new = add_variant_cons("", varntenv$1, mutvarntcons$1[0], mutvarntcons$1[1], mutvarntcons$1[2]);
      _mutvarntcons = mutvarntcons$1[3];
      _varntenv = varntenv_new;
      continue ;
      
    }
  };
}

function read_synonym_spec(scope, _varntenv, _mutvarntcons) {
  while(true) {
    var mutvarntcons = _mutvarntcons;
    var varntenv = _varntenv;
    if (typeof mutvarntcons === "number") {
      return varntenv;
    }
    else if (mutvarntcons.tag) {
      var varntenv_new = add_synonym(scope, varntenv, mutvarntcons[0], mutvarntcons[1], mutvarntcons[2]);
      _mutvarntcons = mutvarntcons[3];
      _varntenv = varntenv_new;
      continue ;
      
    }
    else {
      _mutvarntcons = mutvarntcons[3];
      continue ;
      
    }
  };
}

function add_mutual_cons_hidden(mdlnm, varntenv, mutvarntcons) {
  var mdlnm$1 = mdlnm;
  var _varntenv = varntenv;
  var _mutvarntcons = mutvarntcons;
  while(true) {
    var mutvarntcons$1 = _mutvarntcons;
    var varntenv$1 = _varntenv;
    if (typeof mutvarntcons$1 === "number") {
      return varntenv$1;
    }
    else if (mutvarntcons$1.tag) {
      var mdltysynnm = append_module_name(mdlnm$1, mutvarntcons$1[1]);
      var tyarglen = type_argument_length(mutvarntcons$1[0]);
      var varntenv_new = register_variant(varntenv$1, tyarglen, mdltysynnm);
      _mutvarntcons = mutvarntcons$1[3];
      _varntenv = varntenv_new;
      continue ;
      
    }
    else {
      var mdlvarntnm = append_module_name(mdlnm$1, mutvarntcons$1[1]);
      var tyarglen$1 = type_argument_length(mutvarntcons$1[0]);
      var varntenv_new$1 = register_variant(varntenv$1, tyarglen$1, mdlvarntnm);
      _mutvarntcons = mutvarntcons$1[3];
      _varntenv = varntenv_new$1;
      continue ;
      
    }
  };
}

function memo_variant_name(mdlnm, _varntenv, _mutvarntcons) {
  while(true) {
    var mutvarntcons = _mutvarntcons;
    var varntenv = _varntenv;
    if (typeof mutvarntcons === "number") {
      return varntenv;
    }
    else if (mutvarntcons.tag) {
      _mutvarntcons = mutvarntcons[3];
      continue ;
      
    }
    else {
      var mdlvarntnm = append_module_name(mdlnm, mutvarntcons[1]);
      var tyarglen = type_argument_length(mutvarntcons[0]);
      var varntenv_new = register_variant(varntenv, tyarglen, mdlvarntnm);
      _mutvarntcons = mutvarntcons[3];
      _varntenv = varntenv_new;
      continue ;
      
    }
  };
}

function find(varntenv, constrnm) {
  var _varntenvmain = varntenv[1];
  var constrnm$1 = constrnm;
  while(true) {
    var varntenvmain = _varntenvmain;
    if (varntenvmain) {
      var match = varntenvmain[0];
      if (Caml_obj.caml_equal(match[0], constrnm$1)) {
        return /* tuple */[
                match[1],
                match[2]
              ];
      }
      else {
        _varntenvmain = varntenvmain[1];
        continue ;
        
      }
    }
    else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

var empty = /* tuple */[
  /* [] */0,
  /* [] */0
];

exports.$$Error                             = $$Error;
exports.empty                               = empty;
exports.add                                 = add;
exports.add_list                            = add_list;
exports.register_variant                    = register_variant;
exports.register_variant_list               = register_variant_list;
exports.add_mutual_cons                     = add_mutual_cons;
exports.add_mutual_cons_hidden              = add_mutual_cons_hidden;
exports.find                                = find;
exports.apply_to_type_synonym               = apply_to_type_synonym;
exports.fix_manual_type_for_inner_and_outer = fix_manual_type_for_inner_and_outer;
exports.append_module_name                  = append_module_name;
/* Display Not a pure module */
