// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Range                   = require("./range");
var Pervasives              = require("bs-platform/lib/js/pervasives");
var Block                   = require("bs-platform/lib/js/block");
var Tyvarid                 = require("./tyvarid");
var Assoc                   = require("./assoc");
var Kindenv                 = require("./kindenv");
var $$String                = require("bs-platform/lib/js/string");
var List                    = require("bs-platform/lib/js/list");

function to_list(tyenv) {
  return tyenv;
}

function from_list(lst) {
  return lst;
}

var map = List.map

function add(tyenv, varnm, tystr) {
  if (tyenv) {
    var tail = tyenv[1];
    var match = tyenv[0];
    var vn = match[0];
    if (vn === varnm) {
      return /* :: */[
              /* tuple */[
                varnm,
                tystr
              ],
              tail
            ];
    }
    else {
      return /* :: */[
              /* tuple */[
                vn,
                match[1]
              ],
              add(tail, varnm, tystr)
            ];
    }
  }
  else {
    return /* :: */[
            /* tuple */[
              varnm,
              tystr
            ],
            /* [] */0
          ];
  }
}

function find(_tyenv, varnm) {
  while(true) {
    var tyenv = _tyenv;
    if (tyenv) {
      var match = tyenv[0];
      if (match[0] === varnm) {
        return match[1];
      }
      else {
        _tyenv = tyenv[1];
        continue ;
        
      }
    }
    else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function overwrite_range_of_type(tystr, rng) {
  return /* tuple */[
          rng,
          tystr[1]
        ];
}

function find_in_type_struct(tvid, _tystr) {
  while(true) {
    var tystr = _tystr;
    var tymain = tystr[1];
    if (typeof tymain === "number") {
      return /* false */0;
    }
    else {
      switch (tymain.tag | 0) {
        case 0 : 
            if (find_in_type_struct(tvid, tymain[0])) {
              return /* true */1;
            }
            else {
              _tystr = tymain[1];
              continue ;
              
            }
            break;
        case 1 : 
        case 2 : 
            _tystr = tymain[0];
            continue ;
            case 4 : 
            return Tyvarid.same(tymain[0], tvid);
        case 5 : 
            if (find_in_type_struct_list(tvid, tymain[0])) {
              return /* true */1;
            }
            else {
              _tystr = tymain[2];
              continue ;
              
            }
            break;
        case 3 : 
        case 6 : 
            return find_in_type_struct_list(tvid, tymain[0]);
        default:
          return /* false */0;
      }
    }
  };
}

function find_in_type_struct_list(tvid, tystrlst) {
  return List.fold_left(function (b, tystr) {
              if (b) {
                return /* true */1;
              }
              else {
                return find_in_type_struct(tvid, tystr);
              }
            }, /* false */0, tystrlst);
}

function find_in_type_environment(tvid, tyenv) {
  return List.fold_left(function (b, param) {
              if (b) {
                return /* true */1;
              }
              else {
                return find_in_type_struct(tvid, param[1]);
              }
            }, /* false */0, tyenv);
}

var quantifiable_unbound_id_list = [/* [] */0];

function listup_quantifiable_unbound_id(_tystr, tyenv) {
  while(true) {
    var tystr = _tystr;
    var iter = function (ty) {
      return listup_quantifiable_unbound_id(ty, tyenv);
    };
    var tymain = tystr[1];
    if (typeof tymain === "number") {
      return /* () */0;
    }
    else {
      switch (tymain.tag | 0) {
        case 0 : 
            listup_quantifiable_unbound_id(tymain[0], tyenv);
            _tystr = tymain[1];
            continue ;
            case 1 : 
        case 2 : 
            _tystr = tymain[0];
            continue ;
            case 4 : 
            var tvid = tymain[0];
            if (Tyvarid.is_quantifiable(tvid) && !(find_in_type_environment(tvid, tyenv) || List.mem(tvid, quantifiable_unbound_id_list[0]))) {
              quantifiable_unbound_id_list[0] = /* :: */[
                tvid,
                quantifiable_unbound_id_list[0]
              ];
              return /* () */0;
            }
            else {
              return /* () */0;
            }
        case 3 : 
        case 5 : 
        case 6 : 
            return List.iter(iter, tymain[0]);
        case 7 : 
        case 8 : 
            return Pervasives.failwith("listup_quantifiable_unbound_id");
        case 9 : 
            return List.iter(iter, List.map(function (param) {
                            return param[1];
                          }, Assoc.to_list(tymain[0])));
        default:
          return /* () */0;
      }
    }
  };
}

function listup_quantifiable_unbound_id_in_kind_environment(kdenv, tyenv) {
  var aux = function (kdstr) {
    if (kdstr) {
      return List.iter(function (ty) {
                  return listup_quantifiable_unbound_id(ty, tyenv);
                }, List.map(function (param) {
                      return param[1];
                    }, Assoc.to_list(kdstr[0])));
    }
    else {
      return /* () */0;
    }
  };
  return List.iter(aux, Kindenv.to_kind_struct_list(kdenv));
}

function add_forall_struct(kdenv, lst, tystr) {
  if (lst) {
    var tvid = lst[0];
    var kdstr;
    try {
      kdstr = Kindenv.find(kdenv, tvid);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        kdstr = Pervasives.failwith("add_forall_struct '" + (Tyvarid.show_direct(tvid) + "'"));
      }
      else {
        throw exn;
      }
    }
    return /* tuple */[
            Range.dummy("add_forall_struct"),
            /* ForallType */Block.__(7, [
                tvid,
                kdstr,
                add_forall_struct(kdenv, lst[1], tystr)
              ])
          ];
  }
  else {
    return tystr;
  }
}

function make_forall_type(tystr, tyenv_before, kdenv) {
  quantifiable_unbound_id_list[0] = /* [] */0;
  listup_quantifiable_unbound_id(tystr, tyenv_before);
  listup_quantifiable_unbound_id_in_kind_environment(kdenv, tyenv_before);
  return add_forall_struct(kdenv, quantifiable_unbound_id_list[0], tystr);
}

function string_of_type_environment(tyenv, msg) {
  var iter = function (tyenv) {
    if (tyenv) {
      var vn = tyenv[0][0];
      var len = vn.length;
      return "    #  " + ((
                len >= 16 ? vn : vn + $$String.make(16 - len | 0, /* " " */32)
              ) + (" : type\n" + iter(tyenv[1])));
    }
    else {
      return "";
    }
  };
  return "    #==== " + (msg + (" " + ($$String.make(58 - msg.length | 0, /* "=" */61) + ("\n" + (iter(tyenv) + "    #================================================================\n")))));
}

function string_of_control_sequence_type(tyenv) {
  var iter = function (tyenv) {
    if (tyenv) {
      var vn = tyenv[0][0];
      var match = $$String.sub(vn, 0, 1);
      var $js;
      if (match === "\\") {
        var len = vn.length;
        $js = "    #  " + ((
            len >= 16 ? vn : vn + $$String.make(16 - len | 0, /* " " */32)
          ) + " : type\n");
      }
      else {
        $js = "";
      }
      return $js + iter(tyenv[1]);
    }
    else {
      return "";
    }
  };
  return "    #================================================================\n" + (iter(tyenv) + "    #================================================================\n");
}

function find_id_in_list(elm, _lst) {
  while(true) {
    var lst = _lst;
    if (lst) {
      var match = lst[0];
      if (Tyvarid.same(match[0], elm)) {
        return match[1];
      }
      else {
        _lst = lst[1];
        continue ;
        
      }
    }
    else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function replace_id(lst, tystr) {
  var iter = function (param) {
    return replace_id(lst, param);
  };
  var tymain = tystr[1];
  var rng = tystr[0];
  if (typeof tymain === "number") {
    return /* tuple */[
            rng,
            tymain
          ];
  }
  else {
    switch (tymain.tag | 0) {
      case 0 : 
          return /* tuple */[
                  rng,
                  /* FuncType */Block.__(0, [
                      replace_id(lst, tymain[0]),
                      replace_id(lst, tymain[1])
                    ])
                ];
      case 1 : 
          return /* tuple */[
                  rng,
                  /* ListType */Block.__(1, [replace_id(lst, tymain[0])])
                ];
      case 2 : 
          return /* tuple */[
                  rng,
                  /* RefType */Block.__(2, [replace_id(lst, tymain[0])])
                ];
      case 3 : 
          return /* tuple */[
                  rng,
                  /* ProductType */Block.__(3, [List.map(iter, tymain[0])])
                ];
      case 4 : 
          var tvid = tymain[0];
          try {
            return find_id_in_list(tvid, lst);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* tuple */[
                      rng,
                      /* TypeVariable */Block.__(4, [tvid])
                    ];
            }
            else {
              throw exn;
            }
          }
          break;
      case 5 : 
          return /* tuple */[
                  rng,
                  /* TypeSynonym */Block.__(5, [
                      List.map(iter, tymain[0]),
                      tymain[1],
                      replace_id(lst, tymain[2])
                    ])
                ];
      case 6 : 
          return /* tuple */[
                  rng,
                  /* VariantType */Block.__(6, [
                      List.map(iter, tymain[0]),
                      tymain[1]
                    ])
                ];
      case 7 : 
          var tycont = tymain[2];
          var kdstr = tymain[1];
          var tvid$1 = tymain[0];
          try {
            find_id_in_list(tvid$1, lst);
            return /* tuple */[
                    rng,
                    /* ForallType */Block.__(7, [
                        tvid$1,
                        kdstr,
                        tycont
                      ])
                  ];
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return /* tuple */[
                      rng,
                      /* ForallType */Block.__(7, [
                          tvid$1,
                          kdstr,
                          replace_id(lst, tycont)
                        ])
                    ];
            }
            else {
              throw exn$1;
            }
          }
          break;
      default:
        return /* tuple */[
                rng,
                tymain
              ];
    }
  }
}

function make_unquantifiable_if_needed(qtfbl, tystr) {
  var iter = function (param) {
    return make_unquantifiable_if_needed(qtfbl, param);
  };
  var tymain = tystr[1];
  var tymainnew;
  if (typeof tymain === "number") {
    tymainnew = tymain;
  }
  else {
    switch (tymain.tag | 0) {
      case 0 : 
          tymainnew = /* FuncType */Block.__(0, [
              make_unquantifiable_if_needed(qtfbl, tymain[0]),
              make_unquantifiable_if_needed(qtfbl, tymain[1])
            ]);
          break;
      case 1 : 
          tymainnew = /* ListType */Block.__(1, [make_unquantifiable_if_needed(qtfbl, tymain[0])]);
          break;
      case 2 : 
          tymainnew = /* RefType */Block.__(2, [make_unquantifiable_if_needed(qtfbl, tymain[0])]);
          break;
      case 3 : 
          tymainnew = /* ProductType */Block.__(3, [List.map(iter, tymain[0])]);
          break;
      case 4 : 
          var tvid = tymain[0];
          tymainnew = qtfbl !== 0 ? /* TypeVariable */Block.__(4, [Tyvarid.set_quantifiability(/* Unquantifiable */1, tvid)]) : /* TypeVariable */Block.__(4, [tvid]);
          break;
      case 5 : 
          tymainnew = /* TypeSynonym */Block.__(5, [
              List.map(iter, tymain[0]),
              tymain[1],
              make_unquantifiable_if_needed(qtfbl, tymain[2])
            ]);
          break;
      case 6 : 
          tymainnew = /* VariantType */Block.__(6, [
              List.map(iter, tymain[0]),
              tymain[1]
            ]);
          break;
      case 7 : 
          tymainnew = /* ForallType */Block.__(7, [
              tymain[0],
              tymain[1],
              make_unquantifiable_if_needed(qtfbl, tymain[2])
            ]);
          break;
      case 9 : 
          tymainnew = /* RecordType */Block.__(9, [Assoc.map_value(function (param) {
                    return make_unquantifiable_if_needed(qtfbl, param);
                  }, tymain[0])]);
          break;
      default:
        tymainnew = tymain;
    }
  }
  return /* tuple */[
          tystr[0],
          tymainnew
        ];
}

function make_bounded_free(qtfbl, kdenv, tystr) {
  var qtfbl$1 = qtfbl;
  var _kdenv = kdenv;
  var _tystr = tystr;
  var _lst = /* [] */0;
  while(true) {
    var lst = _lst;
    var tystr$1 = _tystr;
    var kdenv$1 = _kdenv;
    var tymain = tystr$1[1];
    var exit = 0;
    if (typeof tymain === "number") {
      exit = 1;
    }
    else if (tymain.tag === 7) {
      var newtvid = Tyvarid.fresh(qtfbl$1);
      var beta_000 = Range.dummy("eliminate_forall");
      var beta_001 = /* TypeVariable */Block.__(4, [newtvid]);
      var beta = /* tuple */[
        beta_000,
        beta_001
      ];
      _lst = /* :: */[
        /* tuple */[
          tymain[0],
          newtvid,
          beta
        ],
        lst
      ];
      _tystr = tymain[2];
      _kdenv = Kindenv.add(kdenv$1, newtvid, tymain[1]);
      continue ;
      
    }
    else {
      exit = 1;
    }
    if (exit === 1) {
      var tyfree = replace_id(List.map(function (param) {
                return /* tuple */[
                        param[0],
                        param[2]
                      ];
              }, lst), tystr$1);
      var kdenvfree = List.fold_left(function (oldkdenv, param) {
            return Kindenv.replace_type_variable_in_kindenv(oldkdenv, param[0], param[2]);
          }, kdenv$1, lst);
      var tyqtf = make_unquantifiable_if_needed(qtfbl$1, tyfree);
      var tyarglist = List.map(function (param) {
            return param[2];
          }, lst);
      return /* tuple */[
              tyqtf,
              tyarglist,
              kdenvfree
            ];
    }
    
  };
}

var empty = /* [] */0;

exports.empty                           = empty;
exports.to_list                         = to_list;
exports.from_list                       = from_list;
exports.map                             = map;
exports.add                             = add;
exports.find                            = find;
exports.overwrite_range_of_type         = overwrite_range_of_type;
exports.find_in_type_struct             = find_in_type_struct;
exports.find_in_type_environment        = find_in_type_environment;
exports.make_forall_type                = make_forall_type;
exports.string_of_type_environment      = string_of_type_environment;
exports.string_of_control_sequence_type = string_of_control_sequence_type;
exports.replace_id                      = replace_id;
exports.make_bounded_free               = make_bounded_free;
/* Kindenv Not a pure module */
