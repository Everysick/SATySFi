// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Range                   = require("./range");
var Pervasives              = require("bs-platform/lib/js/pervasives");
var Tyvarid                 = require("./tyvarid");
var Char                    = require("bs-platform/lib/js/char");
var Assoc                   = require("./assoc");
var Curry                   = require("bs-platform/lib/js/curry");
var Kindenv                 = require("./kindenv");
var $$String                = require("bs-platform/lib/js/string");
var List                    = require("bs-platform/lib/js/list");
var Caml_string             = require("bs-platform/lib/js/caml_string");

var type_variable_name_max = [0];

var type_valiable_name_list = [/* [] */0];

function string_of_record_type(f, asc) {
  var aux = function (lst) {
    if (lst) {
      var tail = lst[1];
      var match = lst[0];
      var tystr = match[1];
      var fldnm = match[0];
      if (tail) {
        return fldnm + (" : " + (Curry._1(f, tystr) + ("; " + aux(tail))));
      }
      else {
        return fldnm + (" : " + Curry._1(f, tystr));
      }
    }
    else {
      return " -- ";
    }
  };
  return "(|" + (aux(Assoc.to_list(asc)) + "|)");
}

function string_of_kind_struct(f, kdstr) {
  var aux = function (lst) {
    if (lst) {
      var tail = lst[1];
      var match = lst[0];
      var tystr = match[1];
      var fldnm = match[0];
      if (tail) {
        return fldnm + (" : " + (Curry._1(f, tystr) + ("; " + aux(tail))));
      }
      else {
        return fldnm + (" : " + Curry._1(f, tystr));
      }
    }
    else {
      return " -- ";
    }
  };
  if (kdstr) {
    return "(|" + (aux(Assoc.to_list(kdstr[0])) + "|)");
  }
  else {
    return "U";
  }
}

function variable_name_of_int(n) {
  return (
          n >= 26 ? variable_name_of_int(((n - n % 26 | 0) / 26 | 0) - 1 | 0) : ""
        ) + $$String.make(1, Char.chr(/* "a" */97 + n % 26 | 0));
}

function show_type_variable(f, name, bound, kdstr) {
  if (kdstr) {
    if (bound) {
      return name;
    }
    else {
      return "(#" + (name + (" <: " + (string_of_kind_struct(f, kdstr) + ")")));
    }
  }
  else if (bound) {
    return name;
  }
  else {
    return "#" + name;
  }
}

function new_type_variable_name(bound, f, tvid, kdstr) {
  var res = variable_name_of_int(type_variable_name_max[0]);
  type_variable_name_max[0] = type_variable_name_max[0] + 1 | 0;
  type_valiable_name_list[0] = /* :: */[
    /* tuple */[
      tvid,
      res,
      bound,
      kdstr
    ],
    type_valiable_name_list[0]
  ];
  return show_type_variable(f, res, bound, kdstr);
}

function new_bound_type_variable_name(param, param$1, param$2) {
  return new_type_variable_name(/* true */1, param, param$1, param$2);
}

function new_unbound_type_variable_name(param, param$1, param$2) {
  return new_type_variable_name(/* false */0, param, param$1, param$2);
}

function find_type_variable(f, tvid) {
  var _lst = type_valiable_name_list[0];
  while(true) {
    var lst = _lst;
    if (lst) {
      var match = lst[0];
      if (Tyvarid.same(match[0], tvid)) {
        return show_type_variable(f, match[1], match[2], match[3]);
      }
      else {
        _lst = lst[1];
        continue ;
        
      }
    }
    else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function string_of_type_struct(kdenv, tystr) {
  type_variable_name_max[0] = 0;
  type_valiable_name_list[0] = /* [] */0;
  return string_of_type_struct_sub(kdenv, tystr);
}

function string_of_type_struct_double(kdenv, tystr1, tystr2) {
  type_variable_name_max[0] = 0;
  type_valiable_name_list[0] = /* [] */0;
  var strty1 = string_of_type_struct_sub(kdenv, tystr1);
  var strty2 = string_of_type_struct_sub(kdenv, tystr2);
  return /* tuple */[
          strty1,
          strty2
        ];
}

function string_of_type_struct_sub(kdenv, tystr) {
  var iter = function (param) {
    return string_of_type_struct_sub(kdenv, param);
  };
  var tymain = tystr[1];
  if (typeof tymain === "number") {
    switch (tymain) {
      case 0 : 
          return "unit";
      case 1 : 
          return "int";
      case 2 : 
          return "string";
      case 3 : 
          return "bool";
      
    }
  }
  else {
    switch (tymain.tag | 0) {
      case 0 : 
          var tydom = tymain[0];
          var strdom = string_of_type_struct_sub(kdenv, tydom);
          var strcod = string_of_type_struct_sub(kdenv, tymain[1]);
          var $js;
          var $js$1 = tydom[1];
          $js = typeof $js$1 === "number" || $js$1.tag ? strdom : "(" + (strdom + ")");
          return $js + (" -> " + strcod);
      case 1 : 
          var tycont = tymain[0];
          var strcont = string_of_type_struct_sub(kdenv, tycont);
          var $js$2;
          var $js$3 = tycont[1];
          if (typeof $js$3 === "number") {
            $js$2 = strcont;
          }
          else {
            switch ($js$3.tag | 0) {
              case 0 : 
              case 3 : 
                  $js$2 = "(" + (strcont + ")");
                  break;
              default:
                $js$2 = strcont;
            }
          }
          return $js$2 + " list";
      case 2 : 
          var tycont$1 = tymain[0];
          var strcont$1 = string_of_type_struct_sub(kdenv, tycont$1);
          var $js$4;
          var $js$5 = tycont$1[1];
          if (typeof $js$5 === "number") {
            $js$4 = strcont$1;
          }
          else {
            switch ($js$5.tag | 0) {
              case 0 : 
              case 3 : 
                  $js$4 = "(" + (strcont$1 + ")");
                  break;
              default:
                $js$4 = strcont$1;
            }
          }
          return $js$4 + " ref";
      case 3 : 
          return string_of_type_struct_list(kdenv, tymain[0]);
      case 4 : 
          var tvid = tymain[0];
          var $js$6;
          try {
            $js$6 = find_type_variable(function (param) {
                  return string_of_type_struct_sub(kdenv, param);
                }, tvid);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              try {
                $js$6 = new_unbound_type_variable_name(iter, tvid, Kindenv.find(kdenv, tvid));
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  $js$6 = Pervasives.failwith("type variable id '" + (Tyvarid.show_direct(tvid) + " not found in kind environment"));
                }
                else {
                  throw exn$1;
                }
              }
            }
            else {
              throw exn;
            }
          }
          return (
                  Tyvarid.is_quantifiable(tvid) ? "'" : "'_"
                ) + $js$6;
      case 5 : 
          return string_of_type_argument_list(kdenv, tymain[0]) + (tymain[1] + (" (= " + (string_of_type_struct_sub(kdenv, tymain[2]) + ")")));
      case 6 : 
          return string_of_type_argument_list(kdenv, tymain[0]) + tymain[1];
      case 7 : 
          var kdstr = tymain[1];
          var meta = new_bound_type_variable_name(iter, tymain[0], kdstr);
          return "(forall " + (meta + (" <: " + (string_of_kind_struct(function (param) {
                            return string_of_type_struct_sub(kdenv, param);
                          }, kdstr) + (". " + (string_of_type_struct_sub(kdenv, tymain[2]) + ")")))));
      case 8 : 
          return "['" + (tymain[0] + "]");
      case 9 : 
          return string_of_record_type(iter, tymain[0]);
      
    }
  }
}

function string_of_type_argument_list(kdenv, tyarglist) {
  if (tyarglist) {
    var head = tyarglist[0];
    var strhd = string_of_type_struct_sub(kdenv, head);
    var strtl = string_of_type_argument_list(kdenv, tyarglist[1]);
    var headmain = head[1];
    var $js;
    var exit = 0;
    if (typeof headmain === "number") {
      $js = strhd;
    }
    else {
      switch (headmain.tag | 0) {
        case 0 : 
        case 1 : 
        case 2 : 
        case 3 : 
            exit = 1;
            break;
        case 5 : 
        case 6 : 
            if (headmain[0]) {
              exit = 1;
            }
            else {
              $js = strhd;
            }
            break;
        default:
          $js = strhd;
      }
    }
    if (exit === 1) {
      $js = "(" + (strhd + ")");
    }
    return $js + (" " + strtl);
  }
  else {
    return "";
  }
}

function string_of_type_struct_list(kdenv, tylist) {
  if (tylist) {
    var tail = tylist[1];
    var head = tylist[0];
    var strhead = string_of_type_struct_sub(kdenv, head);
    var strtail = string_of_type_struct_list(kdenv, tail);
    var $js;
    var $js$1 = head[1];
    if (typeof $js$1 === "number") {
      $js = strhead;
    }
    else {
      switch ($js$1.tag | 0) {
        case 0 : 
        case 3 : 
            $js = "(" + (strhead + ")");
            break;
        default:
          $js = strhead;
      }
    }
    return $js + (
            tail ? " * " + strtail : ""
          );
  }
  else {
    return "";
  }
}

function string_of_utast(_param) {
  while(true) {
    var param = _param;
    var utastmain = param[1];
    if (typeof utastmain === "number") {
      switch (utastmain) {
        case 0 : 
            return "{}";
        case 1 : 
            return "()";
        case 2 : 
            return "break";
        case 3 : 
            return "[]";
        case 4 : 
            return "$";
        case 5 : 
            return "finish";
        default:
          return "OTHER";
      }
    }
    else {
      switch (utastmain.tag | 0) {
        case 0 : 
            return Pervasives.string_of_int(utastmain[0]);
        case 1 : 
            return Pervasives.string_of_bool(utastmain[0]);
        case 2 : 
            return "{" + (utastmain[0] + "}");
        case 3 : 
            var ut2 = utastmain[1];
            var match = ut2[1];
            var ut1 = utastmain[0];
            var exit = 0;
            if (typeof match === "number") {
              if (match !== 0) {
                exit = 1;
              }
              else {
                _param = ut1;
                continue ;
                
              }
            }
            else {
              exit = 1;
            }
            if (exit === 1) {
              return "(" + (string_of_utast(ut1) + (" ^ " + (string_of_utast(ut2) + ")")));
            }
            break;
        case 4 : 
            return "(" + (string_of_utast(utastmain[0]) + (" :: " + (string_of_utast(utastmain[1]) + ")")));
        case 5 : 
            return "(" + (string_of_utast(utastmain[0]) + (", " + (string_of_utast(utastmain[1]) + ")")));
        case 8 : 
            return utastmain[0];
        case 9 : 
            return "(" + (string_of_utast(utastmain[0]) + (" " + (string_of_utast(utastmain[1]) + ")")));
        case 10 : 
            return "(let ... in " + (string_of_utast(utastmain[1]) + ")");
        case 11 : 
            return "(if " + (string_of_utast(utastmain[0]) + (" then " + (string_of_utast(utastmain[1]) + (" else " + (string_of_utast(utastmain[2]) + ")")))));
        case 12 : 
            return "(" + (utastmain[1] + (" -> " + (string_of_utast(utastmain[2]) + ")")));
        case 13 : 
            return "(match " + (string_of_utast(utastmain[0]) + (" with" + (string_of_pmcons(utastmain[1]) + ")")));
        case 25 : 
            return "(itemize " + (string_of_itemize(0, utastmain[0]) + ")");
        default:
          return "OTHER";
      }
    }
  };
}

function string_of_itemize(dp, param) {
  var partial_arg = dp + 1 | 0;
  return "(" + ($$String.make(dp, /* "*" */42) + (" " + (string_of_utast(param[0]) + (List.fold_left(function (x, y) {
                      return x + (" " + y);
                    }, "", List.map(function (param) {
                          return string_of_itemize(partial_arg, param);
                        }, param[1])) + ")"))));
}

function string_of_pmcons(pmcons) {
  if (typeof pmcons === "number") {
    return "";
  }
  else if (pmcons.tag) {
    return " | " + (string_of_utpat(pmcons[0]) + (" when " + (string_of_utast(pmcons[1]) + (" -> " + (string_of_utast(pmcons[2]) + string_of_pmcons(pmcons[3]))))));
  }
  else {
    return " | " + (string_of_utpat(pmcons[0]) + (" -> " + (string_of_utast(pmcons[1]) + string_of_pmcons(pmcons[2]))));
  }
}

function string_of_utpat(param) {
  var pat = param[1];
  if (typeof pat === "number") {
    switch (pat) {
      case 0 : 
          return "()";
      case 1 : 
          return "[]";
      case 2 : 
          return "$";
      case 3 : 
          return "_";
      
    }
  }
  else {
    switch (pat.tag | 0) {
      case 0 : 
          return Pervasives.string_of_int(pat[0]);
      case 1 : 
          return Pervasives.string_of_bool(pat[0]);
      case 2 : 
          return string_of_utast(pat[0]);
      case 3 : 
          return string_of_utpat(pat[0]) + (" :: " + string_of_utpat(pat[1]));
      case 4 : 
          return "(" + (string_of_utpat(pat[0]) + (", " + (string_of_utpat(pat[1]) + ")")));
      case 5 : 
          return pat[0];
      case 6 : 
          return "(" + (string_of_utpat(pat[1]) + (" as " + (pat[0] + ")")));
      case 7 : 
          return "(" + (pat[0] + (" " + (string_of_utpat(pat[1]) + ")")));
      
    }
  }
}

function escape_letters(str) {
  var aux = function (str, index) {
    if (index <= 0) {
      return "";
    }
    else {
      var other = Caml_string.get(str, 0);
      var head = other !== 34 ? (
          other !== 92 ? $$String.make(1, other) : "\\\\"
        ) : '\\"';
      return head + aux($$String.sub(str, 1, index - 1 | 0), index - 1 | 0);
    }
  };
  return aux(str, str.length);
}

function string_of_ast(ast) {
  if (typeof ast === "number") {
    switch (ast) {
      case 0 : 
          return '""';
      case 1 : 
          return "()";
      case 2 : 
          return "break";
      case 4 : 
          return "[]";
      case 5 : 
          return "end-of-tuple";
      case 6 : 
          return "finish-header-file";
      default:
        return "OTHER";
    }
  }
  else {
    switch (ast.tag | 0) {
      case 0 : 
          return Pervasives.string_of_int(ast[0]);
      case 1 : 
          return Pervasives.string_of_bool(ast[0]);
      case 2 : 
          return '"' + (escape_letters(ast[0]) + '"');
      case 3 : 
          return "(deeper " + (string_of_ast(ast[0]) + ")");
      case 4 : 
          return "(" + (string_of_ast(ast[0]) + (" ^ " + (string_of_ast(ast[1]) + ")")));
      case 5 : 
          return "(" + (ast[0] + (" *-> " + (string_of_ast(ast[1]) + ")")));
      case 6 : 
          return "evaluated-environment";
      case 7 : 
          return "(" + (string_of_ast(ast[0]) + (" :: " + (string_of_ast(ast[1]) + ")")));
      case 8 : 
          return "(" + (string_of_ast(ast[0]) + (", " + (string_of_ast(ast[1]) + ")")));
      case 9 : 
          return "(| ... |)";
      case 10 : 
          return string_of_ast(ast[0]) + ("#" + ast[1]);
      case 11 : 
          return "(let ... in " + (string_of_ast(ast[1]) + ")");
      case 12 : 
          return "_" + (ast[0] + "_");
      case 13 : 
          return "(if " + (string_of_ast(ast[0]) + (" then " + (string_of_ast(ast[1]) + (" else " + (string_of_ast(ast[2]) + ")")))));
      case 14 : 
          return "(" + (ast[0] + (" -> " + (string_of_ast(ast[1]) + ")")));
      case 15 : 
          return "(" + (string_of_ast(ast[0]) + (" " + (string_of_ast(ast[1]) + ")")));
      case 16 : 
          return "(match ...)";
      case 17 : 
          return "(constructor " + (ast[0] + (" " + (string_of_ast(ast[1]) + ")")));
      case 18 : 
          return "(let-mutable " + (ast[0] + (" <- " + (string_of_ast(ast[1]) + (" in " + (string_of_ast(ast[2]) + ")")))));
      case 19 : 
          return "(sequential " + (string_of_ast(ast[0]) + (" ; " + (string_of_ast(ast[1]) + ")")));
      case 20 : 
          return "(while " + (string_of_ast(ast[0]) + (" do " + (string_of_ast(ast[1]) + ")")));
      case 21 : 
          return "(" + (ast[0] + (" <- " + (string_of_ast(ast[1]) + ")")));
      case 22 : 
          return "<mutable>";
      case 23 : 
          return "(!" + (string_of_ast(ast[0]) + ")");
      case 24 : 
          return "(declare-global-hash " + (string_of_ast(ast[0]) + (" <<- " + (string_of_ast(ast[1]) + ")")));
      case 25 : 
          return "(overwrite-global-hash " + (string_of_ast(ast[0]) + (" <<- " + (string_of_ast(ast[1]) + ")")));
      case 26 : 
          return "(!!" + (string_of_ast(ast[0]) + ")");
      case 29 : 
          return "(apply-class-and-id " + (string_of_ast(ast[0]) + (" " + (string_of_ast(ast[1]) + (" " + (string_of_ast(ast[2]) + ")")))));
      case 41 : 
          return "(same " + (string_of_ast(ast[0]) + (" " + (string_of_ast(ast[1]) + ")")));
      case 42 : 
          return "(string-sub " + (string_of_ast(ast[0]) + (" " + (string_of_ast(ast[1]) + (" " + (string_of_ast(ast[2]) + ")")))));
      case 43 : 
          return "(string-length " + (string_of_ast(ast[0]) + ")");
      case 44 : 
          return "(arabic " + (string_of_ast(ast[0]) + ")");
      case 45 : 
          return "(module " + (ast[0] + " = struct ... end-struct)");
      default:
        return "OTHER";
    }
  }
}

function string_of_type_struct_basic(tystr) {
  var tymain = tystr[1];
  var qstn = Range.is_dummy(tystr[0]) ? "?" : "";
  if (typeof tymain === "number") {
    switch (tymain) {
      case 0 : 
          return "unit" + qstn;
      case 1 : 
          return "int" + qstn;
      case 2 : 
          return "string" + qstn;
      case 3 : 
          return "bool" + qstn;
      
    }
  }
  else {
    switch (tymain.tag | 0) {
      case 0 : 
          var tydom = tymain[0];
          var strdom = string_of_type_struct_basic(tydom);
          var strcod = string_of_type_struct_basic(tymain[1]);
          var $js;
          var $js$1 = tydom[1];
          $js = typeof $js$1 === "number" || $js$1.tag ? strdom : "(" + (strdom + ")");
          return $js + (" ->" + (qstn + strcod));
      case 1 : 
          var tycont = tymain[0];
          var strcont = string_of_type_struct_basic(tycont);
          var tycontmain = tycont[1];
          var $js$2;
          var exit = 0;
          if (typeof tycontmain === "number") {
            $js$2 = strcont;
          }
          else {
            switch (tycontmain.tag | 0) {
              case 0 : 
              case 3 : 
                  exit = 1;
                  break;
              case 5 : 
              case 6 : 
                  if (tycontmain[0]) {
                    exit = 1;
                  }
                  else {
                    $js$2 = strcont;
                  }
                  break;
              default:
                $js$2 = strcont;
            }
          }
          if (exit === 1) {
            $js$2 = "(" + (strcont + ")");
          }
          return $js$2 + (" list" + qstn);
      case 2 : 
          var tycont$1 = tymain[0];
          var strcont$1 = string_of_type_struct_basic(tycont$1);
          var tycontmain$1 = tycont$1[1];
          var $js$3;
          var exit$1 = 0;
          if (typeof tycontmain$1 === "number") {
            $js$3 = strcont$1;
          }
          else {
            switch (tycontmain$1.tag | 0) {
              case 0 : 
              case 3 : 
                  exit$1 = 1;
                  break;
              case 5 : 
              case 6 : 
                  if (tycontmain$1[0]) {
                    exit$1 = 1;
                  }
                  else {
                    $js$3 = strcont$1;
                  }
                  break;
              default:
                $js$3 = strcont$1;
            }
          }
          if (exit$1 === 1) {
            $js$3 = "(" + (strcont$1 + ")");
          }
          return $js$3 + (" ref" + qstn);
      case 3 : 
          return string_of_type_struct_list_basic(tymain[0]);
      case 4 : 
          return "'" + (Tyvarid.show_direct(tymain[0]) + qstn);
      case 5 : 
          return string_of_type_argument_list_basic(tymain[0]) + (tymain[1] + ("(= " + (string_of_type_struct_basic(tymain[2]) + ")")));
      case 6 : 
          return string_of_type_argument_list_basic(tymain[0]) + (tymain[1] + ("@" + qstn));
      case 7 : 
          var kdstr = tymain[1];
          var tvid = tymain[0];
          if (kdstr) {
            return "('" + (Tyvarid.show_direct(tvid) + (" <: " + (string_of_kind_struct(string_of_type_struct_basic, kdstr) + (". " + (string_of_type_struct_basic(tymain[2]) + ")")))));
          }
          else {
            return "('" + (Tyvarid.show_direct(tvid) + (". " + (string_of_type_struct_basic(tymain[2]) + ")")));
          }
      case 8 : 
          return tymain[0];
      case 9 : 
          return string_of_record_type(string_of_type_struct_basic, tymain[0]);
      
    }
  }
}

function string_of_type_argument_list_basic(tyarglist) {
  if (tyarglist) {
    var head = tyarglist[0];
    var strhd = string_of_type_struct_basic(head);
    var strtl = string_of_type_argument_list_basic(tyarglist[1]);
    var headmain = head[1];
    var $js;
    var exit = 0;
    if (typeof headmain === "number") {
      $js = strhd;
    }
    else {
      switch (headmain.tag | 0) {
        case 0 : 
        case 1 : 
        case 2 : 
        case 3 : 
            exit = 1;
            break;
        case 5 : 
        case 6 : 
            if (headmain[0]) {
              exit = 1;
            }
            else {
              $js = strhd;
            }
            break;
        default:
          $js = strhd;
      }
    }
    if (exit === 1) {
      $js = "(" + (strhd + ")");
    }
    return $js + (" " + strtl);
  }
  else {
    return "";
  }
}

function string_of_type_struct_list_basic(tylist) {
  if (tylist) {
    var tail = tylist[1];
    var head = tylist[0];
    if (tail) {
      var strhd = string_of_type_struct_basic(head);
      var strtl = string_of_type_struct_list_basic(tail);
      var $js;
      var $js$1 = head[1];
      if (typeof $js$1 === "number") {
        $js = strhd;
      }
      else {
        switch ($js$1.tag | 0) {
          case 0 : 
          case 3 : 
              $js = "(" + (strhd + ")");
              break;
          default:
            $js = strhd;
        }
      }
      return $js + (" * " + strtl);
    }
    else {
      var strhd$1 = string_of_type_struct_basic(head);
      var $js$2 = head[1];
      if (typeof $js$2 === "number") {
        return strhd$1;
      }
      else {
        switch ($js$2.tag | 0) {
          case 0 : 
          case 3 : 
              return "(" + (strhd$1 + ")");
          default:
            return strhd$1;
        }
      }
    }
  }
  else {
    return "";
  }
}

function string_of_kind_struct_basic(kdstr) {
  return string_of_kind_struct(string_of_type_struct_basic, kdstr);
}

function string_of_kind_environment(kdenv) {
  return Kindenv.to_string(string_of_kind_struct_basic, kdenv);
}

exports.string_of_utast              = string_of_utast;
exports.string_of_ast                = string_of_ast;
exports.string_of_type_struct_basic  = string_of_type_struct_basic;
exports.string_of_kind_struct_basic  = string_of_kind_struct_basic;
exports.string_of_type_struct        = string_of_type_struct;
exports.string_of_type_struct_double = string_of_type_struct_double;
exports.string_of_kind_environment   = string_of_kind_environment;
/* Kindenv Not a pure module */
