// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Out                     = require("./out");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Caml_obj                = require("bs-platform/lib/js/caml_obj");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions");
var Pervasives              = require("bs-platform/lib/js/pervasives");
var Hashtbl                 = require("bs-platform/lib/js/hashtbl");
var Caml_int32              = require("bs-platform/lib/js/caml_int32");
var Block                   = require("bs-platform/lib/js/block");
var Display                 = require("./display");
var Assoc                   = require("./assoc");
var $$String                = require("bs-platform/lib/js/string");
var Caml_string             = require("bs-platform/lib/js/caml_string");
var List                    = require("bs-platform/lib/js/list");
var Types                   = require("./types");

var EvalError = Caml_exceptions.create("Evaluator.EvalError");

function interpret(_env, _ast) {
  while(true) {
    var ast = _ast;
    var env = _env;
    if (typeof ast === "number") {
      switch (ast) {
        case 0 : 
            return /* StringEmpty */0;
        case 1 : 
            return /* UnitConstant */1;
        case 2 : 
            return /* BreakAndIndent */2;
        case 3 : 
            return /* SoftBreakAndIndent */3;
        case 4 : 
            return /* EndOfList */4;
        case 5 : 
            return /* EndOfTuple */5;
        case 6 : 
            return /* EvaluatedEnvironment */Block.__(6, [env]);
        
      }
    }
    else {
      switch (ast.tag | 0) {
        case 0 : 
            return /* NumericConstant */Block.__(0, [ast[0]]);
        case 1 : 
            return /* BooleanConstant */Block.__(1, [ast[0]]);
        case 2 : 
            return /* StringConstant */Block.__(2, [ast[0]]);
        case 3 : 
            return /* DeeperIndent */Block.__(3, [interpret(env, ast[0])]);
        case 4 : 
            var valuef = interpret(env, ast[0]);
            var valuel = interpret(env, ast[1]);
            var exit = 0;
            if (typeof valuef === "number") {
              if (valuef !== 0) {
                exit = 1;
              }
              else {
                return valuel;
              }
            }
            else {
              exit = 1;
            }
            if (exit === 1) {
              if (typeof valuel === "number") {
                if (valuel !== 0) {
                  return /* Concat */Block.__(4, [
                            valuef,
                            valuel
                          ]);
                }
                else {
                  return valuef;
                }
              }
              else {
                return /* Concat */Block.__(4, [
                          valuef,
                          valuel
                        ]);
              }
            }
            break;
        case 5 : 
            return /* FuncWithEnvironment */Block.__(5, [
                      ast[0],
                      ast[1],
                      ast[2]
                    ]);
        case 6 : 
            return /* EvaluatedEnvironment */Block.__(6, [ast[0]]);
        case 7 : 
            var valuehd = interpret(env, ast[0]);
            var valuetl = interpret(env, ast[1]);
            return /* ListCons */Block.__(7, [
                      valuehd,
                      valuetl
                    ]);
        case 8 : 
            var valuehd$1 = interpret(env, ast[0]);
            var valuetl$1 = interpret(env, ast[1]);
            return /* TupleCons */Block.__(8, [
                      valuehd$1,
                      valuetl$1
                    ]);
        case 9 : 
            return /* Record */Block.__(9, [Assoc.map_value((function(env){
                          return function (param) {
                            return interpret(env, param);
                          }
                          }(env)), ast[0])]);
        case 10 : 
            var value1 = interpret(env, ast[0]);
            if (typeof value1 === "number") {
              return Pervasives.failwith("AccessField: not a Record");
            }
            else if (value1.tag === 9) {
              return Assoc.find(/* None */0, value1[0], ast[1]);
            }
            else {
              return Pervasives.failwith("AccessField: not a Record");
            }
            break;
        case 11 : 
            var env_func = Hashtbl.copy(env);
            add_mutuals_to_environment(/* false */0, env_func, env_func, "", ast[0]);
            _ast = ast[1];
            _env = env_func;
            continue ;
            case 12 : 
            var varnm = ast[0];
            try {
              var content = Hashtbl.find(env, varnm)[0];
              if (typeof content === "number") {
                return content;
              }
              else if (content.tag === 28) {
                _ast = content[0];
                _env = content[1][0];
                continue ;
                
              }
              else {
                return content;
              }
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return Pervasives.failwith("ContentOf: variable '" + (varnm + "' not found"));
              }
              else {
                throw exn;
              }
            }
            break;
        case 13 : 
            if (interpret_bool(env, ast[0])) {
              _ast = ast[1];
              continue ;
              
            }
            else {
              _ast = ast[2];
              continue ;
              
            }
            break;
        case 14 : 
            return /* FuncWithEnvironment */Block.__(5, [
                      ast[0],
                      ast[1],
                      env
                    ]);
        case 15 : 
            var fspec = interpret(env, ast[0]);
            if (typeof fspec === "number") {
              return Pervasives.failwith("Apply: not a function");
            }
            else if (fspec.tag === 5) {
              var valuel$1 = interpret(env, ast[1]);
              var env_new = Hashtbl.copy(fspec[2]);
              Hashtbl.add(env_new, fspec[0], [valuel$1]);
              _ast = fspec[1];
              _env = env_new;
              continue ;
              
            }
            else {
              return Pervasives.failwith("Apply: not a function");
            }
            break;
        case 16 : 
            var valueobj = interpret(env, ast[0]);
            var env$1 = env;
            var astobj = valueobj;
            var _pmcons = ast[1];
            while(true) {
              var pmcons = _pmcons;
              if (typeof pmcons === "number") {
                throw [
                      EvalError,
                      "no matches"
                    ];
              }
              else if (pmcons.tag) {
                var envnew = Hashtbl.copy(env$1);
                var b = check_pattern_matching(envnew, pmcons[0], astobj);
                var bb = interpret_bool(envnew, pmcons[1]);
                if (b && bb) {
                  return interpret(envnew, pmcons[2]);
                }
                else {
                  _pmcons = pmcons[3];
                  continue ;
                  
                }
              }
              else {
                var envnew$1 = Hashtbl.copy(env$1);
                var b$1 = check_pattern_matching(envnew$1, pmcons[0], astobj);
                if (b$1) {
                  return interpret(envnew$1, pmcons[1]);
                }
                else {
                  _pmcons = pmcons[2];
                  continue ;
                  
                }
              }
            };
        case 17 : 
            var valuecont = interpret(env, ast[1]);
            return /* Constructor */Block.__(17, [
                      ast[0],
                      valuecont
                    ]);
        case 18 : 
            var valueini = interpret(env, ast[1]);
            var loc = [valueini];
            var env_new$1 = Hashtbl.copy(env);
            Hashtbl.add(env_new$1, ast[0], [/* Location */Block.__(22, [loc])]);
            _ast = ast[2];
            _env = env_new$1;
            continue ;
            case 19 : 
            var value1$1 = interpret(env, ast[0]);
            var value2 = interpret(env, ast[1]);
            if (typeof value1$1 === "number") {
              if (value1$1 !== 1) {
                return Pervasives.failwith("Sequential: first operand value is not a UnitConstant");
              }
              else {
                return value2;
              }
            }
            else {
              return Pervasives.failwith("Sequential: first operand value is not a UnitConstant");
            }
        case 20 : 
            var astc = ast[1];
            var astb = ast[0];
            if (interpret_bool(env, astb)) {
              interpret(env, astc);
              _ast = /* WhileDo */Block.__(20, [
                  astb,
                  astc
                ]);
              continue ;
              
            }
            else {
              return /* UnitConstant */1;
            }
            break;
        case 21 : 
            var varnm$1 = ast[0];
            try {
              var rfvalue = Hashtbl.find(env, varnm$1);
              var match = rfvalue[0];
              if (typeof match === "number") {
                return Pervasives.failwith("Overwrite: value is not a Location");
              }
              else if (match.tag === 22) {
                var newvalue = interpret(env, ast[1]);
                match[0][0] = newvalue;
                return /* UnitConstant */1;
              }
              else {
                return Pervasives.failwith("Overwrite: value is not a Location");
              }
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                return Pervasives.failwith("Overwrite: mutable value '" + (varnm$1 + "' not found"));
              }
              else {
                throw exn$1;
              }
            }
            break;
        case 22 : 
            return /* Location */Block.__(22, [ast[0]]);
        case 23 : 
            var valuecont$1 = interpret(env, ast[0]);
            if (typeof valuecont$1 === "number") {
              return Pervasives.failwith("Reference");
            }
            else if (valuecont$1.tag === 22) {
              return valuecont$1[0][0];
            }
            else {
              return Pervasives.failwith("Reference");
            }
            break;
        case 24 : 
            try {
              var str_key = Out.main(interpret(env, ast[0]));
              var valueini$1 = interpret(env, ast[1]);
              var loc$1 = [valueini$1];
              Hashtbl.add(Types.global_hash_env, str_key, [/* Location */Block.__(22, [loc$1])]);
              return /* UnitConstant */1;
            }
            catch (exn$2){
              if (exn$2[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "this cannot hapen:\n    illegal hash key for 'declare-global-hash'"
                    ];
              }
              else {
                throw exn$2;
              }
            }
            break;
        case 25 : 
            try {
              var str_key$1 = Out.main(interpret(env, ast[0]));
              try {
                var rfvalue$1 = Hashtbl.find(Types.global_hash_env, str_key$1);
                var match$1 = rfvalue$1[0];
                if (typeof match$1 === "number") {
                  return Pervasives.failwith("OverwriteGlobalHash: value is not a Location");
                }
                else if (match$1.tag === 22) {
                  var valuenew = interpret(env, ast[1]);
                  match$1[0][0] = valuenew;
                  return /* UnitConstant */1;
                }
                else {
                  return Pervasives.failwith("OverwriteGlobalHash: value is not a Location");
                }
              }
              catch (exn$3){
                if (exn$3 === Caml_builtin_exceptions.not_found) {
                  throw [
                        EvalError,
                        'undefined global hash key "' + (str_key$1 + '"')
                      ];
                }
                else {
                  throw exn$3;
                }
              }
            }
            catch (exn$4){
              if (exn$4[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "illegal argument for '<<-': " + exn$4[1]
                    ];
              }
              else {
                throw exn$4;
              }
            }
            break;
        case 26 : 
            return /* ReferenceFinal */Block.__(26, [interpret(env, ast[0])]);
        case 27 : 
            return /* LazyContentWithEnvironmentRef */Block.__(28, [
                      ast[0],
                      [env]
                    ]);
        case 28 : 
            return /* LazyContentWithEnvironmentRef */Block.__(28, [
                      ast[0],
                      ast[1]
                    ]);
        case 29 : 
            var astf = ast[2];
            var idnmast = ast[1];
            var clsnmast = ast[0];
            "%1 " + (Display.string_of_ast(astf) + "\n");
            var valuef$1 = interpret(env, /* LetIn */Block.__(11, [
                    /* MutualLetCons */[
                      "class-name",
                      clsnmast,
                      /* EndOfMutualLet */0
                    ],
                    /* LetIn */Block.__(11, [
                        /* MutualLetCons */[
                          "id-name",
                          idnmast,
                          /* EndOfMutualLet */0
                        ],
                        astf
                      ])
                  ]));
            "%2 " + (Display.string_of_ast(valuef$1) + "\n");
            if (typeof valuef$1 === "number" || valuef$1.tag !== 5) {
              return valuef$1;
            }
            else {
              return /* FuncWithEnvironment */Block.__(5, [
                        valuef$1[0],
                        /* LetIn */Block.__(11, [
                            /* MutualLetCons */[
                              "class-name",
                              clsnmast,
                              /* EndOfMutualLet */0
                            ],
                            /* LetIn */Block.__(11, [
                                /* MutualLetCons */[
                                  "id-name",
                                  idnmast,
                                  /* EndOfMutualLet */0
                                ],
                                valuef$1[1]
                              ])
                          ]),
                        valuef$1[2]
                      ]);
            }
            break;
        case 30 : 
            var numl = interpret_int(env, ast[0]);
            var numr = interpret_int(env, ast[1]);
            return /* NumericConstant */Block.__(0, [Caml_int32.imul(numl, numr)]);
        case 31 : 
            var numl$1 = interpret_int(env, ast[0]);
            var numr$1 = interpret_int(env, ast[1]);
            try {
              return /* NumericConstant */Block.__(0, [Caml_int32.div(numl$1, numr$1)]);
            }
            catch (exn$5){
              if (exn$5 === Caml_builtin_exceptions.division_by_zero) {
                throw [
                      EvalError,
                      "division by zero"
                    ];
              }
              else {
                throw exn$5;
              }
            }
            break;
        case 32 : 
            var numl$2 = interpret_int(env, ast[0]);
            var numr$2 = interpret_int(env, ast[1]);
            try {
              return /* NumericConstant */Block.__(0, [Caml_int32.mod_(numl$2, numr$2)]);
            }
            catch (exn$6){
              if (exn$6 === Caml_builtin_exceptions.division_by_zero) {
                throw [
                      EvalError,
                      "division by zero"
                    ];
              }
              else {
                throw exn$6;
              }
            }
            break;
        case 33 : 
            var numl$3 = interpret_int(env, ast[0]);
            var numr$3 = interpret_int(env, ast[1]);
            return /* NumericConstant */Block.__(0, [numl$3 + numr$3 | 0]);
        case 34 : 
            var numl$4 = interpret_int(env, ast[0]);
            var numr$4 = interpret_int(env, ast[1]);
            return /* NumericConstant */Block.__(0, [numl$4 - numr$4 | 0]);
        case 35 : 
            var numl$5 = interpret_int(env, ast[0]);
            var numr$5 = interpret_int(env, ast[1]);
            return /* BooleanConstant */Block.__(1, [+(numl$5 > numr$5)]);
        case 36 : 
            var numl$6 = interpret_int(env, ast[0]);
            var numr$6 = interpret_int(env, ast[1]);
            return /* BooleanConstant */Block.__(1, [+(numl$6 < numr$6)]);
        case 37 : 
            var numl$7 = interpret_int(env, ast[0]);
            var numr$7 = interpret_int(env, ast[1]);
            return /* BooleanConstant */Block.__(1, [+(numl$7 === numr$7)]);
        case 38 : 
            var blnl = interpret_bool(env, ast[0]);
            var blnr = interpret_bool(env, ast[1]);
            return /* BooleanConstant */Block.__(1, [+(blnl && blnr)]);
        case 39 : 
            var blnl$1 = interpret_bool(env, ast[0]);
            var blnr$1 = interpret_bool(env, ast[1]);
            return /* BooleanConstant */Block.__(1, [+(blnl$1 || blnr$1)]);
        case 40 : 
            var blnl$2 = interpret_bool(env, ast[0]);
            return /* BooleanConstant */Block.__(1, [!blnl$2]);
        case 41 : 
            var str1;
            try {
              str1 = Out.main(interpret(env, ast[0]));
            }
            catch (exn$7){
              if (exn$7[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "illegal argument for 'same':\n    " + exn$7[1]
                    ];
              }
              else {
                throw exn$7;
              }
            }
            var str2;
            try {
              str2 = Out.main(interpret(env, ast[1]));
            }
            catch (exn$8){
              if (exn$8[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "illegal argument for 'same':\n    " + exn$8[1]
                    ];
              }
              else {
                throw exn$8;
              }
            }
            return /* BooleanConstant */Block.__(1, [+(Caml_string.caml_string_compare(str1, str2) === 0)]);
        case 42 : 
            var str;
            try {
              str = Out.main(interpret(env, ast[0]));
            }
            catch (exn$9){
              if (exn$9[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "illegal argument for 'string-sub':\n    " + exn$9[1]
                    ];
              }
              else {
                throw exn$9;
              }
            }
            var pos = interpret_int(env, ast[1]);
            var wid = interpret_int(env, ast[2]);
            return /* StringConstant */Block.__(2, [$$String.sub(str, pos, wid)]);
        case 43 : 
            var str$1;
            try {
              str$1 = Out.main(interpret(env, ast[0]));
            }
            catch (exn$10){
              if (exn$10[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "Illegal argument for 'string-length': " + exn$10[1]
                    ];
              }
              else {
                throw exn$10;
              }
            }
            return /* NumericConstant */Block.__(0, [str$1.length]);
        case 44 : 
            var num = interpret_int(env, interpret(env, ast[0]));
            return /* StringConstant */Block.__(2, [Pervasives.string_of_int(num)]);
        case 45 : 
            var env_out = Hashtbl.copy(env);
            var env_in = Hashtbl.copy(env);
            add_module_to_environment(env_out, env_in, ast[0], ast[1]);
            _ast = ast[2];
            _env = env_out;
            continue ;
            
      }
    }
  };
}

function interpret_bool(env, ast) {
  var vb = interpret(env, ast);
  if (typeof vb === "number") {
    return Pervasives.failwith("interpret_bool: not a BooleanConstant");
  }
  else if (vb.tag === 1) {
    return vb[0];
  }
  else {
    return Pervasives.failwith("interpret_bool: not a BooleanConstant");
  }
}

function interpret_int(env, ast) {
  var vi = interpret(env, ast);
  var exit = 0;
  if (typeof vi === "number") {
    exit = 1;
  }
  else if (vi.tag) {
    exit = 1;
  }
  else {
    return vi[0];
  }
  if (exit === 1) {
    return Pervasives.failwith("interpret_int: not a NumericConstant; " + (Display.string_of_ast(ast) + (" ->* " + Display.string_of_ast(vi))));
  }
  
}

function make_variable_name(mdlnm, varnm) {
  if (mdlnm === "") {
    return varnm;
  }
  else {
    return mdlnm + ("." + varnm);
  }
}

function add_module_to_environment(eout, ein, mdlnm, _mdltrdef) {
  while(true) {
    var mdltrdef = _mdltrdef;
    if (typeof mdltrdef === "number") {
      return /* () */0;
    }
    else {
      switch (mdltrdef.tag | 0) {
        case 0 : 
            add_mutuals_to_environment(/* true */1, eout, ein, mdlnm, mdltrdef[0]);
            _mdltrdef = mdltrdef[1];
            continue ;
            case 1 : 
            var varnm = mdltrdef[0];
            var valueini = interpret(ein, mdltrdef[1]);
            var loc = [valueini];
            Hashtbl.add(ein, varnm, [/* Location */Block.__(22, [loc])]);
            var varnm$1 = make_variable_name(mdlnm, varnm);
            Hashtbl.add(eout, varnm$1, [/* Location */Block.__(22, [loc])]);
            _mdltrdef = mdltrdef[2];
            continue ;
            case 2 : 
            add_mutuals_to_environment(/* false */0, eout, ein, mdlnm, mdltrdef[0]);
            _mdltrdef = mdltrdef[1];
            continue ;
            case 3 : 
            var valueini$1 = interpret(ein, mdltrdef[1]);
            var loc$1 = [valueini$1];
            Hashtbl.add(ein, mdltrdef[0], [/* Location */Block.__(22, [loc$1])]);
            _mdltrdef = mdltrdef[2];
            continue ;
            case 4 : 
            add_mutuals_to_environment(/* true */1, eout, ein, "", mdltrdef[0]);
            _mdltrdef = mdltrdef[1];
            continue ;
            
      }
    }
  };
}

function check_pattern_matching(env, _pat, _astobj) {
  while(true) {
    var astobj = _astobj;
    var pat = _pat;
    if (typeof pat === "number") {
      switch (pat) {
        case 0 : 
            if (typeof astobj === "number" && astobj === 1) {
              return /* true */1;
            }
            else {
              return /* false */0;
            }
        case 1 : 
            if (typeof astobj === "number" && astobj === 4) {
              return /* true */1;
            }
            else {
              return /* false */0;
            }
        case 2 : 
            if (typeof astobj === "number" && astobj === 5) {
              return /* true */1;
            }
            else {
              return /* false */0;
            }
        case 3 : 
            return /* true */1;
        
      }
    }
    else {
      switch (pat.tag | 0) {
        case 0 : 
            if (typeof astobj === "number" || astobj.tag) {
              return /* false */0;
            }
            else {
              return +(pat[0] === astobj[0]);
            }
            break;
        case 1 : 
            if (typeof astobj === "number" || astobj.tag !== 1) {
              return /* false */0;
            }
            else {
              return Caml_obj.caml_equal(pat[0], astobj[0]);
            }
            break;
        case 2 : 
            var out1;
            try {
              out1 = Out.main(pat[0]);
            }
            catch (exn){
              if (exn[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "Illegal argument for pattern matching of string: " + exn[1]
                    ];
              }
              else {
                throw exn;
              }
            }
            var out2;
            try {
              out2 = Out.main(astobj);
            }
            catch (exn$1){
              if (exn$1[0] === Out.IllegalOut) {
                throw [
                      EvalError,
                      "Illegal argument for pattern matching of string: " + exn$1[1]
                    ];
              }
              else {
                throw exn$1;
              }
            }
            return +(out1 === out2);
        case 3 : 
            if (typeof astobj === "number") {
              return /* false */0;
            }
            else if (astobj.tag === 7) {
              if (check_pattern_matching(env, pat[0], astobj[0])) {
                _astobj = astobj[1];
                _pat = pat[1];
                continue ;
                
              }
              else {
                return /* false */0;
              }
            }
            else {
              return /* false */0;
            }
            break;
        case 4 : 
            if (typeof astobj === "number") {
              return /* false */0;
            }
            else if (astobj.tag === 8) {
              if (check_pattern_matching(env, pat[0], astobj[0])) {
                _astobj = astobj[1];
                _pat = pat[1];
                continue ;
                
              }
              else {
                return /* false */0;
              }
            }
            else {
              return /* false */0;
            }
            break;
        case 5 : 
            Hashtbl.add(env, pat[0], [astobj]);
            return /* true */1;
        case 6 : 
            Hashtbl.add(env, pat[0], [astobj]);
            _pat = pat[1];
            continue ;
            case 7 : 
            if (typeof astobj === "number") {
              return /* false */0;
            }
            else if (astobj.tag === 17) {
              if (pat[0] === astobj[0]) {
                _astobj = astobj[1];
                _pat = pat[1];
                continue ;
                
              }
              else {
                return /* false */0;
              }
            }
            else {
              return /* false */0;
            }
            break;
        
      }
    }
  };
}

function add_mutuals_to_environment(is_public, eout, ein, mdlnm, mutletcons) {
  var lst = add_mutuals_to_environment_sub(is_public, /* [] */0, mdlnm, eout, ein, mutletcons);
  var is_public$1 = is_public;
  var _lst = lst;
  var mdlnm$1 = mdlnm;
  var eout$1 = eout;
  var ein$1 = ein;
  while(true) {
    var lst$1 = _lst;
    var newlst = add_zeroary_mutuals_sub(is_public$1, lst$1, mdlnm$1, eout$1, ein$1, /* [] */0);
    if (List.length(newlst)) {
      if (List.length(newlst) === List.length(lst$1)) {
        throw [
              EvalError,
              "meaningless 0-ary mutual recursion"
            ];
      }
      else {
        _lst = newlst;
        continue ;
        
      }
    }
    else {
      return /* () */0;
    }
  };
}

function add_mutuals_to_environment_sub(is_public, _lst, mdlnm, eout, ein, _mutletcons) {
  while(true) {
    var mutletcons = _mutletcons;
    var lst = _lst;
    if (mutletcons) {
      var tailcons = mutletcons[2];
      var astcont = mutletcons[1];
      var varnm = mutletcons[0];
      try {
        var valuecont = interpret(ein, astcont);
        var varnm$1 = make_variable_name("", varnm);
        Hashtbl.add(ein, varnm$1, [valuecont]);
        if (is_public) {
          var varnm$2 = make_variable_name(mdlnm, varnm);
          Hashtbl.add(eout, varnm$2, [valuecont]);
        }
        _mutletcons = tailcons;
        continue ;
        
      }
      catch (exn){
        if (exn[0] === EvalError) {
          _mutletcons = tailcons;
          _lst = /* :: */[
            /* tuple */[
              varnm,
              astcont
            ],
            lst
          ];
          continue ;
          
        }
        else {
          throw exn;
        }
      }
    }
    else {
      return lst;
    }
  };
}

function add_zeroary_mutuals_sub(is_public, _lst, mdlnm, eout, ein, _acc) {
  while(true) {
    var acc = _acc;
    var lst = _lst;
    if (lst) {
      var tail = lst[1];
      var match = lst[0];
      var astcont = match[1];
      var varnm = match[0];
      try {
        var valuecont = interpret(ein, astcont);
        var varnm$1 = make_variable_name("", varnm);
        Hashtbl.add(ein, varnm$1, [valuecont]);
        if (is_public) {
          var varnm$2 = make_variable_name(mdlnm, varnm);
          Hashtbl.add(eout, varnm$2, [valuecont]);
        }
        _lst = tail;
        continue ;
        
      }
      catch (exn){
        if (exn[0] === EvalError) {
          _acc = /* :: */[
            /* tuple */[
              varnm,
              astcont
            ],
            acc
          ];
          _lst = tail;
          continue ;
          
        }
        else {
          throw exn;
        }
      }
    }
    else {
      return acc;
    }
  };
}

exports.EvalError = EvalError;
exports.interpret = interpret;
/* Out Not a pure module */
