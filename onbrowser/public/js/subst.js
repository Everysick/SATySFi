// Generated by BUCKLESCRIPT VERSION 1.0.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions");
var Range                   = require("./range");
var Variantenv              = require("./variantenv");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions");
var Block                   = require("bs-platform/lib/js/block");
var Typeenv                 = require("./typeenv");
var Display                 = require("./display");
var Tyvarid                 = require("./tyvarid");
var Assoc                   = require("./assoc");
var Kindenv                 = require("./kindenv");
var List                    = require("bs-platform/lib/js/list");
var Types                   = require("./types");

var InternalInclusionError = Caml_exceptions.create("Subst.InternalInclusionError");

var InternalContradictionError = Caml_exceptions.create("Subst.InternalContradictionError");

var InclusionError = Caml_exceptions.create("Subst.InclusionError");

var ContradictionError = Caml_exceptions.create("Subst.ContradictionError");

function add(theta, key, value) {
  var key$1 = key;
  var value$1 = value;
  var _theta = theta;
  var _accrev = /* [] */0;
  while(true) {
    var accrev = _accrev;
    var theta$1 = _theta;
    if (theta$1) {
      var tail = theta$1[1];
      var match = theta$1[0];
      var k = match[0];
      if (Tyvarid.same(k, key$1)) {
        return List.rev_append(accrev, /* :: */[
                    /* tuple */[
                      key$1,
                      value$1
                    ],
                    tail
                  ]);
      }
      else {
        _accrev = /* :: */[
          /* tuple */[
            k,
            match[1]
          ],
          accrev
        ];
        _theta = tail;
        continue ;
        
      }
    }
    else {
      return List.rev(/* :: */[
                  /* tuple */[
                    key$1,
                    value$1
                  ],
                  accrev
                ]);
    }
  };
}

function find(theta, key) {
  return List.find(function (param) {
                return Tyvarid.same(param[0], key);
              }, theta)[1];
}

function mem(key, theta) {
  try {
    find(theta, key);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    }
    else {
      throw exn;
    }
  }
}

function apply_to_type_struct(theta, tystr) {
  var iter = function (param) {
    return apply_to_type_struct(theta, param);
  };
  var tymain = tystr[1];
  var rng = tystr[0];
  if (typeof tymain === "number") {
    return /* tuple */[
            rng,
            tymain
          ];
  }
  else {
    switch (tymain.tag | 0) {
      case 0 : 
          return /* tuple */[
                  rng,
                  /* FuncType */Block.__(0, [
                      apply_to_type_struct(theta, tymain[0]),
                      apply_to_type_struct(theta, tymain[1])
                    ])
                ];
      case 1 : 
          return /* tuple */[
                  rng,
                  /* ListType */Block.__(1, [apply_to_type_struct(theta, tymain[0])])
                ];
      case 2 : 
          return /* tuple */[
                  rng,
                  /* RefType */Block.__(2, [apply_to_type_struct(theta, tymain[0])])
                ];
      case 3 : 
          return /* tuple */[
                  rng,
                  /* ProductType */Block.__(3, [List.map(iter, tymain[0])])
                ];
      case 4 : 
          var tv = tymain[0];
          try {
            return find(theta, tv);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* tuple */[
                      rng,
                      /* TypeVariable */Block.__(4, [tv])
                    ];
            }
            else {
              throw exn;
            }
          }
          break;
      case 5 : 
          return /* tuple */[
                  rng,
                  /* TypeSynonym */Block.__(5, [
                      List.map(iter, tymain[0]),
                      tymain[1],
                      apply_to_type_struct(theta, tymain[2])
                    ])
                ];
      case 6 : 
          return /* tuple */[
                  rng,
                  /* VariantType */Block.__(6, [
                      List.map(iter, tymain[0]),
                      tymain[1]
                    ])
                ];
      case 9 : 
          return /* tuple */[
                  rng,
                  /* RecordType */Block.__(9, [Assoc.map_value(iter, tymain[0])])
                ];
      default:
        return /* tuple */[
                rng,
                tymain
              ];
    }
  }
}

function apply_to_type_environment(theta, tyenv) {
  return Typeenv.map(function (param) {
              return /* tuple */[
                      param[0],
                      apply_to_type_struct(theta, param[1])
                    ];
            }, tyenv);
}

function emerge_in(tvid, _tystr) {
  while(true) {
    var tystr = _tystr;
    var dr = Range.dummy("emerge_in");
    var tymain = tystr[1];
    if (typeof tymain === "number") {
      return /* tuple */[
              /* false */0,
              dr
            ];
    }
    else {
      switch (tymain.tag | 0) {
        case 0 : 
            var match = emerge_in(tvid, tymain[0]);
            var bdom = match[0];
            var match$1 = emerge_in(tvid, tymain[1]);
            var bcod = match$1[0];
            if (bdom) {
              return /* tuple */[
                      bdom,
                      match[1]
                    ];
            }
            else if (bcod) {
              return /* tuple */[
                      bcod,
                      match$1[1]
                    ];
            }
            else {
              return /* tuple */[
                      /* false */0,
                      dr
                    ];
            }
        case 1 : 
        case 2 : 
            _tystr = tymain[0];
            continue ;
            case 4 : 
            return /* tuple */[
                    Tyvarid.same(tymain[0], tvid),
                    tystr[0]
                  ];
        case 5 : 
            var match$2 = emerge_in(tvid, tymain[2]);
            var bcont = match$2[0];
            var match$3 = emerge_in_list(tvid, tymain[0]);
            var blst = match$3[0];
            if (bcont) {
              return /* tuple */[
                      bcont,
                      match$2[1]
                    ];
            }
            else if (blst) {
              return /* tuple */[
                      blst,
                      match$3[1]
                    ];
            }
            else {
              return /* tuple */[
                      /* false */0,
                      dr
                    ];
            }
        case 3 : 
        case 6 : 
            return emerge_in_list(tvid, tymain[0]);
        case 7 : 
        case 8 : 
            return /* tuple */[
                    /* false */0,
                    dr
                  ];
        case 9 : 
            return emerge_in_list(tvid, Assoc.to_value_list(tymain[0]));
        default:
          return /* tuple */[
                  /* false */0,
                  dr
                ];
      }
    }
  };
}

function emerge_in_list(tvid, tylist) {
  var dr = Range.dummy("emerge_in_list");
  if (tylist) {
    var match = emerge_in(tvid, tylist[0]);
    var bhd = match[0];
    var match$1 = emerge_in_list(tvid, tylist[1]);
    var btl = match$1[0];
    if (bhd) {
      return /* tuple */[
              bhd,
              match[1]
            ];
    }
    else if (btl) {
      return /* tuple */[
              btl,
              match$1[1]
            ];
    }
    else {
      return /* tuple */[
              /* false */0,
              dr
            ];
    }
  }
  else {
    return /* tuple */[
            /* false */0,
            dr
          ];
  }
}

function replace_type_variable_in_subst(theta, key, value) {
  return List.map(function (param) {
              return /* tuple */[
                      param[0],
                      Types.replace_type_variable(param[1], key, value)
                    ];
            }, theta);
}

function replace_type_variable_in_equations(eqnlst, key, value) {
  return List.map(function (param) {
              return /* tuple */[
                      Types.replace_type_variable(param[0], key, value),
                      Types.replace_type_variable(param[1], key, value)
                    ];
            }, eqnlst);
}

function report_inclusion_error(kdenv, tystr1, tystr2) {
  var rng1 = tystr1[0];
  var rng2 = tystr2[0];
  var match = Display.string_of_type_struct_double(kdenv, tystr1, tystr2);
  var match$1 = Range.is_dummy(rng1);
  var match$2 = Range.is_dummy(rng2);
  var msg;
  var exit = 0;
  if (match$1 !== 0 && match$2 !== 0) {
    msg = "(cannot report position: '" + (Range.message(rng1) + ("', '" + (Range.message(rng2) + "')")));
  }
  else {
    exit = 1;
  }
  if (exit === 1) {
    msg = match$2 !== 0 ? "at " + Range.to_string(rng1) : "at " + Range.to_string(rng2);
  }
  throw [
        InclusionError,
        msg + (":\n    this expression has types\n      " + (match[0] + ("\n    and\n      " + (match[1] + "\n    at the same time,\n    but these are incompatible with each other"))))
      ];
}

function compose(theta2, theta1) {
  var res1 = List.map(function (param) {
        return /* tuple */[
                param[0],
                apply_to_type_struct(theta2, param[1])
              ];
      }, theta1);
  var res2 = List.filter(function (param) {
          return !mem(param[0], theta1);
        })(theta2);
  return List.append(res1, res2);
}

function compose_list(thetalst) {
  return List.fold_right(compose, thetalst, /* [] */0);
}

function unify_sub(_kdenv, _eqnlst, _acctheta, _acckdenv) {
  while(true) {
    var acckdenv = _acckdenv;
    var acctheta = _acctheta;
    var eqnlst = _eqnlst;
    var kdenv = _kdenv;
    List.iter(function (param) {
          " [" + (Display.string_of_type_struct_basic(param[0]) + (" = " + (Display.string_of_type_struct_basic(param[1]) + "]")));
          return /* () */0;
        }, eqnlst);
    "        (kinds(K) " + (Display.string_of_kind_environment(kdenv) + ")\n");
    "        (kinds(S) " + (Display.string_of_kind_environment(acckdenv) + ")\n");
    if (eqnlst) {
      var eqntail = eqnlst[1];
      var match = eqnlst[0];
      var tystr2 = match[1];
      var tystr1 = match[0];
      var iter_none = (function(kdenv,acctheta,acckdenv,eqntail){
      return function () {
        return unify_sub(kdenv, eqntail, acctheta, acckdenv);
      }
      }(kdenv,acctheta,acckdenv,eqntail));
      var iter_add = (function(kdenv,acctheta,acckdenv,eqntail){
      return function (addedeqns) {
        return unify_sub(kdenv, List.append(addedeqns, eqntail), acctheta, acckdenv);
      }
      }(kdenv,acctheta,acckdenv,eqntail));
      var tymain1 = tystr1[1];
      var rng1 = tystr1[0];
      var tymain2 = tystr2[1];
      var rng2 = tystr2[0];
      var exit = 0;
      var exit$1 = 0;
      var exit$2 = 0;
      if (typeof tymain1 === "number") {
        switch (tymain1) {
          case 0 : 
              if (typeof tymain2 === "number") {
                if (tymain2) {
                  throw InternalContradictionError;
                }
                else {
                  return iter_none(/* () */0);
                }
              }
              else {
                switch (tymain2.tag | 0) {
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 1 : 
              if (typeof tymain2 === "number") {
                if (tymain2 === 1) {
                  return iter_none(/* () */0);
                }
                else {
                  throw InternalContradictionError;
                }
              }
              else {
                switch (tymain2.tag | 0) {
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 2 : 
              if (typeof tymain2 === "number") {
                if (tymain2 === 2) {
                  return iter_none(/* () */0);
                }
                else {
                  throw InternalContradictionError;
                }
              }
              else {
                switch (tymain2.tag | 0) {
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 3 : 
              if (typeof tymain2 === "number") {
                if (tymain2 === 3) {
                  return iter_none(/* () */0);
                }
                else {
                  throw InternalContradictionError;
                }
              }
              else {
                switch (tymain2.tag | 0) {
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          
        }
      }
      else {
        switch (tymain1.tag | 0) {
          case 0 : 
              if (typeof tymain2 === "number") {
                throw InternalContradictionError;
              }
              else {
                switch (tymain2.tag | 0) {
                  case 0 : 
                      return iter_add(/* :: */[
                                  /* tuple */[
                                    tymain1[0],
                                    tymain2[0]
                                  ],
                                  /* :: */[
                                    /* tuple */[
                                      tymain1[1],
                                      tymain2[1]
                                    ],
                                    /* [] */0
                                  ]
                                ]);
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 1 : 
              if (typeof tymain2 === "number") {
                throw InternalContradictionError;
              }
              else {
                switch (tymain2.tag | 0) {
                  case 1 : 
                      return iter_add(/* :: */[
                                  /* tuple */[
                                    tymain1[0],
                                    tymain2[0]
                                  ],
                                  /* [] */0
                                ]);
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 2 : 
              if (typeof tymain2 === "number") {
                throw InternalContradictionError;
              }
              else {
                switch (tymain2.tag | 0) {
                  case 2 : 
                      return iter_add(/* :: */[
                                  /* tuple */[
                                    tymain1[0],
                                    tymain2[0]
                                  ],
                                  /* [] */0
                                ]);
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 3 : 
              var tylist1 = tymain1[0];
              if (typeof tymain2 === "number") {
                throw InternalContradictionError;
              }
              else {
                switch (tymain2.tag | 0) {
                  case 3 : 
                      var tylist2 = tymain2[0];
                      if (List.length(tylist1) !== List.length(tylist2)) {
                        throw InternalContradictionError;
                      }
                      else {
                        return iter_add(List.combine(tylist1, tylist2));
                      }
                      break;
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 4 : 
              var tvid1 = tymain1[0];
              if (typeof tymain2 === "number") {
                exit$1 = 2;
              }
              else {
                switch (tymain2.tag | 0) {
                  case 4 : 
                      var tvid2 = tymain2[0];
                      if (Tyvarid.same(tvid1, tvid2)) {
                        return iter_none(/* () */0);
                      }
                      else {
                        Tyvarid.make_unquantifiable_if_needed(/* tuple */[
                              tvid1,
                              tvid2
                            ]);
                        var match$1 = Range.is_dummy(rng1) ? /* tuple */[
                            tvid1,
                            tvid2,
                            tystr2
                          ] : /* tuple */[
                            tvid2,
                            tvid1,
                            tystr1
                          ];
                        var newtystr = match$1[2];
                        var oldtvid = match$1[0];
                        "    substituteVV " + (Display.string_of_type_struct_basic(/* tuple */[
                                Range.dummy(""),
                                /* TypeVariable */Block.__(4, [oldtvid])
                              ]) + (" with " + (Display.string_of_type_struct_basic(newtystr) + "\n")));
                        var kdstr1 = Kindenv.find(kdenv, tvid1);
                        var kdstr2 = Kindenv.find(kdenv, tvid2);
                        var match$2;
                        if (kdstr1) {
                          var asc1 = kdstr1[0];
                          if (kdstr2) {
                            var asc2 = kdstr2[0];
                            var pureunion = /* RecordKind */[Assoc.union(/* None */0, asc1, asc2)];
                            match$2 = /* tuple */[
                              Assoc.intersection(/* None */0, asc1, asc2),
                              Kindenv.replace_type_variable_in_kind_struct(pureunion, oldtvid, newtystr)
                            ];
                          }
                          else {
                            match$2 = /* tuple */[
                              /* [] */0,
                              /* RecordKind */[asc1]
                            ];
                          }
                        }
                        else {
                          match$2 = kdstr2 ? /* tuple */[
                              /* [] */0,
                              /* RecordKind */[kdstr2[0]]
                            ] : /* tuple */[
                              /* [] */0,
                              /* UniversalKind */0
                            ];
                        }
                        var neweqnlst = replace_type_variable_in_equations(List.append(match$2[0], eqntail), oldtvid, newtystr);
                        var newkdenv = Kindenv.add(Kindenv.replace_type_variable_in_kindenv(kdenv, oldtvid, newtystr), match$1[1], match$2[1]);
                        var newacctheta = add(replace_type_variable_in_subst(acctheta, oldtvid, newtystr), oldtvid, newtystr);
                        var newacckdenv = Kindenv.add(Kindenv.replace_type_variable_in_kindenv(kdenv, oldtvid, newtystr), oldtvid, kdstr1);
                        _acckdenv = newacckdenv;
                        _acctheta = newacctheta;
                        _eqnlst = neweqnlst;
                        _kdenv = newkdenv;
                        continue ;
                        
                      }
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  case 9 : 
                      var asc2$1 = tymain2[0];
                      var kdstr1$1 = Kindenv.find(kdenv, tvid1);
                      var binc = kdstr1$1 ? Assoc.domain_included(/* None */0, kdstr1$1[0], asc2$1) : /* true */1;
                      var match$3 = emerge_in(tvid1, tystr2);
                      if (match$3[0]) {
                        return report_inclusion_error(kdenv, tystr1, tystr2);
                      }
                      else if (binc) {
                        var newtystr2 = Range.is_dummy(rng1) ? /* tuple */[
                            rng2,
                            tymain2
                          ] : /* tuple */[
                            rng1,
                            tymain2
                          ];
                        "    substituteVR " + (Display.string_of_type_struct_basic(tystr1) + (" with " + (Display.string_of_type_struct_basic(newtystr2) + "\n")));
                        var eqnlstbyrecord = kdstr1$1 ? Assoc.intersection(/* None */0, kdstr1$1[0], asc2$1) : /* [] */0;
                        var neweqnlst$1 = replace_type_variable_in_equations(List.append(eqnlstbyrecord, eqntail), tvid1, newtystr2);
                        var newkdenv$1 = Kindenv.replace_type_variable_in_kindenv(kdenv, tvid1, newtystr2);
                        var newacctheta$1 = add(replace_type_variable_in_subst(acctheta, tvid1, newtystr2), tvid1, newtystr2);
                        var newacckdenv$1 = Kindenv.add(Kindenv.replace_type_variable_in_kindenv(acckdenv, tvid1, newtystr2), tvid1, kdstr1$1);
                        _acckdenv = newacckdenv$1;
                        _acctheta = newacctheta$1;
                        _eqnlst = neweqnlst$1;
                        _kdenv = newkdenv$1;
                        continue ;
                        
                      }
                      else {
                        throw InternalContradictionError;
                      }
                      break;
                  default:
                    exit$1 = 2;
                }
              }
              break;
          case 5 : 
              return iter_add(/* :: */[
                          /* tuple */[
                            Variantenv.apply_to_type_synonym(tymain1[0], tymain1[2]),
                            tystr2
                          ],
                          /* [] */0
                        ]);
          case 6 : 
              if (typeof tymain2 === "number") {
                throw InternalContradictionError;
              }
              else {
                switch (tymain2.tag | 0) {
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  case 6 : 
                      if (tymain1[1] === tymain2[1]) {
                        return iter_add(List.combine(tymain1[0], tymain2[0]));
                      }
                      else {
                        throw InternalContradictionError;
                      }
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          case 7 : 
          case 8 : 
              exit$2 = 3;
              break;
          case 9 : 
              var asc1$1 = tymain1[0];
              if (typeof tymain2 === "number") {
                throw InternalContradictionError;
              }
              else {
                switch (tymain2.tag | 0) {
                  case 4 : 
                      exit = 1;
                      break;
                  case 5 : 
                      exit$2 = 3;
                      break;
                  case 9 : 
                      var asc2$2 = tymain2[0];
                      if (Assoc.domain_same(/* None */0, asc1$1, asc2$2)) {
                        return iter_add(Assoc.combine_value(/* None */0, asc1$1, asc2$2));
                      }
                      else {
                        throw InternalContradictionError;
                      }
                      break;
                  default:
                    throw InternalContradictionError;
                }
              }
              break;
          
        }
      }
      if (exit$2 === 3) {
        if (typeof tymain2 === "number") {
          exit$1 = 2;
        }
        else if (tymain2.tag === 5) {
          return iter_add(/* :: */[
                      /* tuple */[
                        tystr1,
                        Variantenv.apply_to_type_synonym(tymain2[0], tymain2[2])
                      ],
                      /* [] */0
                    ]);
        }
        else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (typeof tymain1 !== "number") {
          switch (tymain1.tag | 0) {
            case 4 : 
                var tvid1$1 = tymain1[0];
                var match$4 = emerge_in(tvid1$1, tystr2);
                if (match$4[0]) {
                  return report_inclusion_error(kdenv, tystr1, tystr2);
                }
                else {
                  var newtystr2$1 = Range.is_dummy(rng1) ? /* tuple */[
                      rng2,
                      tymain2
                    ] : /* tuple */[
                      rng1,
                      tymain2
                    ];
                  "    substituteVX " + (Display.string_of_type_struct_basic(tystr1) + (" with " + (Display.string_of_type_struct_basic(newtystr2$1) + "\n")));
                  var newkdenv$2 = Kindenv.replace_type_variable_in_kindenv(kdenv, tvid1$1, newtystr2$1);
                  "    kinds(old) " + (Display.string_of_kind_environment(kdenv) + "\n");
                  "    kinds(new) " + (Display.string_of_kind_environment(newkdenv$2) + "\n");
                  var neweqnlst$2 = replace_type_variable_in_equations(eqntail, tvid1$1, newtystr2$1);
                  var newacctheta$2 = add(replace_type_variable_in_subst(acctheta, tvid1$1, newtystr2$1), tvid1$1, newtystr2$1);
                  var newacckdenv$2 = Kindenv.add(Kindenv.replace_type_variable_in_kindenv(acckdenv, tvid1$1, newtystr2$1), tvid1$1, /* UniversalKind */0);
                  _acckdenv = newacckdenv$2;
                  _acctheta = newacctheta$2;
                  _eqnlst = neweqnlst$2;
                  _kdenv = newkdenv$2;
                  continue ;
                  
                }
                break;
            case 7 : 
            case 8 : 
                exit = 1;
                break;
            
          }
        }
        
      }
      if (exit === 1) {
        if (typeof tymain2 === "number") {
          throw InternalContradictionError;
        }
        else if (tymain2.tag === 4) {
          return iter_add(/* :: */[
                      /* tuple */[
                        tystr2,
                        tystr1
                      ],
                      /* [] */0
                    ]);
        }
        else {
          throw InternalContradictionError;
        }
      }
      
    }
    else {
      return /* tuple */[
              acctheta,
              kdenv
            ];
    }
  };
}

function unify(kdenv, tystr1, tystr2) {
  try {
    return unify_sub(kdenv, /* :: */[
                /* tuple */[
                  tystr1,
                  tystr2
                ],
                /* [] */0
              ], /* [] */0, Kindenv.empty);
  }
  catch (exn){
    if (exn === InternalInclusionError) {
      return report_inclusion_error(kdenv, tystr1, tystr2);
    }
    else if (exn === InternalContradictionError) {
      var kdenv$1 = kdenv;
      var tystr1$1 = tystr1;
      var tystr2$1 = tystr2;
      var rng1 = tystr1$1[0];
      var rng2 = tystr2$1[0];
      var strty1 = Display.string_of_type_struct(kdenv$1, tystr1$1);
      var strty2 = Display.string_of_type_struct(kdenv$1, tystr2$1);
      var strrng1 = Range.to_string(rng1);
      var strrng2 = Range.to_string(rng2);
      var match = Range.is_dummy(rng1);
      var match$1 = Range.is_dummy(rng2);
      var msg = match !== 0 ? (
          match$1 !== 0 ? "(cannot report position; '" + (Range.message(rng1) + ("', '" + (Range.message(rng2) + "')"))) : "at " + (strrng2 + (":\n    this expression has type\n      " + (strty2 + ("\n    but is expected of type\n      " + strty1))))
        ) : (
          match$1 !== 0 ? "at " + (strrng1 + (":\n    this expression has type\n      " + (strty1 + ("\n    but is expected of type\n      " + strty2)))) : "at " + (strrng1 + (":\n    this expression has type\n      " + (strty1 + ("\n    but is expected of type\n      " + (strty2 + (";\n    this constraint is required by the expression\n    at " + strrng2))))))
        );
      throw [
            ContradictionError,
            msg
          ];
    }
    else {
      throw exn;
    }
  }
}

function string_of_subst(theta) {
  var iter = function (theta) {
    if (theta) {
      var match = theta[0];
      return " | '" + (Tyvarid.show_direct(match[0]) + (" := " + (Display.string_of_type_struct_basic(match[1]) + ("\n" + iter(theta[1])))));
    }
    else {
      return "";
    }
  };
  return " +-------------------------------\n" + (iter(theta) + " +-------------------------------\n");
}

var empty = /* [] */0;

exports.ContradictionError        = ContradictionError;
exports.InclusionError            = InclusionError;
exports.empty                     = empty;
exports.add                       = add;
exports.find                      = find;
exports.apply_to_type_struct      = apply_to_type_struct;
exports.apply_to_type_environment = apply_to_type_environment;
exports.compose                   = compose;
exports.compose_list              = compose_list;
exports.unify                     = unify;
exports.string_of_subst           = string_of_subst;
/* Variantenv Not a pure module */
