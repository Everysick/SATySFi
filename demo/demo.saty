@require: stdjabook
@require: code
@require: itemize
@import: local

document (|
  title = {\SATySFi;入門};
  author = {Takashi SUWA};
  show-title = true;
  show-toc = true;
|) '<
  +section{はじめに}<
    +p{
      \dfn{\SATySFi;}は，2017年度IPA未踏事業のひとつとして開発された，新しい組版処理システムである。
      一口に組版処理システムといっても，大きく分けて
    }
    +listing{
      * GUIの画面上に版面がプレヴューされた状態で文書を視覚的に記述していく\dfn{WYISIWYGエディタ}方式
      * \dfn{マークアップ言語}によってテキストファイルとして文書を記述し，
        言語処理系に入力として与えて最終的にPDFなどの形式で版面を出力する方式
    }
    +pn{
      の2つがあるが，\SATySFi;は後者にあたる。すなわち，\LaTeX;やtroffなどと同様の形式をとるソフトウェアだ。
      では\LaTeX;をはじめとする既存のマークアップ言語方式と\SATySFi;との違いは何なのだろうか？
      簡潔に言ってしまえば，最大の違いは
    }
    +listing{
      * コマンド定義を記述したコードの\emph{可読性が高くカスタマイズしやすい}
      * ユーザが不適格な入力を与えたときの\emph{エラー報告がすばやく，わかりやすく提示される}
    }
    +pn{
      といった点にある。
      この性質の詳細を述べる前に，\SATySFi;を実装した動機をもう少し詳しく順を追って説明したい。
    }
    +p{
      “マークアップ言語方式とWYSIWYG方式とのいずれが優れているのか” といった話題は
      （少なくとも一方に触れる人が多いためか）頻繁に目にし，もはや大喜利の様相を呈しているが，
      実際にはそれぞれの方式に利点と弱点のトレードオフがあるといってよい。
      WYSIWYG方式に比べたマークアップ言語方式一般の利点としては，あくまでも傾向ではあるが
    }
    +listing{
     * 入力がテキストファイルなので差分管理が簡単
     * ユーザ定義コマンドにより：
       ** 複雑な自動処理が実現できる
       ** 文書の内容を変更せずに後から体裁を柔軟に変更しやすい
    }
    +pn{
      といったことが挙げられるだろう。一方で明白な弱点としては，
    }
    +listing{
      * 任意のテキストが入力として渡せるため，ユーザが意図しないコードを入力として与えやすい
    }
    +pn{
      というものがある。ユーザが意図していない入力のうち処理系にとっては適格なコードは
      間違いを検出することが（少なくとも非統計的な手法では）原理的にできないし，
      これはユーザ自身が出力された版面を見て確かめるしかないが，
      処理系にとっても不適格なコード，すなわちコマンドの引数の与え方がおかしいといったミスは，
      処理系が見つけて報告することができる。
      つまり，ユーザが意図しないコードを与えてしまいやすいという弱点が本質的にあるマークアップ言語という方式では，
      処理系にとって不適格なコードが入力として渡された場合にどのようなエラー報告を行なうかが
      ユーザの執筆効率に多大な影響をもたらすと考えてよいだろう。
    }
    +p{
      ところが，既存のマークアップ言語方式の組版処理システムでは，
      この不適格な入力に対するエラー報告がわかりにくいという傾向がある。
      特に\LaTeX;の場合を例に挙げると，以下のようなエラーログを数え切れないほど見たユーザは多いだろう：
    }
    +console(`! Undefined control sequence.`);
    +console(`! Missing $ inserted.`);
    +console(`! Missing number, treated as zero.`);
    +pn{
      場合によっては原因がすぐわかることもあるが，
      基本的には「組版処理中に初めて不整合が生じた」ときにエラーが報告される仕組みなので，
      ユーザの与り知らない，コマンドの実装内の記述と与えた引数の不整合によるエラーが直接報告されることも多い。
      「第${n}行目までで何かがおかしい」という程度の情報しか得られないことも多く，
      こうなるともはやコードをコメントアウトしながら二分探索して原因の場所を特定するしかない。
    }
    +p{
      ようやく本題に戻るが，\SATySFi;はこれらの問題点を解決するひとつの答えである。
      具体的にはいわゆる函数型プログラミングに便利な言語をベースに設計されているため
    }
    +listing{
      * \emph{強力な型がつく}
      * グローバルな状態を意識せず\emph{局所的な処理にだけ気を遣えばよい}
    }
    +pn{
      といった函数型の知見の恩恵を享受でき，型検査という形でエラー報告が強化されているのである。
    }
    +p{
      ともあれ，ひとまずエラー報告能力に関しては一旦置いておき，
      次の第\ref(`sec:typesetting`);章では
      組版処理システムとしてどのような機能が実現されているかについて触れていく。
    }
  >
  +section ?:(`sec:typesetting`) {代表的な機能}<
    +subsection{和文組版}<
      +p{
        和文は慣習的に正方形を基調として文字を並べる組版が好まれ，
        基本的には単語の途中で改行しても構わないなど，欧文組版と比べるとやや緩やかな組版規則に見える。
        この文書も多くの箇所は日本語で書かれているし，読める方にとっては和文組版は馴染み深いものであろう。
        ただし，括弧類や句読点類の前後にスペース（アキ）をどの程度の大きさで入れるかといった視覚的調整は
        それほど自明ではない。また，いかに改行位置に関して寛容であると言っても例えば「チョコレート」を
        「チ」と「ョコレート」に分けるとか「チョコレ」と「ート」に分けるといった組み方は
        強く違和感を喚起してしまうから，行末禁則文字や行頭禁則文字といった取り決めが要請される。
        こうした規則をまとめたものとして『\dfn{日本語組版処理の要件}』（W3C日本語組版タスクフォース，2012）
        という文書が策定されており，通称として\dfn{JLreq}と呼ばれる。
      }
    >
    +subsection{欧文組版}<
      +p{
        和文
      }
    >
    +subsection{数式}<
      +p{
        既存の組版処理システムである\LaTeX;が圧倒的な高品質での出力を得意とする機能のひとつに数式組版がある。
        \SATySFi;でも，十分にこれに肩を並べられるといってよい程度の数式組版が実現されている。
        ある程度複雑な数式も，比較的簡素に記述することができる：
      }
      +math(
        let int1 = ${\int_0^a} in
        let int2 = ${\int_0^\sqrt{a^2 - x^2}} in
        let sqrt2 = ${\sqrt{x^2 + r^2}} in
          ${
            \frac{
              #int1 x \ordd x #int2 r #sqrt2 \ordd r
            }{
              #int1 \ordd x #int2 r #sqrt2 \ordd r
            }
              = \frac{2a}{5}
          }
      );
      +code(```
        +math(
          let int1 = ${\int_0^a} in
          let int2 = ${\int_0^\sqrt{a^2 - x^2}} in
          let sqrt2 = ${\sqrt{x^2 + r^2}} in
            ${
              \frac{
                #int1 x \ordd x #int2 r #sqrt2 \ordd r
              }{
                #int1 \ordd x #int2 r #sqrt2 \ordd r
              }
                = \frac{2a}{5}
            }
        );
      ```);
    >
  >
>