% -*- coding: utf-8 -*-

module StdJa : sig

  val document : 'a -> block-text -> document
    constraint 'a :: (| title : inline-text; author : inline-text; |)

  val font-latin-italic : font
  direct \ref : [string] inline-cmd
  direct \ref-page : [string] inline-cmd
  direct \figure : [block-text] inline-cmd
  direct +make-title : [] block-cmd
  direct +p : [inline-text] block-cmd
  direct +section : [inline-text; block-text] block-cmd
  direct +section-ref : [string; inline-text; block-text] block-cmd
  direct \emph : [inline-text] inline-cmd

end = struct

  let-inline ctx \ref key =
    let opt = get-cross-reference (key ^ `:num`) in
    let it =
      match opt with
      | None    -> {?}
      | Some(s) -> embed-string s
    in
      read-inline ctx it


  let-inline ctx \ref-page key =
    let opt = get-cross-reference (key ^ `:page`) in
    let it =
      match opt with
      | None    -> {?}
      | Some(s) -> embed-string s
    in
      read-inline ctx it


  let font-size-normal  = 12pt
  let font-size-title   = 32pt
  let font-size-author  = 16pt
  let font-size-section = 18pt

  let section-top-margin = 20pt
  let section-bottom-margin = 12pt

  let font-ratio-latin = 1.
  let font-ratio-cjk = 0.88

  let font-latin-roman  = font `Arno`   font-ratio-latin 0.
  let font-latin-italic = font `ArnoIt` font-ratio-latin 0.
  let font-latin-sans   = font `Hlv`    font-ratio-latin 0.
  let font-cjk-mincho   = font `ipaexm` font-ratio-cjk   0.
  let font-cjk-gothic   = font `Osaka`  font-ratio-cjk   0.

  let set-cjk-font font ctx =
    ctx |> set-font HanIdeographic font
        |> set-font Kana           font


  let get-standard-context wid =
    get-initial-context wid (command \math)
      |> set-dominant-wide-script Kana
      |> set-language Kana Japanese
      |> set-language HanIdeographic Japanese
      |> set-dominant-narrow-script Latin
      |> set-language Latin English
      |> set-font Kana           font-cjk-mincho
      |> set-font HanIdeographic font-cjk-mincho
      |> set-font Latin          font-latin-roman
      |> set-math-font `lmodern`


  let-mutable ref-title <- {}
  let-mutable ref-author <- {}


  let-mutable ref-float-boxes <- []


  let height-of-float-boxes pageno =
    let () = display-message `get height` in
    (!ref-float-boxes) |> List.fold-left (fun h (pn, bb) -> (
      if pn < pageno then h +' (get-natural-length bb) else h
    )) 0pt


  let-mutable ref-figure <- 0


  let-inline ctx \figure inner =
    let () = ref-figure <- !ref-figure + 1 in
    let s-num = embed-string (arabic (!ref-figure)) in
    let bb-inner =
      block-frame-breakable ctx (2pt, 2pt, 2pt, 2pt) (VDecoSet.simple-frame 1pt Color.red) (fun ctx -> (
        read-block ctx inner
          +++ line-break true true ctx (inline-fil ++ read-inline ctx {図#s-num;} ++ inline-fil)
      ))
    in
      hook-page-break (fun pbinfo _ -> (
        let () = display-message (`register` ^ (arabic pbinfo#page-number)) in
        ref-float-boxes <- (pbinfo#page-number, bb-inner) :: !ref-float-boxes
      ))


  let document rcd inner =
    let title = rcd#title in
    let author = rcd#author in
    let page = A4Paper in
    let txtorg = (80pt, 100pt) in
    let txtwid = 440pt in
    let txthgt = 630pt in
    let hdrorg = (40pt, 30pt) in
    let ftrorg = (40pt, 780pt) in
    let hdrwid = 520pt in
    let ftrwid = 520pt in
    let thickness = 0.5pt in

    let () = ref-title <- title in
    let () = ref-author <- author in
    let bb =
      let ctx-doc = get-standard-context txtwid
      in
        read-block ctx-doc inner
    in

    let page-text-scheme pbinfo =
      let hgtfb = height-of-float-boxes pbinfo#page-number in
      let (txtorgx, txtorgy) = txtorg in
      (|
        text-origin = (txtorgx, txtorgy +' hgtfb);
        text-height = txthgt -' hgtfb;
      |)
    in
    let page-parts pbinfo =
      let pageno = pbinfo#page-number in
      let header =
        let ctx =
          get-standard-context hdrwid
            |> set-paragraph-margin 0pt 0pt
        in
        let ib-text =
         if pageno mod 2 == 0 then
           (inline-fil ++ read-inline ctx title)
         else
           (read-inline ctx title ++ inline-fil)
       in
       let () = display-message `insert` in
       let (bb-float-boxes, acc) =
         (!ref-float-boxes) |> List.fold-left (fun (bbacc, acc) elem -> (
           let (pn, bb) = elem in
             if pn < pageno then
               let bbs =
                 line-break true true (ctx |> set-paragraph-margin 0pt 12pt)
                   (inline-fil ++ embedded-block-top ctx txtwid (fun _ -> bb) ++ inline-fil)
                     % 'ctx' is a dummy context
               in
                 (bbacc +++ bbs, acc)
             else
               (bbacc, elem :: acc)
         )) (block-nil, [])
       in
       let () = ref-float-boxes <- acc in
          line-break true true ctx ib-text
            +++ line-break true true (ctx |> set-paragraph-margin 0pt 6pt)
              ((inline-graphics hdrwid thickness 0pt
                (fun (x, y) -> [ fill Color.black (Gr.rectangle (x, y) (x +' hdrwid, y +' thickness))])) ++ inline-fil)
            +++ bb-float-boxes
      in
      let footer =
        let ctx = get-standard-context ftrwid in
        let it-pageno = embed-string (arabic pbinfo#page-number) in
          line-break true true ctx
            (inline-fil ++ (read-inline ctx {— #it-pageno; —}) ++ inline-fil)
      in
        (|
          header-origin  = hdrorg;
          header-content = header;
          footer-origin  = ftrorg;
          footer-content = footer;
        |)
    in
      page-break page page-text-scheme page-parts bb


  let title-deco =
    let pads = (5pt, 5pt, 10pt, 10pt) in
    let deco (x, y) wid hgt dpt =
      let path1 =
        let cx = 14pt in
        let cy = 8pt in
        let xL = x in
        let xR = x +' wid in
        let yT = y +' hgt in
        let yB = y -' dpt in
          start-path (xL, yT)
            |> line-to (xR, yT)
            |> bezier-to (xR +' cx, yT -' cy) (xR +' cx, yB +' cy) (xR, yB)
            |> line-to (xL, yB)
            |> close-with-bezier (xL -' cx, yB +' cy) (xL -' cx, yT -' cy)
      in
      let path2 =
        let cx = 12pt in
        let cy = 8pt in
        let gapx = 3pt in
        let gapy = 5pt in
        let xL = x +' gapx in
        let xR = x +' wid -' gapx in
        let yT = y +' hgt -' gapy in
        let yB = y -' dpt +' gapy in
          start-path (xL, yT)
            |> line-to (xR, yT)
            |> bezier-to (xR +' cx, yT -' cy) (xR +' cx, yB +' cy) (xR, yB)
            |> line-to (xL, yB)
            |> close-with-bezier (xL -' cx, yB +' cy) (xL -' cx, yT -' cy)
      in
        [
          stroke 3pt Color.black path1;
          stroke 1pt Color.black path2;
        ]
    in
      (deco, deco, deco, deco)

  let-block ctx +make-title =
    let pads = (20pt, 20pt, 10pt, 10pt) in
    block-frame-breakable ctx pads title-deco (fun ctx -> (
      let ctx-title =
        ctx |> set-font-size font-size-title
            |> set-font Latin font-latin-roman
      in
      let ctx-author =
        ctx |> set-font-size font-size-author
            |> set-font Latin font-latin-roman
      in
      let ib-title = read-inline ctx-title (!ref-title) in
      let ib-line =
        let thk = 1pt in
        let wid = get-text-width ctx in
        let path (x, y) =
          start-path (x, y +' thk *' 0.5)
            |> line-to (x +' wid, y +' thk *' 0.5)
            |> terminate-path
        in
        inline-graphics wid thk 0pt (fun pt -> (
          [ stroke thk Color.black (path pt); ]
        ))
      in
      let ib-author = read-inline ctx-author (!ref-author) in
      let bb-title = form-paragraph ctx-title (inline-fil ++ ib-title ++ inline-fil) in
      let bb-line = form-paragraph ctx (ib-line ++ inline-fil) in
      let bb-author = form-paragraph ctx-author (inline-fil ++ ib-author) in
        bb-title +++ bb-line +++ bb-author
    ))


  let-mutable needs-indentation-ref <- true

  let-mutable num-section <- 0


  let quad-indent ctx =
    inline-skip (get-font-size ctx)


  let-block ctx +p inner =
    let needs-indentation =
      if !needs-indentation-ref then true else
        let () = needs-indentation-ref <- true in
          false
    in
    let ib-inner = read-inline ctx inner in
    let br-parag =
      if needs-indentation then
        (quad-indent ctx) ++ ib-inner ++ inline-fil
      else
        ib-inner ++ inline-fil
    in
      form-paragraph ctx br-parag


  let section-scheme ctx crefopt title inner =
    let ctx-title =
      ctx |> set-font-size font-size-section
          |> set-font Latin font-latin-sans
          |> set-cjk-font font-cjk-gothic
    in
    let () = num-section <- !num-section + 1 in
    let () = needs-indentation-ref <- false in
    let s-num = arabic (!num-section) in
    let ib-num =
      match crefopt with
      | None ->
          read-inline ctx-title (embed-string (s-num ^ `.`))

      | Some(label) ->
          let () = register-cross-reference (label ^ `:num`) s-num in
            read-inline ctx-title (embed-string (s-num ^ `.`))
              ++ hook-page-break (fun pbinfo _ -> register-cross-reference (label ^ `:page`) (arabic pbinfo#page-number))
    in
    let ib-title = read-inline ctx-title title in
    let bb-title =
      line-break true false (ctx |> set-paragraph-margin section-top-margin section-bottom-margin)
        (ib-num ++ (inline-skip 10pt) ++ ib-title ++ (inline-fil))
    in
    let bb-inner = read-block ctx inner in
      bb-title +++ bb-inner


  let-block ctx +section title inner =
    section-scheme ctx None title inner


  let-block ctx +section-ref label title inner =
    section-scheme ctx (Some(label)) title inner


  let-inline ctx \emph inner =
    let ctx-emph =
      ctx |> set-font Latin font-latin-italic
          |> set-cjk-font font-cjk-gothic
          |> set-text-color (CMYK(1., 0., 0., 0.))
    in
      read-inline ctx-emph inner

end


let document = StdJa.document
  % ad-hoc
