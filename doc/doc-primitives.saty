% -*- coding: utf-8 -*-
StdJa.document (|
  title = {\SATySFi;プリミティヴ一覧};
  author = {Takashi SUWA};
|) '<
  +make-title;
  +p {
    この文書では，\SATySFi;によって提供されるプリミティヴをすべて掲げる．
  }
  +section({基本演算})(
    let t-int-arith = tI --> (tI --> tI) in
    let t-int-comp  = tI --> (tI --> tB) in
    let t-bool-op = tB --> (tB --> tB) in
  '<
    +commands [`+`; `-`; `*`] (t-int-arith) {
      整数の加算・減算・乗算．
    }
    +commands [`/`; `mod`] (t-int-arith) {
      整数の除算と剰余．現在の仕様では，第2引数に \code{0} を与えて評価した場合の結果は未定義．
      現在の実装では実行時エラーとなり処理を中止する．
      \subject-to-change;
    }
    +commands [`==`; `<>`; `<`; `>`; `<=`; `>=`] (t-int-comp) {
      整数の比較演算．
    }
    +commands [`&&`; `||`] (t-bool-op) {
      真偽値の連言・選言．
    }
    +commands [`not`] (tB --> tB) {
      論理否定．
    }
    +commands [`+.`; `-.`] (tF --> (tF --> tF)) {
      浮動小数点数の加算・減算．IEEE754に従う．
    }
    +commands [`+'`; `-'`] (tL --> (tL --> tL)) {
      長さの加算・減算．内部的にはPDFポイント単位の浮動小数点数で扱われ，IEEE754に従う．
    }
    +commands [`*'`] (tL --> (tF --> tL)) {
      長さのスカラー演算．
    }
    +commands [`/'`] (tL --> (tL --> tF)) {
      長さの割合．
    }
    +commands [`<'`; `>'`] (tL --> (tL --> tB)) {
      長さの比較．
    }
    +command (`float`) (tI --> tF) {
      整数を浮動小数点数に変換する．
    }
  >);
  +section {文字列演算} <
    +p {
      文字列操作のための簡単なプリミティヴがいくつか用意されているが，
      現状これらのうちの一部は開発初期の名残といった様相であり，積極的な使用を推奨しない．
      Unicode正規化の指定などはおろかUnicodeコードポイント単位の扱いをサポートせず，
      直接UTF-8バイト列を扱うなど，低級な処理として形式化されているためである．
    }
    +command (`^`) (tS --> (tS --> tS)) {
      文字列の結合．
    }
    +command (`arabic`) (tI --> tS) {
      受け取った整数の十進文字列を返す．
    }
    +command (`string-same`) (tS --> (tS --> tB)) {
      文字列がUTF-8のバイト列として等価かの判定．
      \subject-to-change;\discouraged;
    }
    +command (`string-sub`) (tS --> (tI --> (tI --> tS))) {
      \code{string-sub ${s} ${i} ${l}}で
      文字列\code{${s}}の第\code{${i}}番目の文字を先頭とする
      長さ\code{${l}}の部分文字列を取り出す．
      最初の文字は0番目，また長さはUTF-8表現でのバイト長であって
      Unicodeコードポイントの個数ではないことに注意．
      \subject-to-change;\discouraged;
    }
    +command (`string-length`) (tS --> tI) {
      受け取った文字列のUTF-8表現のバイト長を返す．
      \subject-to-change;\discouraged;
    }
  >
  +section {インライン方向に関する処理} <
    +command (`read-inline`) (tCTX --> (tIT --> tIB)) {
      \code{read-inline ${ctx} ${it}}で
      文脈\code{${ctx}}を用いて
      インラインテキスト\code{${it}}を変換したインラインボックス列を返す．
    }
    +command (`inline-skip`) (tL --> tIB) {
      \code{inline-skip ${l}}で
      長さ\code{${l}}の（伸縮しない）インライン方向の空白を返す．
    }
    +command (`inline-glue`) (tL --> (tL --> (tL --> tIB))) {
      \code{inline-glue ${l_0} ${l_1} ${l_2}}で
      自然長\code{${l_0}}，縮小基準長\code{${l_1}}，伸長基準長\code{${l_2}}
      のインライン方向の空白を返す．
    }
    +command (`inline-fil`) (tIB) {
      自然長0，罰則なしで任意有限長に伸長できるインライン方向の空白．
      左揃え，右揃え，中央揃えなどに有用である．
      特に段落の整形を目的として
      \code{line-break true true (${ib} ++ inline-fil)}の形で使う場面が多い．
    }
    +command (`++`) (tIB --> (tIB --> tIB)) {
      2つのインラインボックス列を結合して返す．
    }
    +command (`inline-nil`) (tIB) {
      長さ0のインライン方向の空白．
      より正確に言えばこれは空白ではなく，任意のインラインボックス列\code{${ib}}に対して
      \code{${ib} ++ inline-nil}が\code{${ib}}と全く同様に振舞うようになっている．
    }
    +command (`embed-string`) (tS --> tIT) {
      文字列をインラインテキストに変換する．
    }
    +command (`discretionary`) (tI --> (tIB --> (tIB --> (tIB --> tIB)))) {
      \code{line-break}による行分割の候補位置をつくる．
      \code{discretionary ${p} ${ib_0} ${ib_1} ${ib_2}}で
      「行分割されなかったときは\code{${ib_0}}を出力し，
      行分割されたときは分割位置の直前に\code{${ib_1}}を挿入し直後に\code{${ib_2}}を挿入する」
      という効果をもつインラインボックス列を返す．
      なお，この位置で行分割することになるか否かにかかわらず，
      各\code{${ib_i}}内にあるすべての行分割候補位置は行分割しない箇所として扱われる．
      \code{${p}}はペナルティ値であり，“どの程度行分割してほしくないか”の指標である．
      \code{10000}以上で「最悪」，すなわち「本当に行分割することが避けられない場合を除いてなんとしてもここで行分割しないでほしい」
      ことを指し，\code{0}で「行分割の抑制も促進もしない」を指す．
      \code{0}未満は「行分割しないよりも行分割する方が望ましい」ことを意味し，よりその位置での行分割が促進される．
    }
    +command (`script-guard`) (tSCR --> (tIB --> tIB)) {
      \code{script-guard ${script} ${ib}}で，インラインボックス列\code{${ib}}を
      文字体系\code{${script}}の単語として扱う．これは和欧間空白など異なる文字体系間のスペースの挿入の有無に影響を与える．
    }
    +command (`get-natural-width`) (tIB --> tL) {
      インラインボックス列を受け取り，その自然な幅を返す．
    }
    +command (`inline-graphics`) (tL --> (tL --> (tL --> (tIGR --> tIB)))) {
      \code{inline-graphics ${w} ${h} ${d} ${igr}}で
      幅\code{${w}}，高さ\code{${h}}，深さ\code{${d}}の
      領域にインライングラフィックス\code{${igr}}を描画したものをインラインボックス列として返す．
    }
    +command (`inline-frame-solid`) (tPADS --> (tDECO --> (tIB --> tIB))) {
      \code{inline-frame-solid ${p} ${d} ${ib}}で
      パディング指定\code{${p}}，装飾指定\code{${d}}，
      内容\code{${ib}}の途中で行分割不可能なフレームを返す．
    }
    +command (`inline-frame-breakable`) (tPADS --> (tDECOSET --> (tIB --> tIB))) {
      \code{inline-frame-breakable ${p} ${ds} ${ib}}で
      パディング指定\code{${p}}，装飾4つ組指定\code{${ds}}，
      内容\code{${ib}}の途中で行分割可能なフレームを返す．
    }
    +commands [`embedded-block-top`; `embedded-block-bottom`] (tCTX --> (tL --> (tCTX --> tBB) --> tIB)) {
      \code{embedded-block-top ${ctx} ${l} ${k}}
      で文脈\code{${ctx}}をテキスト幅に関して\code{${l}}に変更して
      継続\code{${k}}に渡し，
      その結果のブロックボックス列をインラインボックス列内に埋め込む．
      高さと深さは中身の最初の行のベースラインが外のベースラインと一致するように決められる．
      \code{embedded-block-bottom}は
      最後の行のベースラインが外のベースラインと一致することを除いて
      \code{embedded-block-top}と同様．
    }
    +commands [`line-stack-top`; `line-stack-bottom`] ((tLIST tIB) --> tIB) {
      複数のインラインボックス列をブロック方向に積む．全体の幅は最も長い行の幅となる．
      \code{line-stack-top}は最初の行のベースラインが外のベースラインと一致するように位置が決められ，
      \code{line-stack-bottom}は最後の行に合わせて決められる．
    }
  >
  +section {ブロック方向に関する処理} <
    +command (`read-block`) (tCTX --> (tBT --> tBB)) {
      \code{read-block ${ctx} ${bt}}で
      文脈\code{${ctx}}に従ってブロックテキスト\code{${bt}}を
      変換したブロックボックス列を返す．
    }
    +command (`line-break`) (tB --> (tB --> (tCTX --> (tIB --> tBB)))) {
      \code{line-break ${b_1} ${b_2} ${ctx} ${ib}}
      で文脈\code{${ctx}}にしたがってインラインボックス列\code{${ib}}を
      適切に行分割して段落の形に組んだブロックボックス列を返す．
      \code{${b_1}}が\code{true}のときはその段落の直前での改ページを許し，
      \code{false}のときは許さない．
      \code{${b_2}}も同様に段落の直後で改ページを許すかの指定である．
      \subject-to-change;
    }
    +command (`form-document`) (tCTX --> (tBB --> tDOC)) {
      与えられたインラインボックス列を適切にページ分割して文書に整形する．
    }
    +command (`+++`) (tBB --> (tBB --> tBB)) {
      2つのブロックボックス列を結合して返す．
    }
    +command (`block-nil`) (tBB) {
      高さ0のブロックボックス列．より正確には，任意のブロックボックス列\code{${bb}}に対して
      \code{${bb}}と\code{${bb} ++ block-nil}が全く等価に振舞うようになっている．
    }
  >
>
