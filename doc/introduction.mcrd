\document{
  \settings;
  \title{Macrodown \version; 解説（未完成）}
  \author{\twitter-at-id{bd_gfngfn}}
}{
  \maketitle;
  \section{概要}{
    \p{
      \newword{Macrodown}（\newword{マクロダウン}）は
      「マークアップの記述においてはマークアップ方法自体もユーザが設計できるべきである」
      という思想のもとに制作された，
      \LaTeX;やHTMLなどのマークアップ言語をラップするための軽量［要出典］マークアップ言語です。
      OCamlで実装しており，ソースコードは

      \url-display{http://github.com/gfngfn/Macrodown}

      で公開しています。この文書もMacrodownを経由してHTMLソースコードと\LaTeX;ソースコードを出力し，
      \LaTeX;ソースコードの方は\pLaTeX2e;とdvipdfmxで組んでいます。
    }
  }
  \section{動機}{
    \p{
      今日，一般的な文書作成のために多用されているマークアップ言語としては
      HTML+CSSや\LaTeX;などが挙げられます。
      しかし，このHTML+CSSと\LaTeX;は一長一短です。
    }
    \p{
      HTML+CSSは構造と体裁がよく分離されており，CSSによる体裁の変更等も柔軟ですが，
      記法が冗長で，またマクロ定義機能も存在していない\footnote{おそらく意図的に取り入れられていないのでしょう。}ため，
      直接人間の手で文書を記述するには適しているとは思えません。
      Markdown，AsciiDoc，その他ローカルなWiki記法など，HTMLを専用にラップする軽量マークアップ言語も数多くありますが，
      用途が限られている傾向にあり，表現力は乏しいと言わざるを得ないでしょう。
    }
    \p{
      一方の\LaTeX;は比較的平易な記法でマクロ定義機能が備わっており，先達による高度なパッケージも充実し，
      そして何よりもソフトウェアとしての\TeX;が高品質な組版結果を出力してくれますが，
      構造と体裁が明示的に分離されていないため体裁を扱うには或る程度のリテラシーが必要であったり，
      柔軟なマクロを創るには\TeX; on \LaTeX;の知識が必要で，これが相当非直感的な仕様であるため，
      大多数の人を寄せつけない様相を呈しています。
    }
    \p{
      これらの欠点を解決し，またWebページとPDFを共通の規格で記述できるようにすべく，
      Macrodownの制作に手をつけました。
      記法は“OCamlと\LaTeX;のハーフ”であり，
      “意味論が綺麗な\LaTeX;的記法”を目指したといってもよいかもしれません。
    }
  }
  \section{実用的な例}{
    \subsection{クラス名・ID名オプション}{
      \p{
        クラス名・ID名オプション機能を使うと，
        例えば

        \mcrd-display```
          \div{The quick brown fox jumps over the lazy dog.}
          \div .quote {色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。}
          \div .quote #tori {鳥啼く声す，夢覚ませ。見よ明け亘る，東を。}
        ```

        から

        \mcrd-display```
          <div>
            The quick brown fox jumps over the lazy dog.
          </div>
          <div class="quote">
            色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。
          </div>
          <div class="quote" id="tori">
            鳥啼く声す，夢覚ませ。見よ明け亘る，東を。
          </div>
        ```
            %有為の奥山今日越えて，浅き夢見じ，酔いもせず。
            %空色映えて，沖つ辺に，帆船群れゐぬ，靄の内。

        を得るようなマクロ \mcrd`\div` を定義することができます。
        クラス名・ID名オプション機能はHTMLの影響で実装したものですが，
        HTMLに限らず「マークアップ上大きな意味はないが小さい分岐をさせたいとき」に利用できます。
        函数・マクロ定義の項目で後述します。
      }
    }
    \subsection{自動番号づけ・相互参照}{
      \p{
        Macrodownには強力な相互参照を実装できる機能があり，例えば
        
        \mcrd-display```
          \section{はじめに}{
            \p{後方参照の例です。\ref{next}の番号を前方で取得できます。}
          }
          \section #next {サンプル}{
            \p{参照される側にはIDをつけておけばOK!}
          }
        ```

        に対する出力として

        \mcrd-display```
          <section>
            <h1>第1章 はじめに</h1>
              <p>
                後方参照の例です。第2章の番号を前方で取得できます。
              </p>
            <!-- ---- ---- ---- ---- -->
          </section>
          <section id="next">
            <h1>第2章 サンプル</h1>
              <p>
                参照される側にはIDをつけておけばOK!
              </p>
            <!-- ---- ---- ---- ---- -->
          </section>
        ```

        を得るようなマクロ \mcrd`\section`，\mcrd`\ref` を定義することが可能です。
        \LaTeX;ではこのような相互参照は更新するたびに2回タイプセットしなければ正当に出力されませんが，
        Macrodownのテキスト整形では1度で正当な相互参照を出力することができます。
      }
    }
  }
  \section{言語仕様}{
    \subsection{概要}{
      \p{
        Macrodownは手続き的記述よりも函数的記述に特化しています。
        変数には基本的に破壊的代入の機能がなく，
        したがって純粋函数型プログラミングに近い性質をしています。
      }
      \p{
        \newword{函数}と\newword{マクロ}は基本的にほとんど同様に扱えるもので，
        単に\newword{制御綴}で書かれるものをマクロ，
        制御綴でない普通の変数名のように書かれるものを函数と便宜的に呼び分けているだけです。
        制御綴は\newword{テキスト階層}で，函数は\newword{プログラム階層}で用いるようになっています。
        以降はプログラム階層を基本にして例を掲げていきましょう。
      }
    }
    \subsection{入出力方法}{
      \p{
        まずはどのようにソースコードを与え，どのように出力を得るかを見てみましょう。
        お決まりのHello World!を出力するソースコードを書いてみます。
        
        \mcrd-input{input.mcrd}```
          Hello World!
        ```
        
        一般的なプログラミング言語でHello World!を書いた人なら「冗談だろう」と思われることでしょう。
        世界で最もつまらないHello World!であることは疑う餘地なしです。これに対して
        
        \mcrd-display```
          macrodown input.mcrd -o output.txt
        ```

        とコマンドプロンプトやターミナルで処理すると

        \mcrd-output{output.txt}```
          Hello World!
        ```
        
        が得られます。「何もしていないじゃないか！」と思われても仕方ないので，
        もう少しMacrodownを勤勉に見せる例を挙げます。
        勿論詳しい仕組みは後述するので，おまじない程度に認識しても構いません。
        
        \mcrd-input{header.mcrdh}```
          let \hello s = {Hello, @s;!}
        ```
        \mcrd-input{input.mcrd}```
          \hello{World} \hello{Macrodown}
        ```
        
        という2つのファイルを用意し，
        
        \mcrd-display```
          macrodown header.mcrdh input.mcrd -o output.txt
        ```
        
        と処理すると
        
        \mcrd-output{output.txt}```
          Hello, World! Hello, Macrodown!
        ```
        
        なるファイルが出力されます。\file-name{header.mcrdh}で\mcrd`\hello`というマクロが定義され，
        \file-name{input.mcrd}でそれを使用しているというわけです。
        拡張子が\extension{.mcrdh}のものはプログラム階層で函数・マクロを定義する\newword{ヘッダファイル}，
        拡張子が\extension{.mcrd}のものはテキスト階層で文書を記述する\newword{文書ファイル}です。
        このほか入力ファイルの拡張子として\extension{.mcrds}があり，
        これはプログラム階層で記述されながらも文書として出力される\newword{単独ファイル}です。
        例えばさきほど2ファイル要した例も
        
        \mcrd-input{input.mcrds}```
          let \hello s = {Hello, @s;!} in
            {\hello{World} \hello{Macrodown}}
        ```
        
        とすると1ファイルで等価に記述することができます。
        \mcrd`{\hello{World} \hello{Macrodown}}` の
        最も外側の \mcrd`{` と \mcrd`}` はテキスト階層の開始と終了を表しています。
        プログラム階層中に \mcrd`{` があると，
        その \mcrd`{` とそれに釣り合う \mcrd`}` の直前までがテキスト階層となります。
      }
      \p{
        処理のしやすさを考慮して，言語仕様の解説でもこの単独ファイルを中心に扱います。
        とはいえ大きな文書の記述に単独ファイルを実用することはおそらくほとんどなく，
        デバッグ等に使うと便利という程度です。
      }
      \p{
        非常に小さい例でしたが，Macrodownはこのような仕組みを駆使して
        「共通の処理を抽出して，文字の並べるだけではなく意味を示しながら文書を記述する」
        ことを目的とした，メタなマークアップ言語を設計して使用できるシステムなのです。
        以降の節で言語仕様を掲げます。
      }
    }
    \subsection{変数・函数・マクロ}{
      \p{
        以下のような\newword{定義式}

        \code-display{
          \synt`let` \meta{hoge} %
            \meta{nvar1} \metadots; \meta{nvarN}
            \synt`=` \meta{ExprA} \synt`in` \meta{ExprB}
        }

        で引数を\math{N}個伴う函数\code{\meta{hoge}}が定義されます。
        定義が有効な範囲を\newword{スコープ}と言い，
        この函数\code{\meta{hoge}}の定義は\code{\meta{ExprB}}がスコープです。
        函数だけでなくマクロも同様の構文で定めることができ，

        \code-display{
          \synt`let` \synt`\`\meta{piyo} %
            \meta{var1} \metadots; \meta{varN}
            \synt`=` \meta{ExprA} \synt`in` \meta{ExprB}
        }

        で \code{\synt`\`\meta{piyo}} が \code{\meta{ExprB}} をスコープとして定義されます。
        なお，普通積極的には用いませんが，名前のない函数は

        \code-display{
          \synt`(function` \meta{nv1} \metadots; \meta{nvN}
          \synt`->` \meta{Expr} \synt`)`
        }

        で表現することができます。例えば与えられた整数を2乗する函数は
        \mcrd`(function n -> n * n)` です。

        \code-display{
          \synt`\`\meta{hoge}\ %
            \synt`{`\meta{Arg1}\synt`}`\metadots;\synt`{`\meta{ArgN}\synt`}`
        }

        で各 \code{\meta{varI}} に \code{\meta{ArgI}} が格納された上で定義式の \code{\meta{Expr}} が評価されます。
        定義された函数をプログラム階層で使うときは単に引数を並べることで適用します。
        例えば
        
        \mcrd-input{test.mcrds}```
          let f x = x * x in arabic (f (f 3))
        ```
        
        に対する出力は
        
        \mcrd-output{test.txt}```
          81
        ```
        
        となります。Macrodownにはユーザが定儀せずとも最初から備わっている函数とマクロ
        \footnote{正確には，ユーザが定義しようとしても原理的に定義できないものがほとんどです。}
        がいくつもあり，これを\newword{プリミティヴ}と呼びます。
        上の例で登場した\mcrd`arabic`は整数を文字列に変換するプリミティヴです。もし入力を

        \mcrd-input{test.mcrds}```
          let f x = x * x in f (f 3)
        ```
        
        としたならば，これは 81 という整数値になるはずです。しかし，
        Macrodownは文字列値しか出力することができないので，
        
        \mcrd-display```
          ! [ERROR IN TYPECHECK] the output of 'test.mcrds' is not string.
        ```
        
        とエラーが返されるようになっています。したがって
        さらに \mcrd`arabic` を適用して \mcrd`81` という文字列に変換してやる必要があるのです。
        値には\newword{型}がついており，整数値は\type-synt`int`型，文字列値は\type-synt`string`型です。
        Macrodownは，\type-synt`string`型のデータのみを出力できるようになっている，というわけです。
        \mcrd`arabic`は\type-synt`int`型の値を受け取って\type-synt`string`型の値を返す函数であり，
        これを表して\type-synt`int -> string`型を持っていると扱われます。
        型が整合していない場合，実際に処理が行なわれる前にその不整合を検出してエラーを返します。
        これが\newword{静的型検査}という仕組みです。
      }
      \p{
        既に説明なく乗算 \mcrd`*` を用いましたが，算術演算子には
        \itemize{
          | 乗算 \mcrd-type`*` `int -> int -> int`
          | 除算 \mcrd-type`/` `int -> int -> int`
          | 剰餘 \mcrd-type`mod` `int -> int -> int`
          | 加算 \mcrd-type`+` `int -> int -> int`
          | 減算 \mcrd-type`-` `int -> int -> int`
          |}
        があります。\mcrd`-` は単項演算子としても使用することができます。
        なお，2項演算子は \mcrd`(` と \mcrd`)` で囲うことで普通の函数のように使うことができます。
        例えば \mcrd`(function n -> 3 + n)` と \mcrd`(+) 3` は同等です。
      }
      \p{
        マクロも函数とまったく同様の構文で定義することができます。
        ただし，マクロはプログラム階層では適用することができず，必ずテキスト階層で用います。
        テキスト階層では，引数は基本的に\type-synt`string`型であり，
        これは各引数を \mcrd`{` と \mcrd`}` で括ることによって与えます。
        例えば

        \mcrd-input{test.mcrds}```
          let \test x y = {Ma@x;r@y;down} in
            {\test{c}{o}, \test{}{k}}
        ```

        に対する出力は

        \mcrd-output{test.txt}```
          Macrodown, Markdown
        ```

        となります。
        変数\code{\meta{piyo}}に格納された中身をテキスト階層中で取り出すには
        \code{\synt`@`\meta{piyo}\synt`;`}とします。
        或いは，文字列結合演算子 \mcrd-type`^` `string -> string -> string` を用いて

        \mcrd-input{test.mcrds}```
          let \test x y = {Ma} ^ x ^ {r} ^ y ^ {down} in
            {\test{c}{o}, \test{}{k}}
        ```

        としても同様ですが，ここでは \mcrd`@` を使う方が短く済んで見やすいようです。
      }
      \p{
        なお，マクロを制御綴で記述する仕様になっているために，テキスト階層に於いて
        文字 \mcrd`\`，\mcrd`{`，\mcrd`}`，\mcrd`@` は
        文字そのものとして直接書くことができません。
        また，これらに加えて \mcrd`` ` `` も同様に文字そのものとしては書けません。
        これらの文字を文字そのものとして書くには
        \mcrd`\\`，\mcrd`\{`，\mcrd`\}`，\mcrd`\@`，\mcrd``\` `` とエスケープする必要があります。
        実際にはいちいちエスケープしていては面倒なので，
        後述するリテラル階層という機能によりさらに簡潔に記述することができます。
      }
      \p{
        定義式を用いて変数や引数のないマクロも定義できます。
        引数のないマクロは，使用の際にセミコロンをつけます。例えば

        \mcrd-input{no-arg.mcrds}```
          let \mcrd = {Macrodown} in {Hello, \mcrd;!}
        ```

        に対する出力は

        \mcrd-output{no-arg.txt}```
          Hello, Macrodown!
        ```

        となります。
      }
      \p{
        引数に文字列以外の値を与えることもできます。
        例として，整数値を2つ渡すとそれらの和を文字列にし，単位をつけて返すマクロ \mcrd`\sumstr` を定義してみましょう。
        
        \mcrd-input{header.mcrdh}```
          let \sumstr m n u = (arabic (m + n)) ^ u
        ```
        
        これを文書中で使うには
        
        \mcrd-input{doc.mcrd}```
          \sumstr(3)(4){個}
        ```
        
        というように文字列でない値を \mcrd`(` と \mcrd`)` で括って与えます。これらを処理すると
        
        \mcrd-output{doc.txt}```
          7個
        ```
        
        とめでたく出力されることとなります。ただし注意として，
        \mcrd`{` と \mcrd`}` で括られた引数（\newword{テキスト引数}）が存在する時，
        \mcrd`(` と \mcrd`)` で括られた引数（\newword{プログラム引数}）はいずれも
        どのテキスト引数よりも手前になければなりません。
        そのうえ，すべての引数がプログラム引数である場合，末尾には必ず \mcrd`;` をつけねばなりません。
        したがって，\mcrd`\sumstr` を

        \mcrd-input{header.mcrdh}```
          let \sumstr u m n = (arabic (m + n)) ^ u
        ```
        
        という引数の順序で定義して
        
        \mcrd-input{doc.mcrd}```
          \sumstr{個}(3)(4)
        ```
        
        とすることはできません。
        この入力だと \mcrd`{個}` に \mcrd`{` が後続しないため「引数は1つである」と判断され，
        残りの \mcrd`(3)(4)` はすべて単なる文字列と解釈されてしまいます。したがって
        \mcrd`\sumstr` は\type-synt`string -> int -> int -> string`型で
        適用結果は\type-synt`string`型でなければならないのに
        引数として\type-synt`string`型の値1つしか与えられていないので，
        型検査で不整合と判断しMacrodownはエラーを返します。
        
        \mcrd`(3)(4)` が単なる文字列になっていることは，代わりに

        \mcrd-input{header.mcrdh}```
          let \sumstr t = {A@t;B}
        ```
        \mcrd-input{doc.mcrd}```
          \sumstr{個}(3)(4)
        ```

        を処理すると
        
        \mcrd-output{doc.txt}```
          A個B(3)(4)
        ```
        
        が出力されることからもわかります。
        なお，あまりおすすめしませんが，
        文字列値はテキスト引数ではなくプログラム引数で与えることもできるので，先ほどのように

        \mcrd-input{header.mcrdh}```
          let \sumstr u m n = (arabic (m + n)) ^ u
        ```

        の引数の順序で定義したとしても
        
        \mcrd-input{doc.mcrd}```
          \sumstr( {個} )(3)(4);
        ```
        
        と使うことができ，やはり処理するとその出力は

        \mcrd-output{doc.txt}```
          7個
        ```
        
        となります。型さえ整合していれば，
        構文上でテキスト引数かプログラム引数かは問わない，ということです。
      }
    }
    \subsection{条件分岐}{
      \p{
        条件分岐は単純明快で，
        
        \code-display{
          \synt{if} \meta{ExprB} \synt{then} \meta{ExprT} \synt{else} \meta{ExprF}
        }
        
        の構文を用います。\code{\meta{ExprB}} は
        真偽値を表す\type-synt`bool`型を持ち，これを評価して \mcrd`true` であった場合は
        \code{\meta{ExprT}}を評価してその結果を，
        \mcrd`false` であった場合は
        \code{\meta{ExprF}}を評価してその結果を返します。
        例として1つの整数値をFizzBuzz上の表現にするマクロ \mcrd-type`\fb` `int -> string`
        を定義して使ってみましょう。
        
        \mcrd-input{input.mcrds}```
          let \fb n =
            if n mod 5 == 0 then
              if n mod 3 == 0 then {FizzBuzz} else {Buzz}
            else
              if n mod 3 == 0 then {Fizz} else arabic n
          
          in {
            \fb(1);, \fb(3);, \fb(6);, \fb(10);, \fb(15);, \fb(21);, \fb(28);
          }
        ```
        \mcrd-output{output.txt}```
          1, Fizz, Fizz, Buzz, FizzBuzz, Fizz, 28
        ```
      }
      \p{
        整数の比較で真理値を返す演算子として
        \itemize{
          | 等価演算子 \mcrd-type`==` `int -> int -> bool`
          | 非等価演算子 \mcrd-type`<>` `int -> int -> bool`
          | 不等号演算子 \mcrd-type`>=` `int -> int -> bool`
          | 不等号演算子 \mcrd-type`<=` `int -> int -> bool`
          | 不等号演算子 \mcrd-type`>` `int -> int -> bool`
          | 不等号演算子 \mcrd-type`<` `int -> int -> bool`
          |}
        があります。またいわゆる論理演算子として
        \itemize{
          | 選言 \mcrd-type`||` `bool -> bool -> bool`
          | 連言 \mcrd-type`&&` `bool -> bool -> bool`
          | 否定 \mcrd-type`not` `bool -> bool`
          |}
        があります。
      }
    }
    \subsection{文字列操作プリミティヴ}{
      \p{
        文字列を“直接見る”或いは“加工する”プリミティヴとして
        \itemize{
          | \mcrd-type`\deeper` `string -> string`
          | \mcrd-type`string-length` `string -> int`
          | \mcrd-type`string-sub` `string -> int -> int -> string`
          | \mcrd-type`same` `string -> string -> bool`
          |}
        があります。
        \mcrd`\deeper` は出力される文字列に於けるインデントを深めて返し，
        \code{\synt`string-length` \meta{s}} は与えられた文字列 \code{\meta{s}} の長さを返し，
        \code{\synt`string-sub` \meta{s} \meta{i} \meta{l}} は
        文字列 \code{\meta{s}} の \code{\meta{i}} 文字目から \code{\meta{l}} 文字を返し，
        \code{\synt`same` \meta{s} \meta{t}} は
        文字列 \code{\meta{s}} と \code{\meta{t}} が一致していれば真を，そうでなければ偽を返します。
      }
      \p{
        ただし，これらのプリミティヴの機能は，厳密には上記の説明ほど単純ではありません。
        ほとんどの場合は上記の説明で意図通り使用することができますが，用いられ方によっては
        \type-synt`string`型の仕様とMacrodownの評価規則を正確に知らないと不可解に近いような挙動を見せてしまいます。
        これについては後の\newword{最終値参照}と\newword{グローバルハッシュ}の節で述べます。
      }
    }
    \subsection{再帰}{
      \p{
        条件分岐を使えば，再帰函数によって繰り返し処理を書くこともできます。
        全然実用的ではありませんが，
        1から与えられた整数までを並べた文字列を返す函数 \mcrd`\lineup` を定義して使ってみましょう。
        
        \mcrd-input{lineup.mcrds}```
          let \lineup n =
            if n <= 0 then {} else
              let s = arabic n in {\lineup(n - 1);[@s;]}

          in {\lineup(20);}
        ```
        \mcrd-output{lineup.txt}```
          [1][2][3][4][5][6][7][8][9][10][11][12][13][14][15][16][17][18][19][20]
        ```
        
        いわゆる函数型プログラミングの経験がない方には少し想像しづらいかもしれませんが，
        慣れてしまえばループ処理よりもずっと少ない手間で書くことができます。
      }
    }
    \subsection{リストとパターンマッチ}{
      \p{
        具体的なリストは，基本的に
        
        \mcrd-display```
          [3; 1; 4; 1; 5; 9; 2]
        ```

        のように\code{\synt`[`}と\code{\synt`]`}で括って各要素を\code{\synt`;`}で区切って書きます。
        リストでは，全ての要素の型が一致していなければなりません。
        \type-synt`'t`型の要素を持つリストの型は\type-synt{'t list}であり，
        例えば\type-synt`int`型のリストは\type-synt{int list}型になります。
        なお，実際に文書中のテキスト階層で用いるリストの多くは
        \type-synt`string list`型のリストをマクロの引数とする場合ですが，これは

        \mcrd-display```
          \somecs( [{hoge}; {piyo}; {fuga}; {moge}] );
        ```

        と複雑に入り組んだ書き方をせずとも

        \mcrd-display```
          \somecs{|hoge|piyo|fuga|moge|}
        ```

        と省略して書くことができます。
        プログラム階層でも \mcrd`{|hoge|piyo|fuga|moge|}` で
        \mcrd`[{hoge}; {piyo}; {fuga}; {moge}]` の省略として使えます。
      }
      \p{
        リストの各要素を取り出して操作には，\newword{パターンマッチ}を用います。一般にパターンマッチは

        \code-display{
          \synt`match` \meta{Expr0} \synt`with`\code-break;
          \synt`|` \meta{pat1} \synt`->` \meta{Expr1}\code-break;
          \synt`|` \meta{pat2} \synt`->` \meta{Expr2}\code-break;
          \metadots;\code-break;
          \synt`|` \meta{patN} \synt`->` \meta{ExprN}
        }
        
        という記法をとり，\code{\meta{Expr0}} の値が
        パターン \code{\meta{pat1}} に合致する場合は \meta{Expr1} を返し，
        パターン \code{\meta{pat1}} に合致しない場合は
        次の \code{\meta{pat2}} と照らしあわせて合致すれば \meta{Expr2} を返し，
        ……という，上から順にマッチする表現を探して対応する値を返す仕組みです。
        具体的に次の例を見てみましょう。
        
        \mcrd-input{enclose.mcrds}```
          let \enclose lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {(@hd;)\enclose(tl);}
          
          in {\enclose{|hoge|piyo|fuga|moge|}}
        ```
        
        という入力に対して
        
        \mcrd-output{enclose.txt}```
          (hoge)(piyo)(fuga)(moge)
        ```
        
        という文字列になります。
        %まずリストの先頭要素を取り出す函数が \mcrd-type`list-head`{'a list -> 'a}，
        %先頭を除いたリストを得る函数が \mcrd-type`list-tail`{'a list -> 'a list} です。
        %例えば \mcrd`list-head [2; 4; 6; 9; 11]` は \mcrd`2` に，
        %\mcrd`list-tail [2; 4; 6; 9; 11]` は \mcrd`[4; 6; 9; 11]` にそれぞれ評価されます。
      }
%      \p{
%        では，\mcrd`list-head` および \mcrd`list-tail` に空のリスト \mcrd`[]` を渡すとどうなるかというと，
%        これは実行時エラーで終了してしまいます。
%        そこで，リストが空かどうか判定する函数 \mcrd-type`is-empty` `'a list -> bool` を使うことになります。
%      }
      \p{
        リストを再帰的に扱う例を見てみましょう。
        \type-synt`string list` 型の値を受け取り，
        各要素をHTMLのリストの項目として並べたものを返す
        マクロ \mcrd-type`\ul` `string list -> string` を定義します。

        \mcrd-input{ul.mcrdh}```
          let sub-ul lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {<li class="list-content">@hd;</li>} ^ break ^ (sub-ul tl)

          let \ul lst = {<ul>\deeper(sub-ul lst);</ul>}
        ```
        \mcrd-input{ul.mcrd}```
          \ul{|hoge|piyo|fuga|moge|}
        ```

        を処理した出力は
        
        \mcrd-output{ul.txt}```
          <ul>
            <li class="list-content">hoge</li>
            <li class="list-content">piyo</li>
            <li class="list-content">fuga</li>
            <li class="list-content">moge</li>
          </ul>
        ```

        となります。ここで挙げた例は4要素のリストですが，
        実際の文書を記述するにあたってはもっと長いリストも登場することでしょう。
        そのように何度も同じ記述が繰り返される場合，すべて手で打つのではなく，
        共通部分は再帰的なマクロ定義に含ませて，異なる部分をリストの各要素として与えることにより，
        効率的にマークアップすることができます。
      }
      \p{
        ついでに再帰の例として有名な左畳み込み演算
        \mcrd-type`foldl` `('a -> 'b -> 'a) -> 'a -> 'b list -> 'a`
        とそれを使った函数を掲げておきます。

        \mcrd-input{foldl.mcrds}```
          let foldl f i lst =
            match lst with
            | []       -> i
            | hd :: tl -> foldl f (f i hd) tl

          let sum = foldl (+) 0
          let \sum lst = arabic (sum lst)

          let count m a = m + 1
          let length = foldl count 0
          let \length lst = arabic (length lst)

          let enclose s t = {@s;[@t;]}
          let \display = foldl enclose {}

          in {
            \sum    ( [3; 1; 4; 1; 5; 9; 2] );
            \length ( [3; 1; 4; 1; 5; 9; 2] );
            \display{|hoge|piyo|fuga|moge|}
          }
        ```
        \mcrd-output{foldl.txt}```
          25
          7
          [hoge][piyo][fuga][moge]
        ```
        リストになっている整数の総和を返す函数 \mcrd-type`sum` `int list -> int`，
        リストの長さを返す函数 \mcrd-type`length` `'a list -> int`，
        リストの文字列各々を四角括弧で括って並べるマクロ \mcrd-type`\display` `string list -> string`
        がそれぞれ \mcrd`foldl` を使って非常に簡潔に定義できています。
      }
    }
    \subsection{相互再帰}{
      \p{
        再帰は“自己再帰”に限らず，複数の函数が“相互に依存しあう”こともできます。
        例えば奇数番目が\mcrd`style-odd`クラス，偶数番目が\mcrd`style-even`クラスに指定される
        HTMLのリストを書きたいときは

        \mcrd-input{mut.mcrds}```
          let ul-odd lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {<li class="style-odd">@hd;</li>} ^ (ul-even tl)

          and ul-even lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {<li class="style-even"@hd;</li>>} ^ (ul-odd tl)

          let \ul lst = {<ul>\deeper(ul-odd lst);</ul>}
          in {
            \ul{|hoge|piyo|fuga|moge|}
          }
        ```
        
        と \mcrd`and` を用いて“並列的に” \mcrd`ul-odd` と \mcrd`ul-even` を宣言して書くと
        
        \mcrd-output{mut.txt}```
          <ul>
            <li class="style-odd">hoge</li>
            <li class="style-even">piyo</li>
            <li class="style-odd">fuga</li>
            <li class="style-even">moge</li>
          </ul>
        ```
        
        が出力されます。もしかしたら
        「なぜわざわざ \mcrd`and` で書く必要があるんだ？ \mcrd`let` に置き換えてもいいんじゃないか」
        と思われるかもしれませんが，これはスコープの問題で，もしも

        \code-display{
          \synt{let} \meta{f} \meta{x1} \metadots; \meta{xM} \synt{=} \meta{ExprA}\code-break;
          \code-break;
          \synt{let} \meta{g} \meta{y1} \metadots; \meta{yN} \synt{=} \meta{ExprB}
        }
        
        と書くと，
        \code{\meta{ExprB}} で \code{\meta{f}} を使うことができても
        \code{\meta{ExprA}} で \code{\meta{g}} を使うことができないのです。

        \code-display{
          \synt{let} \meta{f} \meta{x1} \metadots; \meta{xM} \synt{=} \meta{ExprA}\code-break;
          \code-break;
          \synt{and} \meta{g} \meta{y1} \metadots; \meta{yN} \synt{=} \meta{ExprB}
        }
        
        とすると，これは
        \code{\meta{ExprB}} で \code{\meta{f}} を使うことも
        \code{\meta{ExprA}} で \code{\meta{g}} を使うこともできるようにスコープが設定されています。
        このように \mcrd`and` を駆使せねばならないことは一見面倒なように見えますが，
        定義の依存関係を明確に意識して書ける，
        すなわち一度書いた定義を後で書き換えるとどの範囲に影響が及ぶかということが明確になるという意味で有用です。
      }
    }
    \subsection{ファイル分割}{
      \p{
        これまでは単独ファイルの例を多用してきましたが，実用上は函数とマクロの定義をヘッダファイルに，
        “文書本体”を文書ファイルに記述する方が便利です。
        というのも，複数のターゲット言語，例えば\LaTeX;とHTML/CSSの両方に出力したいとき，
        “文書本体”を共通のデータにしてヘッダファイルのみを入れ替えることでどちらも出力することができる，
        という利点があるためです。
        その他，単独ファイルだと先頭の函数とマクロの定義がかさばって見づらい，という問題も解消できます。
      }
      \p{
        ヘッダファイルはプログラム階層で記述し，

        \code-display{
          \synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1}\code-break;
          \code-break;
          \synt{let} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2}\code-break;
          \code-break;
          \metadots;\code-break;
          \code-break;
          \synt{let} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM}
        }
        
        というように \mcrd`let` で宣言を並べます。
        この宣言が並ぶ“最も外側の領域”を\newword{大域環境}と呼びます。
        大域環境の \mcrd`let` は
        \code{\synt{let} \meta{hoge} \synt{=} \meta{Expr} \synt{in} \meta{Expr}}
        のように \mcrd`in` をつける必要はありませんが，上のコードは実際には

        \code-display{
          \synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1} \synt{in}\code-break;
          \code-tab;
          \synt{let} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2} \synt{in}\code-break;
          \code-tab;\code-tab;
          \metadots;\code-break;
          \code-tab;\code-tab;\code-tab;
          \synt{let} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM} \synt{in}\code-break;
          \code-tab;\code-tab;\code-tab;\code-tab;
          \synt{finish}
        }
        
        と同等となります。最後の \mcrd`finish` は実際には書けないトークンで，値としては \mcrd`()` ですが，
        これが書かれた場所から“見える”函数・マクロの定義を次以降のファイルの読み込みに引き継ぐという機能を持っています。
      }
      \p{
        大域環境での相互再帰はやはり

        \code-display{
          \synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1}\code-break;
          \code-break;
          \synt{and} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2}\code-break;
          \code-break;
          \metadots;\code-break;
          \code-break;
          \synt{and} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM}
        }

        と書きますが，
        「定義の依存関係が明白になるなんて全然有用に思えん！\quad;\mcrd`and` なんて意識しないで書きたい！」
        という方のために \mcrd`mutual`～\mcrd`end-mutual` という糖衣構文を用意しており，
        
        \code-display{
          \synt{mutual}\code-break;
          \code-tab;\synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1}\code-break;
          \code-break;
          \code-tab;\synt{let} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2}\code-break;
          \code-break;
          \code-tab;\metadots;\code-break;
          \code-break;
          \code-tab;\synt{let} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM}\code-break;
          \synt{end-mutual}
        }
        
        と書くことで，上に掲げた \mcrd`and` を用いたものと同等となります。
      }
    }
    \subsection{リテラル階層}{
      \p{
        テキスト階層では，\mcrd`\`，\mcrd`{`，\mcrd`}`，\mcrd`` ` ``，\mcrd`@` という
        “そのままでは書けない”文字がありました。これらはそれぞれ
        \mcrd`\\`，\mcrd`\{`，\mcrd`\}`，\mcrd``\` ``，\mcrd`\@` とエスケープしなければならないのですが，
        長い定文字列中にこれらの文字が高頻度で出現する場合は非常に面倒です
        （特に\LaTeX;をターゲット言語とするマクロを記述する場合，
        これらの文字をいちいちエスケープしていては大変です）。
        そこでより簡潔に定文字列を書く方法として，プログラム階層で
        
        \mcrd-input{literal1.mcrds}```
          `In literal areas, you can use letters \, {, }, and @ as they are.`
        ```
        
        と \mcrd`` ` `` で括って書くことで
        
        \mcrd-output{literal1.txt}```
          In literal areas, you can use letters \, {, }, and @ as they are.
        ```

        と出力できるようになっています。これを\newword{リテラル階層}と呼びます。
        「えっ，では \mcrd`` ` `` そのものはどうやって書くんだ」と思われた方，安心してください。
        \mcrd`` ` `` が含まれる文字列は全体を \mcrd``` `` ``` で囲んで
        
        \mcrd-input{literal2.mcrds}```
          ``You can also use ` in literal areas like this.``
        ```
        
        \mcrd-output{literal2.txt}```
          You can also use ` in literal areas like this.
        ```
        
        のように使えます。さらに \mcrd``` `` ```が含まれる文字列は全体を \mcrd```` ``` ```` で囲んで，
        …と文字列中に \mcrd`` ` `` が連続する最大個数よりも多い数の \mcrd`` ` `` で括ってリテラル階層にすることができます。
        左右の個数は同数でなければなりません。
      }
      \p{
        \mcrd`` ` `` \metadots; \mcrd`` ` `` はプログラム階層での文字列だけでなく，テキスト引数として使うこともできます。
        すなわち，例えば
        
        \mcrd-input{literal3.mcrds}```
          let \test inner = {The parameter is @inner;.} in
            {\test`{@bd_gfngfn}`}
        ```
        
        に対しては
        
        \mcrd-output{literal3.txt}```
          The parameter is {@bd_gfngfn}.
        ```
        
        と出力されます。
        リテラル階層を用いて2個以上の連続するテキスト引数を書く場合は，
        それらの引数の間にスペースを空けねばなりません。すなわち
        
        \mcrd-input{literal4.mcrds}```
          let \test p1 p2 = {First: p1, Second: p2.} in
            {(\test``vis-a`-vis`` `P \/ Q`)}
        ```
        \mcrd-output{leteral4.txt}```
          (First: vis-a`-vis, Second: P \/ Q.)
        ```
        
        のようにします。これは，スペースを空けないと \mcrd``` `` ``` で始まった
        1個目の引数が \mcrd```` ``` ```` で終了しているとみなされてしまい，
        釣り合いがとれていないという旨のエラーが返されるからです。
      }
    }
    \subsection{クラス名・ID名オプション}{
      \p{
        マクロは適用に於いて\newword{クラス名オプション}および\newword{ID名オプション}をとることができます。
        ここで言うクラス名とID名とは，おおよそHTMLのクラス属性とID属性にそれぞれ対応するものです。
        クラス名オプション，ID名オプションはいずれもアクティヴ階層で使い，
        
        \code-display{
          \synt`\`\meta`cs` \synt`.`\meta`class` \synt`#`\meta`id` \synt`(` \metadots;
        }
        
        のように，マクロを表す制御綴よりも後ろで，どのプログラム引数よりも手前に書きます。
        クラス名オプションとID名オプションはいずれか片方でも構わず，
        また両方書く場合はクラス名オプションを先に書かねばなりません。
        クラス名オプションは先頭の \mcrd`.` を除いた部分が文字列として変数 \mcrd`class` に，
        同様にID名オプションは先頭の \mcrd`#` を除いた部分が文字列として変数 \mcrd`id` に格納されてマクロが適用されます。
        
        マクロ定義中でクラス名オプションの文字列を使用するには，
        まず指定された場合と指定されなかった場合で分岐しなければなりませんから
        
        \code-display{
          \synt`if-class-is-valid` \synt`then` \meta`ExprT` \synt`else` \meta`ExprF`
        }
        
        という分岐を用います。\mcrd`if-class-is-valid` でひとつのトークンであることに注意してください。
        また，\mcrd`then` は省略することができます。
        この分岐に於いて，クラス名オプションが指定されている場合は \code{\meta`ExprT`} が，
        指定されなかった場合は \code{\meta`ExprF`} がそれぞれ評価され，
        このうち \code{\meta`ExprT`} 内でのみ変数 \mcrd`class` を用いることができます。
        \code{\meta`ExprF`} 内や \mcrd`if-class-is-valid` の外で \mcrd`class` が用いられた場合は，
        型検査時にエラーが返されます。ID名オプションも同様に

        \code-display{
          \synt`if-id-is-valid` \synt`then` \meta`ExprT` \synt`else` \meta`ExprF`
        }
        
        で分岐し，\code{\meta`ExprT`} 内でのみ変数 \mcrd`id` を用いることができます。
        使用例としては
        
        \mcrd-input{header.mcrdh}```
          let deeper inner = {\deeper{@inner;}}

          let \p inner = `\indent` ^(deeper inner)^ `\par`

          let \sect sect cont =
            `\section{` ^sect^ `}` ^
              ( if-id-is-valid `\label{`^id^ `}` else {} ) ^
              (deeper cont) ^
            `% ---- ----`
        ```
        \mcrd-input{main.mcrd}```
          \sect{First Title}{
            \p{ The quick brown fox jumps over the lazy dog. }
          }
          \sect #second {Second Title}{
            \p{ My quiz above the kiwi juice needs priceless fixing. }
          }
        ```
        
        から
        
        \mcrd-output{output.txt}```
          \section{First Title}
            \indent
              The quick brown fox jumps over the lazy dog.
            \par
          % ---- ----
          \section{Second Title}\label{second}
            \indent
              My quiz above the kiwi juice needs priceless fixing.
            \par
          % ---- ----
        ```
        
        を得ることができます。
      }
    }
    \subsection{手続き型プログラミング機能}{
      \p{
        これまで函数型プログラミングを基礎に各種機能を紹介してきましたが，
        手続き型プログラミングにあたる機能も存在しています。
        手続き型に洗脳されている皆様におかれましては「なぜそれをもっと早く言わなかったんだ」
        と思われたかもしれませんが，
        手続き的プログラミングは破壊的代入の存在によりいわゆる参照透過性が失われるなど
        相対的に保守を困難にする要素をはらんでいるため，その使用は最小限に留めたいという志向があります。
        といっても，破壊的代入が可能な変数を用いた方がずっと見通しよく処理が書けることも多々あるので，
        これを意図して手続き型の機能を備えつけています。
      }
      \p{
        まず，書き換え可能な変数の宣言は
        
        \code-display{
          \synt`let-mutable` \meta`var` \synt`<-` \meta`ExprA` \synt`in` \meta`ExprB`
        }
        
        で行ないます。こうすると変数 \code{\meta`var`} に \code{\meta`ExprA`} の評価結果が初期値として代入され，
        \code{\meta`ExprB`} をスコープとして使用することができます。
        大域環境では \code{\synt`in` \meta`ExprB`} を書かずに

        \code-display{
          \synt`let-mutable` \meta`var` \synt`<-` \meta`ExprA`
        }
        
        とすることで以降すべての箇所で \code{\meta`var`} を書き換えたり参照したりして使えます。
        このようにして宣言された \code{\meta`var`} は，
        \code{\meta`ExprA`} を\type-synt`'t`型とすると \type-synt`'t ref`型を持ちます。
        参照は通常の変数とは違い \mcrd`!` をつけて \code{\synt`!` \meta`var`} とします。
        また書き換えは \mcrd`<-` を用いて \code{\meta`var` \synt`<-` \meta`Expr`} とします。
        書き換えの式全体は\type-synt`unit`型です。引き続き処理を行なうには
        逐次評価の二項演算子 \mcrd-type`before` `unit -> 'a -> 'a` を用います。
        例えば
        
        \mcrd-input{ref1.mcrds}```
          let-mutable x <- {hoge} in
            (! x) ^ {/} ^ ( x <- {piyo} before (! x) )
        ```
        
        に対する出力は
        
        \mcrd-output{ref1.txt}```
          hoge/piyo
        ```
        
        となります。
      }
      \p{
        ループの機能もあります。\mcrd`while` を用いて
        
        \code-display{
          \synt`while` \meta`ExprB` \synt`do` \meta`ExprC`
        }
        
        と書くと，\code{\meta`ExprB`} が真である間 \code{\meta`ExprC`} を繰り返し評価し，
        \code{\meta`ExprB`} が偽となった時に\type-synt`unit`型の唯一の値を返します。
        これを用いると，例えば\math{1}から\math{n}までの和を求める函数は
        
        \mcrd-input{while.mcrds}```
          let sum n =
            let-mutable i <- 1 in
            let-mutable r <- 0 in
              ( while ! i <= n do
                r <- (! r) + (! i) before i <- (! i) + 1
              ) before ! r

          in arabic (sum 10)
        ```
        \mcrd-output{while.txt}```
          55
        ```
        
        と定義して使うことができます。しかしこの例のような処理は“わざわざ”手続き的に書かなくとも
        
        \mcrd-input{rec.mcrds}```
          let sum n =
            if n <= 0 then 0 else n + (sum (n - 1))
          
          in arabic (sum 10)
        ```
        
        とすれば済む話ではあります。
        手続き的処理がどうしても必要な場面というのは，
        例えば文書の冒頭で宣言的に書かれた情報を文書の途中で使うために書き換え可能変数に保持しておくといった，
        比較的限定された状況なのです。
      }
    }
    \subsection{最終値参照・グローバルハッシュ}{
      \p{（執筆中）}
    }
    \subsection{\type-synt`string`型の実体・2段階評価}{
      \p{（執筆中）}
    }
  }
  \section{字句解析の厳密な仕様}{
    \subsection{概要}{
      \p{
        この章は，Macrodownのより詳細で厳密な仕様が気になるという方に向けた記述です。
        Macrodownは大きく分けて
        \itemize{
          | テキスト階層
          | プログラム階層
          | アクティヴ階層
          | リテラル階層
          | コメント階層
          |}
        を行き来しながらソースコードをトークンとして解釈します。
        文書（拡張子が\extension{.mcrd}のもの）はテキスト階層で読み込みが開始され，一方で
        ヘッダ（拡張子が\extension{.mcrdh}のもの）はプログラム階層で読み込みが開始されます。
      }
    }
    \subsection{テキスト階層}{
      \p{
        マクロではなく文書そのものを書いているときは，
        このテキスト階層を中心に意識していれば良いでしょう。
      }
      \p{
        大小ラテン文字とアラビア数字とハイフンを\newword{基本文字}，その他の文字を\newword{非基本文字}，
        基本文字のみからなり先頭が大小ラテン文字である文字列を\newword{名前文字列}と呼ぶことにすると，
        テキスト階層では文字列を\ref{token-text}に示す規則でマッチするようにトークン化します。
        ただし + は1回以上の繰り返しを表し，また複数通りのマッチがある場合はより長い文字列ほど優先し，
        同一の文字列が複数のトークンにマッチする場合は表で上位に掲げられているものほど優先されます。
      }
      \float-table #token-text {テキスト階層で認識されるトークンとその規則}{
        \description{
          |\d-item{\mcrd`\`（名前文字列）}{\math{\token-cs;}：\newword{制御綴トークン}}
          |\d-item{\mcrd`@`}{\math{\token-varinstr;}：\newword{文字列中変数参照トークン}}
          |\d-item{\mcrd`{`}{\math{\token-bgrp;}：\newword{ブロック開始トークン}}
          |\d-item{\mcrd`}`}{\math{\token-egrp;}：\newword{ブロック終了トークン}・\newword{テキスト終了トークン}}
          |\d-item{\mcrd`|`}{\math{\token-sep;}：\newword{区切りトークン}}
          |\d-item{\mcrd`\`（非基本文字）}{\math{\token-char;}：エスケープされた\newword{文字トークン}}
          |\d-item{\mcrd`` ` ``+}{\math{\token-opnqt;}：\newword{リテラル開始トークン}}
          |\d-item{\mcrd`%`}{\newword{コメント開始トークン}}
          |\d-item{（空白文字）または（タブ文字）}{\math{\token-space;}}：\newword{空白トークン}
          |\d-item{（改行文字）}{\math{\token-break;}}：\newword{改行トークン}
          |\d-item{（1文字）}{\math{\token-char;}：\newword{文字トークン}}
          |}
      }
      \p{
        表からわかるように，
        \mcrd`%`，\mcrd`\`，\mcrd`@`，\mcrd`{`，\mcrd`}`，\mcrd`|`，\mcrd`` ` ``
        はそのまま書くことができず，\mcrd`\` を手前につけてエスケープしなければならない文字です。
      }
      \p{
        ただし，空白文字，タブ文字，改行文字をまとめて\newword{空白類文字}と呼ぶことにすると，
        \itemize{
          | 行頭の空白類文字
          | 空白類文字の直後の空白類文字
          | \mcrd`{` の直後の空白類文字
          | \mcrd`}` の手前に連続して並んでいる空白類文字
          |}
        はいずれも空白トークンおよび改行トークンと認識されることなく読み捨てられます。
        したがって \mcrd`{` の直後での改行やインデントなどを比較的自由に入れることができます。
      }
      \p{
        また制御綴トークンと変数名トークンは，認識されると直後に字句解析器がアクティヴ階層に遷移します。
        同様に，リテラル開始トークンが認識されると直後にリテラル階層に，
        コメント開始トークンが認識されるとこのコメント開始トークンは即座に読み捨てられてコメント階層に遷移します。
        その他のトークンを認識した直後はテキスト階層を維持して次のトークンの認識に移ります。
      }
      \p{
        \mcrd`}` は基本的に\newword{ブロック終了トークン} \math{\token-egrp;} ですが，
        場合によっては\newword{テキスト終了トークン} \math{\token-clsstr;} となります。
        プログラム階層で後述しますが，
        プログラム階層からテキスト階層に入るときに
        \newword{テキスト開始トークン} \math{\token-opnstr;} と扱われた \mcrd`{` と釣り合う \mcrd`}` は
        テキスト終了トークン \math{\token-clsstr;} となり，これが認識されるとテキスト階層を出てプログラム階層に戻ります。
      }
    }
    \subsection{プログラム階層}{
      \p{
        プログラム階層は，\newword{マクロ}や\newword{函数}の定義に用います。
        プログラム階層で認識されるトークンとその規則を\ref{token-program}に示します。
        全体的にML風の構文をとっています。
      }
      \float-table #token-program {プログラム階層で認識されるトークン}{
        \description{
          | \d-item{\mcrd`(`}{
              \math{\token-lparen;}：\newword{開括弧トークン}}
          | \d-item{\mcrd`)`}{
              \math{\token-rparen;}：\newword{閉括弧トークン}・%
              \math{\token-clsprog;}：\newword{プログラム終了トークン}}
          | \d-item{\mcrd`[`}{
              \math{\token-blist;}：\newword{リスト開括弧トークン}}
          | \d-item{\mcrd`]`}{
              \math{\token-elist;}：\newword{リスト閉括弧トークン}}
          | \d-item{\mcrd`;`}{
              \math{\token-listpunct;}：\newword{リスト区切りトークン}}
          | \d-item{（二項演算子）}{
              \math{\token-bin;}：\newword{二項演算子トークン}}
          | \d-item{\mcrd`let`}{
              \math{\token-let;}：\newword{宣言トークン}}
          | \d-item{\mcrd`and`}{
              \math{\token-and;}：\newword{並列宣言トークン}}
          | \d-item{\mcrd`in`}{
              \math{\token-in;}：\newword{inトークン}}
          | \d-item{\mcrd`if`}{
              \math{\token-if;}：\newword{ifトークン}}
          | \d-item{\mcrd`then`}{
              \math{\token-then;}：\newword{thenトークン}}
          | \d-item{\mcrd`else`}{
              \math{\token-else;}：\newword{elseトークン}}
          | \d-item{\mcrd`true`}{
              \math{\token-true;}：\newword{真トークン}}
          | \d-item{\mcrd`false`}{
              \math{\token-true;}：\newword{偽トークン}}
          | \d-item{\mcrd`function`}{
              \math{\token-function;}：\newword{無名函数トークン}}
          | \d-item{\mcrd`->`}{
              \math{\token-arrow;}：\newword{無名函数矢印トークン}}
          | \d-item{\mcrd`if-class-is-valid`}{
              \math{\token-if-class-is-valid;}：\newword{if-class-is-validトークン}}
          | \d-item{\mcrd`if-id-is-valid`}{
              \math{\token-if-id-is-valid;}：\newword{if-id-is-validトークン}}
          | \d-item{\mcrd`let-mutable`}{
              \math{\token-let-mutable;}：\newword{変更可能変数宣言トークン}}
          | \d-item{\mcrd`<-`}{
              \math{\token-oweq;}：\newword{破壊的代入トークン}}
          | \d-item{\mcrd`before`}{
              \math{\token-before;}：\newword{逐次評価トークン}}
          | \d-item{\mcrd`()`}{
              \math{\token-unit;}：\newword{ユニットトークン}}
          | \d-item{\mcrd`while`}{
              \math{\token-while;}：\newword{whileトークン}}
          | \d-item{\mcrd`do`}{
              \math{\token-do;}：\newword{doトークン}}
          | \d-item{\mcrd`new-global-hash`}{
              \math{\token-new-global-hash;}：\newword{ハッシュ宣言トークン}}
          | \d-item{\mcrd`renew-global-hash`}{
              \math{\token-renew-global-hash;}：\newword{ハッシュ変更トークン}}
          | \d-item{\mcrd`<<-`}{
              \math{\token-owhash;}：\newword{ハッシュ代入トークン}}
          | \d-item{（名前文字列）}{
              \math{\token-ident;}：\newword{項トークン}}
          | \d-item{（整数文字列）}{
              \math{\token-int;}：\newword{整数トークン}}
          | \d-item{\mcrd`{`}{
              \math{\token-opnstr;}：\newword{テキスト開始トークン}}
          | \d-item{\mcrd`` ` ``}{
              \math{\token-opnqt;}：\newword{リテラル開始トークン}}
          | \d-item{\mcrd`%`}{\newword{コメント開始トークン}}
          |}
      }
      \p{
        \mcrd`{` を見つけてテキスト開始トークン \math{\token-opnstr;} と認識すると，直後にテキスト階層に入ります。
        テキスト階層で釣り合う \mcrd`}` を見つけると，それをテキスト終了トークン \math{\token-clsstr;} とみなして
        再びプログラム階層に戻ってきます。
      }
      \p{
        \mcrd`)` は基本的に\newword{閉括弧トークン} \math{\token-rparen;} となりますが，
        アクティヴ階層で \mcrd`(` をプログラム開始トークン \math{\token-opnprog;} と認識してプログラム階層に入ってきていたとき，
        釣り合う \mcrd`)` を\newword{プログラム終了トークン} \math{\token-clsprog;} と認識し，直後にアクティヴ階層に戻ります。
      }
      \p{
        finishトークン \math{\token-finish;} はヘッダファイルを終了させるトークンで，
        ユーザーは入力できず，大域環境の末尾に自動的に附加されます。
        これが評価されたときの環境が次のファイルの読み込みに引き継がれます。
      }
    }
    \subsection{アクティヴ階層}{
      \p{
        アクティヴ階層は，
        テキスト階層内で制御綴トークンと変数名トークン直後にのみ現れる，
        テキスト階層から出ることなく整数値などを扱うための例外的な部分です。
        とは言いつつも文書中で直接プログラムを書くということは普通避けたいので，
        実際には整数値をマクロに引数として渡すなど短い記述で完結することがほとんどです。
        トークンの認識規則を\ref{token-active}に示します。
      }
      \float-table #token-active {アクティヴ階層で認識されるトークンとその規則}{
        \description{
          | \d-item{\mcrd`(`}{
              \math{\token-opnprog;}：\newword{プログラム開始トークン}}
          | \d-item{\mcrd`#`（名前文字列）}{
              \math{\token-id;}：\newword{ID名トークン}}
          | \d-item{\mcrd`.`（名前文字列）}{
              \math{\token-class;}：\newword{クラス名トークン}}
          | \d-item{\mcrd`{`}{
              \math{\token-bgrp;}：\newword{ブロック開始トークン}}
          | \d-item{\mcrd`` ` ``}{
              \math{\token-opnqt;}：\newword{リテラル開始トークン}}
          |}
      }
      \p{
        \mcrd`(` を読んでプログラム開始トークン \math{\token-opnprog;} を認識すると，直後にプログラム階層に入ります。
        プログラム階層内で釣り合う \mcrd`)` を読むと，これをプログラム終了トークン \math{\token-clsprog;} と認識して
        直後にアクティヴ階層に戻ってきます。
        これにより制御綴の引数として文字列だけでなく整数値などを扱うことができるようになっています。
      }
      \p{
        \mcrd`{` を読んでブロック開始トークン \math{\token-bgrp;} を認識すると，直後にアクティヴ階層を出てテキスト階層に戻ります。
        同様にリテラル開始トークン \math{\token-opnqt;} を認識すると
        直後にアクティヴ階層を出てさらに即座にリテラル階層に入り，
        リテラル階層を出るとテキスト階層に戻ります。
        つまり，アクティヴ階層は最初に現れる \mcrd`{` か \mcrd`` ` `` で終了するということになります。
      }
    }
    \subsection{リテラル階層}{
      \p{
        リテラル階層は書いた文字列をそのまま出力するための特殊なブロックです。
        \mcrd`` ` `` が\math{n}個連なる文字列をそのまま出したい場合，\math{n + 1} 個以上で左右同数の
        \mcrd`` ` `` で括るとリテラル階層となります。
        したがって，リテラル階層は入ってきたときのリテラル開始トークンと同じ個数の
        連続した \mcrd`` ` `` を認識するともともといた階層に戻る，という動作をします。
        「文字列をそのまま出力する」と言いつつも，
        インデントは空白文字でも改行文字でもない文字を含む最もインデントの浅い行に合わせて削られ，
        さらに先頭の空白文字が0文字以上連続した部分および
        末尾の改行文字1文字以下と空白文字0文字以上が連続した部分は削除されるので注意してください。
      }
    }
    \subsection{コメント階層}{
      \p{
        コメント階層では，改行文字が現れるまで全ての文字を読み飛ばします。
        そして改行文字を認識すると，
        その改行文字も含めてそこまでがコメントだったとしてコメント階層を離れ，
        入る前にいたもとの階層に戻ります。
        特にテキスト階層からコメント階層に入ってきて再びテキスト階層に戻るとき，
        改行文字は出力されず，
        さらにコメント階層から抜けた直後は行頭なので空白類文字が無視されることに注意してください。
      }
    }
  }
  \section{構文解析の厳密な仕様}{
    \p{
      Macrodownは字句解析が終了した後に構文解析に移ります。
      文法は以下のBNFで表されます。
      拡張子が\extension{.mcrd}である文書は \math{\Text;} で表現される文字列を，
      拡張子が\extension{.mcrdh}であるヘッダおよび拡張子が\extension{.mcrds}である単独ファイルは
      \math{\TopLevel;} で表現される文字列を
      それぞれ受理します。ただし，結合順序は適切に定まっているものとします。
      \math-dp-gather{
        | \cfl{\TopLevel;}{|  \repeat-plus{\TopSingle;} \cfl-or{|\token-in; \Expr; | \epsilon; |} |}
        | \cfl{\TopSingle;}{
            | \token-let; \Dec; \repeat-star{\token-and; \Dec;}
            | \token-mutual; \repeat-plus{\token-let; \Dec;} \token-end-mutual;
            |}
        | \cfl{\Expr;}{
            | \token-let; \Dec; \repeat-star{\token-and; \Dec;} \token-in; \Expr;
            |*br*
            | \token-if; \Expr; \token-then; \Expr; \token-else; \Expr;
            |*br*
            | \token-function; \Args; \token-arrow; \Expr;
            |*br*
            | \Expr; \token-bin; \Expr; | \Expr; \Expr;
            | \token-ident;
            | \token-lparen; \Expr; \token-rparen;
            |*br*
            | \GroupInExpr; | \token-int; | \token-true; | \token-false; | \token-unit; | \token-finish;
            |*br*
            | \token-let-mutable; \token-ident; \token-oweq; \Expr; \token-in; \Expr;
            | \token-ident; \token-oweq; \Expr;
            |*br*
            | \token-while; \Expr; \token-do; \Expr;
            | \Expr; \token-before; \Expr;
            |*br*
            | \token-if-class-is-valid; \cfl-or{|\epsilon;|\token-then;|} \Expr; \token-else; \Expr;
            |*br*
            | \token-if-id-is-valid; \cfl-or{|\epsilon;|\token-then;|} \Expr; \token-else; \Expr;
            |*br*
            | \token-new-global-hash; \Expr; \token-owhash; \Expr;
            |*br*
            | \token-renew-global-hash; \Expr; \token-owhash; \Expr;
            |}
        | \cfl{\Dec;}{| \cfl-or{|\token-ident;|\token-cs;|} \Args; \token-defeq; \Expr; |}
        | \cfl{\Args;}{| \repeat-star{\token-ident;} |}
        | \cfl{\Text;}{| \repeat-star{\Single;} |}
        | \cfl{\Single;}{
            | \token-char; | \token-space; | \token-break;
            | \token-varinstr; \token-ident; \token-end;
            |*br*
            | \token-cs; \cfl-or{| \epsilon; | \token-class; |} \cfl-or{| \epsilon; | \token-id; |} \ExprArgs; \TextArgs;
            |}
        | \cfl{\ExprArgs;}{| \repeat-star{\token-opnprog; \Expr; \token-clsprog;} |}
        | \cfl{\TextArgs;}{| \token-end; | \repeat-plus{ \GroupInText; } |}
        | \cfl{\GroupInText;}{| \token-bgrp; \Text; \token-egrp; | \token-opnqt; \Literal; \token-clsqt; |}
        | \cfl{\GroupInExpr;}{| \token-opnstr; \Text; \token-clsstr; | \token-opnqt; \Literal; \token-clsqt; |}
        |}
    }
  }
}
