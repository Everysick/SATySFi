\document{
  \settings;
  \title{Macrodown (\version;)}
  \author{\twitter-at-id{bd_gfngfn}}
}{
  \maketitle;
  \section{概要}{
    \p{
      \newword{Macrodown}（\newword{マクロダウン}）は
      「マークアップの記述においてはマークアップ方法自体もユーザが設計できるべきである」
      という思想のもとに制作された，
      \LaTeX;やHTMLなどのマークアップ言語をラップするための軽量［要出典］マークアップ言語です。
      OCamlで実装しており，ソースコードは

      \url-display{http://github.com/gfngfn/Macrodown}

      で公開しています。この文書もMacrodownを経由してHTMLソースコードと\LaTeX;ソースコードを出力し，
      \LaTeX;ソースコードの方は\pLaTeX2e;とdvipdfmxで組んでいます。
    }
  }
  \section{動機}{
    \p{
      今日，一般的な文書作成のために多用されているマークアップ言語としては
      HTML+CSSや\LaTeX;などが挙げられます。
      しかし，このHTML+CSSと\LaTeX;は一長一短です。
    }
    \p{
      HTML+CSSは構造と体裁がよく分離されており，CSSによる体裁の変更等も柔軟ですが，
      記法が冗長で，またマクロ定義機能も存在していない\footnote{おそらく意図的に取り入れられていないのでしょう。}ため，
      直接人間の手で文書を記述するには適しているとは思えません。
      Markdown，AsciiDoc，その他ローカルなWiki記法など，HTMLを専用にラップする軽量マークアップ言語も数多くありますが，
      用途が限られている傾向にあり，表現力は乏しいと言わざるを得ないでしょう。
    }
    \p{
      一方の\LaTeX;は比較的平易な記法でマクロ定義機能が備わっており，先達による高度なパッケージも充実し，
      そして何よりもソフトウェアとしての\TeX;が高品質な組版結果を出力してくれますが，
      構造と体裁が明示的に分離されていないため体裁を扱うには或る程度のリテラシーが必要であったり，
      柔軟なマクロを創るには\TeX; on \LaTeX;の知識が必要で，これが相当非直感的な仕様であるため，
      大多数の人を寄せつけない様相を呈しています。
    }
    \p{
      これらの欠点を解決し，またWebページとPDFを共通の規格で記述できるようにすべく，
      Macrodownの制作に手をつけました。
      記法は“OCamlと\LaTeX;のハーフ”であり，
      “意味論が綺麗な\LaTeX;的記法”を目指したといってもよいかもしれません。
    }
  }
  \section{実用的な例}{
    \subsection{クラス名・ID名オプション}{
      \p{
        クラス名・ID名オプション機能を使うと，
        例えば

        \mcrd-display```
          \div{The quick brown fox jumps over the lazy dog.}
          \div .quote {色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。}
          \div .quote #tori {鳥啼く声す，夢覚ませ。見よ明け亘る，東を。}
        ```

        から

        \mcrd-display```
          <div>
            The quick brown fox jumps over the lazy dog.
          </div>
          <div class="quote">
            色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。
          </div>
          <div class="quote" id="tori">
            鳥啼く声す，夢覚ませ。見よ明け亘る，東を。
          </div>
        ```
            %有為の奥山今日越えて，浅き夢見じ，酔いもせず。
            %空色映えて，沖つ辺に，帆船群れゐぬ，靄の内。

        を得るようなマクロ\code{\synt`\div`}を定義することができます。
        クラス名・ID名オプション機能はHTMLの影響で実装したものですが，
        HTMLに限らず「マークアップ上大きな意味はないが小さい分岐をさせたいとき」に利用できます。
        函数・マクロ定義の項目で後述します。
      }
    }
    \subsection{自動番号づけ・相互参照}{
      \p{
        Macrodownには強力な相互参照を実装できる機能があり，例えば
        
        \mcrd-display```
          \section{はじめに}{
            \p{後方参照の例です。\ref{next}の番号を前方で取得できます。}
          }
          \section #next {サンプル}{
            \p{参照される側にはIDをつけておけばOK!}
          }
        ```

        に対する出力として

        \mcrd-display```
          <section>
            <h1>第1章 はじめに</h1>
              <p>
                後方参照の例です。第2章の番号を前方で取得できます。
              </p>
            <!-- ---- ---- ---- ---- -->
          </section>
          <section id="next">
            <h1>第2章 サンプル</h1>
              <p>
                参照される側にはIDをつけておけばOK!
              </p>
            <!-- ---- ---- ---- ---- -->
          </section>
        ```

        を得るようなマクロ\mcrd`\section`，\mcrd`\ref`を定義することが可能です。
        \LaTeX;ではこのような相互参照は更新するたびに2回タイプセットしなければ正当に出力されませんが，
        Macrodownのテキスト整形では1度で正当な相互参照を出力することができます。
      }
    }
  }
  \section{変数・函数・マクロ}{
    \subsection{基礎}{
      \p{
        Macrodownは手続き的記述よりも函数的記述に特化しています。
        変数には基本的に破壊的代入の機能がなく，
        したがって純粋函数型プログラミングに近い性質をしています。
      }
      \p{
        函数とマクロは基本的にほとんど同様に扱えるもので，
        単に制御綴で書かれるものをマクロ，
        制御綴でない普通の変数名のように書かれるものを函数と便宜的に呼び分けているだけです。
        制御綴はテキスト階層で，函数はプログラム階層で用いるようになっています。
        以降はプログラム階層を基本にして例を掲げていきましょう。
        したがって，慣れるまではヘッダファイルのみを処理することがしばらく続きます。
      }
      \p{
        以下のような\newword{定義式}

        \code-dp{
          \synt`let` \meta{hoge} %
            \meta{nvar1} \metadots; \meta{nvarN}
            \synt`=` \meta{ExprA} \synt`in` \meta{ExprB}
        }

        および

        \code-dp{
          \synt`let` \synt`\`\meta{piyo} %
            \meta{var1} \metadots; \meta{varN}
            \synt`=` \meta{ExprA} \synt`in` \meta{ExprB}
        }

        で引数を\math{N}個伴う函数\code{\meta{hoge}}およびマクロ\code{\synt`\`\meta{piyo}}
        が定義されます。
        なお，普通積極的には用いませんが，名前のない函数は

        \code-dp{
          \synt`(function` \meta{nv1} \metadots; \meta{nvN}
          \synt`->` \meta{Expr} \synt`)`
        }

        で表現することができます。例えば与えられた整数を2乗する函数は
        \mcrd`(function n -> n * n)`です。

        \code-dp{
          \synt`\`\meta{hoge}\ %
            \synt`{`\meta{Arg1}\synt`}`\metadots;\synt`{`\meta{ArgN}\synt`}`
        }

        で各\code{\meta{varI}}に\code{\meta{ArgI}}が格納された上で定義式の\code{\meta{Expr}}が評価されます。
        変数\code{\meta{piyo}}に格納された中身をテキスト階層中で取り出すには
        \code{\synt`@`\meta{piyo}\synt`;`}とします。例えば

        \mcrd-file{test.mcrds}```
          let \test x y = {Ma@x;r@y;down} in
            {\test{c}{o}, \test{}{k}}
        ```

        に対する出力は

        \mcrd-file{test.txt}```
          Macrodown, Markdown
        ```

        となります。引数のないマクロも定義でき，これは使用時にセミコロンをつけます。例えば

        \mcrd-file{no-arg.mcrds}```
          let \mcrd = {Macrodown} in {Hello, \mcrd;!}
        ```

        に対する出力は

        \mcrd-file{no-arg.txt}```
          Hello, Macrodown!
        ```

        となります。
      }
    }
    \subsection{リスト}{
      \p{
        具体的なリストは，基本的に
        
        \mcrd-display```
          [3; 1; 4; 1; 5; 9; 2]
        ```

        のように\code{\synt`[`}と\code{\synt`]`}で括って各要素を\code{\synt`;`}で区切って書きます。
        リストでは，全ての要素の型が一致していなければなりません。
        \type-synt{'t}型の要素を持つリストの型は\type-synt{'t list}であり，
        例えば\type-synt{int}型のリストは\type-synt{int list}型になります。
        なお，実際に文書中のテキスト階層で用いるリストの多くは
        \type-synt{string list}型のリストをマクロの引数とする場合ですが，これは

        \mcrd-display```
          \somecs([{hoge}; {piyo}; {fuga}; {moge}]);
        ```

        と複雑に入り組んだ書き方をせずとも

        \mcrd-display```
          \somecs{|hoge|piyo|fuga|moge|}
        ```

        と省略して書くことができます。
        プログラム階層でも\mcrd`{|hoge|piyo|fuga|moge|}`で
        \mcrd`[{hoge}; {piyo}; {fuga}; {moge}]`の省略として使えます。
      }
      \p{
        リストの要素を取り出す操作を見ていきましょう。
        まずリストの先頭要素を取り出す函数が\mcrd-type`list-head`{'a list -> 'a}，
        先頭を除いたリストを得る函数が\mcrd-type`list-tail`{'a list -> 'a list}です。
        例えば\mcrd`list-head [2; 4; 6; 9; 11]`は\mcrd`2`に，
        \mcrd`list-tail [2; 4; 6; 9; 11]`は\mcrd`[4; 6; 9; 11]`にそれぞれ評価されます。
      }
      \p{
        では，\mcrd`list-head`および\mcrd`list-tail`に空のリスト\mcrd`[]`を渡すとどうなるかというと，
        これは実行時エラーで終了してしまいます。
        そこで，リストが空かどうか判定する函数\mcrd-type`is-empty`{'a list -> bool}を使うことになります。
      }
      \p{
        リストを再帰的に扱う例を見てみましょう。
        \type-synt{string list}型の値を受け取り，
        各要素をHTMLのリストの項目として並べたものを返すマクロ
        \mcrd-type`\ul`{string list -> string}を定義します。

        \mcrd-file{ul.mcrdh}```
          let sub-ul lst =
            if is-empty lst then {} else
              let hd = list-head lst in
              let tl = list-tail lst in
                {<li class="list-content">@head;</li>\break;} ^ (sub-ul tl)
          in
          let \ul lst = {<ul>\deeper(sub-ul lst);</ul>}
          in finish
        ```
        \mcrd-file{main.mcrd}```
          \ul{|hoge|piyo|fuga|moge|}
        ```

        に対して\mcrd`macrodown ul.mcrdh main.mcrd -o main.txt`で処理した出力は
        
        \mcrd-file{main.txt}```
          <ul>
            <li class="list-content">hoge</li>
            <li class="list-content">piyo</li>
            <li class="list-content">fuga</li>
            <li class="list-content">moge</li>
          </ul>
        ```

        となります。ここで挙げた例は4要素のリストですが，
        実際の文書を記述するにあたってはもっと長いリストも登場することでしょう。
        そのように何度も同じ記述が繰り返される場合，すべて手で打つのではなく，
        共通部分は再帰的なマクロ定義に含ませて，異なる部分をリストの各要素として与えることにより，
        効率的にマークアップすることができます。
      }
    }
  }
  \section{字句解析の厳密な仕様}{
    \subsection{概要}{
      \p{
        Macrodownは大きく分けて
        \itemize{
          | テキスト階層
          | プログラム階層
          | アクティヴ階層
          | リテラル階層
          | コメント階層
          |}
        を行き来しながらソースコードをトークンとして解釈します。
        文書（拡張子が.mcrdのもの）はテキスト階層で読み込みが開始され，一方で
        ヘッダ（拡張子が.mcrdhのもの）はプログラム階層で読み込みが開始されます。
      }
    }
    \subsection{テキスト階層}{
      \p{
        マクロではなく文書そのものを書いているときは，
        このテキスト階層を中心に意識していれば良いでしょう。
      }
      \p{
        大小ラテン文字とアラビア数字とハイフンを\newword{基本文字}，その他の文字を\newword{非基本文字}，
        基本文字のみからなり先頭が大小ラテン文字である文字列を\newword{名前文字列}と呼ぶことにすると，
        テキスト階層では文字列を\ref{token-text}に示す規則でマッチするようにトークン化します。
        ただし + は1回以上の繰り返しを表し，また複数通りのマッチがある場合はより長い文字列ほど優先し，
        同一の文字列が複数のトークンにマッチする場合は表で上位に掲げられているものほど優先されます。
      }
      \float-table #token-text {テキスト階層で認識されるトークンとその規則}{
        \description{
          |\d-item{\mcrd`\`（名前文字列）}{\math{\token-cs;}：\newword{制御綴トークン}}
          |\d-item{\mcrd`@`}{\math{\token-varinstr;}：\newword{文字列中変数参照トークン}}
          |\d-item{\mcrd`{`}{\math{\token-bgrp;}：\newword{ブロック開始トークン}}
          |\d-item{\mcrd`}`}{\math{\token-egrp;}：\newword{ブロック終了トークン}・\newword{テキスト終了トークン}}
          |\d-item{\mcrd`|`}{\math{\token-sep;}：\newword{区切りトークン}}
          |\d-item{\mcrd`\`（非基本文字）}{\math{\token-char;}：エスケープされた\newword{文字トークン}}
          |\d-item{\mcrd`` ` ``+}{\math{\token-opnqt;}：\newword{リテラル開始トークン}}
          |\d-item{\mcrd`%`}{\newword{コメント開始トークン}}
          |\d-item{（空白文字）または（タブ文字）}{\math{\token-space;}}：\newword{空白トークン}
          |\d-item{（改行文字）}{\math{\token-break;}}：\newword{改行トークン}
          |\d-item{（1文字）}{\math{\token-char;}：\newword{文字トークン}}
          |}
      }
      \p{
        表からわかるように，
        \mcrd`%`，\mcrd`\`，\mcrd`@`，\mcrd`{`，\mcrd`}`，\mcrd`|`，\mcrd`` ` ``
        はそのまま書くことができず，\mcrd`\` を手前につけてエスケープしなければならない文字です。
      }
      \p{
        ただし，空白文字，タブ文字，改行文字をまとめて\newword{空白類文字}と呼ぶことにすると，
        \itemize{
          | 行頭の空白類文字
          | 空白類文字の直後の空白類文字
          | \mcrd`{` の直後の空白類文字
          | \mcrd`}` の手前に連続して並んでいる空白類文字
          |}
        はいずれも空白トークンおよび改行トークンと認識されることなく読み捨てられます。
        したがって \mcrd`{` の直後での改行やインデントなどを比較的自由に入れることができます。
      }
      \p{
        また制御綴トークンと変数名トークンは，認識されると直後に字句解析器がアクティヴ階層に遷移します。
        同様に，リテラル開始トークンが認識されると直後にリテラル階層に，
        コメント開始トークンが認識されるとこのコメント開始トークンは即座に読み捨てられてコメント階層に遷移します。
        その他のトークンを認識した直後はテキスト階層を維持して次のトークンの認識に移ります。
      }
      \p{
        \mcrd`}` は基本的に\newword{ブロック終了トークン} \math{\token-egrp;} ですが，
        場合によっては\newword{テキスト終了トークン} \math{\token-clsstr;} となります。
        プログラム階層で後述しますが，
        プログラム階層からテキスト階層に入るときに
        \newword{テキスト開始トークン} \math{\token-opnstr;} と扱われた \mcrd`{` と釣り合う \mcrd`}` は
        テキスト終了トークン \math{\token-clsstr;} となり，これが認識されるとテキスト階層を出てプログラム階層に戻ります。
      }
    }
    \subsection{プログラム階層}{
      \p{
        プログラム階層は，\newword{マクロ}や\newword{函数}の定義に用います。
        プログラム階層で認識されるトークンとその規則を\ref{token-program}に示します。
        全体的にML風の構文をとっています。
      }
      \float-table #token-program {プログラム階層で認識されるトークン}{
        \description{
          | \d-item{\mcrd`(`}{
              \math{\token-lparen;}：\newword{開括弧トークン}}
          | \d-item{\mcrd`)`}{
              \math{\token-rparen;}：\newword{閉括弧トークン}・%
              \math{\token-clsprog;}：\newword{プログラム終了トークン}}
          | \d-item{\mcrd`[`}{
              \math{\token-blist;}：\newword{リスト開括弧トークン}}
          | \d-item{\mcrd`]`}{
              \math{\token-elist;}：\newword{リスト閉括弧トークン}}
          | \d-item{\mcrd`;`}{
              \math{\token-listpunct;}：\newword{リスト区切りトークン}}
          | \d-item{（二項演算子）}{
              \math{\token-bin;}：\newword{二項演算子トークン}}
          | \d-item{\mcrd`let`}{
              \math{\token-let;}：\newword{宣言トークン}}
          | \d-item{\mcrd`and`}{
              \math{\token-and;}：\newword{並列宣言トークン}}
          | \d-item{\mcrd`in`}{
              \math{\token-in;}：\newword{inトークン}}
          | \d-item{\mcrd`if`}{
              \math{\token-if;}：\newword{ifトークン}}
          | \d-item{\mcrd`then`}{
              \math{\token-then;}：\newword{thenトークン}}
          | \d-item{\mcrd`else`}{
              \math{\token-else;}：\newword{elseトークン}}
          | \d-item{\mcrd`true`}{
              \math{\token-true;}：\newword{真トークン}}
          | \d-item{\mcrd`false`}{
              \math{\token-true;}：\newword{偽トークン}}
          | \d-item{\mcrd`function`}{
              \math{\token-function;}：\newword{無名函数トークン}}
          | \d-item{\mcrd`->`}{
              \math{\token-arrow;}：\newword{無名函数矢印トークン}}
          | \d-item{\mcrd`if-class-is-valid`}{
              \math{\token-if-class-is-valid;}：\newword{if-class-is-validトークン}}
          | \d-item{\mcrd`if-id-is-valid`}{
              \math{\token-if-id-is-valid;}：\newword{if-id-is-validトークン}}
          | \d-item{\mcrd`let-mutable`}{
              \math{\token-let-mutable;}：\newword{変更可能変数宣言トークン}}
          | \d-item{\mcrd`<-`}{
              \math{\token-oweq;}：\newword{破壊的代入トークン}}
          | \d-item{\mcrd`before`}{
              \math{\token-before;}：\newword{逐次評価トークン}}
          | \d-item{\mcrd`()`}{
              \math{\token-unit;}：\newword{ユニットトークン}}
          | \d-item{\mcrd`while`}{
              \math{\token-while;}：\newword{whileトークン}}
          | \d-item{\mcrd`do`}{
              \math{\token-do;}：\newword{doトークン}}
          | \d-item{\mcrd`new-global-hash`}{
              \math{\token-new-global-hash;}：\newword{ハッシュ宣言トークン}}
          | \d-item{\mcrd`renew-global-hash`}{
              \math{\token-renew-global-hash;}：\newword{ハッシュ変更トークン}}
          | \d-item{\mcrd`<<-`}{
              \math{\token-owhash;}：\newword{ハッシュ代入トークン}}
          | \d-item{\mcrd`finish`}{
              \math{\token-finish;}：\newword{finishトークン}}
          | \d-item{（名前文字列）}{
              \math{\token-ident;}：\newword{項トークン}}
          | \d-item{（整数文字列）}{
              \math{\token-int;}：\newword{整数トークン}}
          | \d-item{\mcrd`{`}{
              \math{\token-opnstr;}：\newword{テキスト開始トークン}}
          | \d-item{\mcrd`` ` ``}{
              \math{\token-opnqt;}：\newword{リテラル開始トークン}}
          | \d-item{\mcrd`%`}{\newword{コメント開始トークン}}
          |}
      }
      \p{
        \mcrd`{` を見つけてテキスト開始トークン \math{\token-opnstr;} と認識すると，直後にテキスト階層に入ります。
        テキスト階層で釣り合う \mcrd`}` を見つけると，それをテキスト終了トークン \math{\token-clsstr;} とみなして
        再びプログラム階層に戻ってきます。
      }
      \p{
        \mcrd`)` は基本的に\newword{閉括弧トークン} \math{\token-rparen;} となりますが，
        アクティヴ階層で \mcrd`(` をプログラム開始トークン \math{\token-opnprog;} と認識してプログラム階層に入ってきていたとき，
        釣り合う \mcrd`)` を\newword{プログラム終了トークン} \math{\token-clsprog;} と認識し，直後にアクティヴ階層に戻ります。
      }
      \p{
        finishトークン \math{\token-finish;} はヘッダファイルを終了させるトークンで，
        これが評価されたときの環境が次のファイルの読み込みに引き継がれます。
      }
    }
    \subsection{アクティヴ階層}{
      \p{
        アクティヴ階層は，
        テキスト階層内で制御綴トークンと変数名トークン直後にのみ現れる，
        テキスト階層から出ることなく整数値などを扱うための例外的な部分です。
        とは言いつつも文書中で直接プログラムを書くということは普通避けたいので，
        実際には整数値をマクロに引数として渡すなど短い記述で完結することがほとんどです。
        トークンの認識規則を\ref{token-active}に示します。
      }
      \float-table #token-active {アクティヴ階層で認識されるトークンとその規則}{
        \description{
          | \d-item{\mcrd`(`}{
              \math{\token-opnprog;}：\newword{プログラム開始トークン}}
          | \d-item{\mcrd`#`（名前文字列）}{
              \math{\token-id;}：\newword{ID名トークン}}
          | \d-item{\mcrd`.`（名前文字列）}{
              \math{\token-class;}：\newword{クラス名トークン}}
          | \d-item{\mcrd`{`}{
              \math{\token-bgrp;}：\newword{ブロック開始トークン}}
          | \d-item{\mcrd`` ` ``}{
              \math{\token-opnqt;}：\newword{リテラル開始トークン}}
          |}
      }
      \p{
        \mcrd`(` を読んでプログラム開始トークン \math{\token-opnprog;} を認識すると，直後にプログラム階層に入ります。
        プログラム階層内で釣り合う \mcrd`)` を読むと，これをプログラム終了トークン \math{\token-clsprog;} と認識して
        直後にアクティヴ階層に戻ってきます。
        これにより制御綴の引数として文字列だけでなく整数値などを扱うことができるようになっています。
      }
      \p{
        \mcrd`{` を読んでブロック開始トークン \math{\token-bgrp;} を認識すると，直後にアクティヴ階層を出てテキスト階層に戻ります。
        同様にリテラル開始トークン \math{\token-opnqt;} を認識すると
        直後にアクティヴ階層を出てさらに即座にリテラル階層に入り，
        リテラル階層を出るとテキスト階層に戻ります。
        つまり，アクティヴ階層は最初に現れる \mcrd`{` か \mcrd`` ` `` で終了するということになります。
      }
    }
    \subsection{リテラル階層}{
      \p{
        リテラル階層は書いた文字列をそのまま出力するための特殊なブロックです。
        \mcrd`` ` `` が\math{n}個連なる文字列をそのまま出したい場合，\math{n + 1} 個以上で左右同数の
        \mcrd`` ` `` で括るとリテラル階層となります。
        したがって，リテラル階層は入ってきたときのリテラル開始トークンと同じ個数の
        連続した \mcrd`` ` `` を認識するともともといた階層に戻る，という動作をします。
        「文字列をそのまま出力する」と言いつつも，
        インデントは空白文字でも改行文字でもない文字を含む最もインデントの浅い行に合わせて削られ，
        さらに先頭の空白文字が0文字以上連続した部分および
        末尾の改行文字1文字以下と空白文字0文字以上が連続した部分は削除されるので注意してください。
      }
    }
    \subsection{コメント階層}{
      \p{
        コメント階層では，改行文字が現れるまで全ての文字を読み飛ばします。
        そして改行文字を認識すると，
        その改行文字も含めてそこまでがコメントだったとしてコメント階層を離れ，
        入る前にいたもとの階層に戻ります。
        特にテキスト階層からコメント階層に入ってきて再びテキスト階層に戻るとき，
        改行文字は出力されず，
        さらにコメント階層から抜けた直後は行頭なので空白類文字が無視されることに注意してください。
      }
    }
  }
  \section{構文解析の厳密な仕様}{
    \p{
      Macrodownは字句解析が終了した後に構文解析に移ります。
      文法は以下のBNFで表されます。
      拡張子が.mcrdである文書は \math{\Text;} で表現される文字列を，
      拡張子が.mcrdhであるヘッダおよび拡張子が.mcrdsである単独ファイルは \math{\TopLevel;} で表現される文字列を
      それぞれ受理します。ただし，結合順序は適切に定まっているものとします。
      \math-dp-gather{
        | \cfl{\TopLevel;}{|  \repeat-plus{\TopSingle;} \cfl-or{|\token-in; \Expr; | \epsilon; |} |}
        | \cfl{\TopSingle;}{
            | \token-let; \Dec; \repeat-star{\token-and; \Dec;}
            | \token-mutual; \repeat-plus{\token-let; \Dec;} \token-end-mutual;
            |}
        | \cfl{\Expr;}{
            | \token-let; \Dec; \repeat-star{\token-and; \Dec;} \token-in; \Expr;
            |*br*
            | \token-if; \Expr; \token-then; \Expr; \token-else; \Expr;
            |*br*
            | \token-function; \Args; \token-arrow; \Expr;
            |*br*
            | \Expr; \token-bin; \Expr; | \Expr; \Expr;
            | \token-ident;
            | \token-lparen; \Expr; \token-rparen;
            |*br*
            | \GroupInExpr; | \token-int; | \token-true; | \token-false; | \token-unit; | \token-finish;
            |*br*
            | \token-let-mutable; \token-ident; \token-oweq; \Expr; \token-in; \Expr;
            | \token-ident; \token-oweq; \Expr;
            |*br*
            | \token-while; \Expr; \token-do; \Expr;
            | \Expr; \token-before; \Expr;
            |*br*
            | \token-if-class-is-valid; \cfl-or{|\epsilon;|\token-then;|} \Expr; \token-else; \Expr;
            |*br*
            | \token-if-id-is-valid; \cfl-or{|\epsilon;|\token-then;|} \Expr; \token-else; \Expr;
            |*br*
            | \token-new-global-hash; \Expr; \token-owhash; \Expr;
            |*br*
            | \token-renew-global-hash; \Expr; \token-owhash; \Expr;
            |}
        | \cfl{\Dec;}{| \cfl-or{|\token-ident;|\token-cs;|} \Args; \token-defeq; \Expr; |}
        | \cfl{\Args;}{| \repeat-star{\token-ident;} |}
        | \cfl{\Text;}{| \repeat-star{\Single;} |}
        | \cfl{\Single;}{
            | \token-char;
            | \token-varinstr; \token-ident; \token-end;
            | \token-cs; \cfl-or{| \epsilon; | \token-class; |} \cfl-or{| \epsilon; | \token-id; |} \ExprArgs; \TextArgs;
            |}
        | \cfl{\ExprArgs;}{| \repeat-star{\token-opnprog; \Expr; \token-clsprog;} |}
        | \cfl{\TextArgs;}{| \token-end; | \repeat-plus{ \GroupInText; } |}
        | \cfl{\GroupInText;}{| \token-bgrp; \Text; \token-egrp; | \token-opnqt; \Literal; \token-clsqt; |}
        | \cfl{\GroupInExpr;}{| \token-opnstr; \Text; \token-clsstr; | \token-opnqt; \Literal; \token-clsqt; |}
        |}
    }
  }
}
