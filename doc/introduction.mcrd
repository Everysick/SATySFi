\document{
  \settings;
  \title{Macrodown (ver. 0.99) の仕様}
  \author{gfn}
}{
  \maketitle;
  \section{概要}{
    \p{
      \newword{Macrodown}（\newword{マクロダウン}）は
      「マークアップの記述においてはマークアップ方法自体もユーザが設計できるべきである」
      という思想のもとに制作された，
      \LaTeX;やHTMLなどのマークアップ言語をラップするための軽量［要出典］マークアップ言語です。
      OCamlで実装しており，ソースコードは

      \url-display{http://github.com/gfngfn/Macrodown}

      で公開しています。この文書もMacrodownを経由してHTMLソースコードと\LaTeX;ソースコードを出力し，
      \LaTeX;ソースコードの方は\pLaTeX2e;とdvipdfmxで組んでいます。
    }
  }
  \section{動機}{
    \p{
      今日，一般的な文書作成のために多用されているマークアップ言語としては
      HTML+CSSや\LaTeX;などが挙げられます。
      しかし，このHTML+CSSと\LaTeX;は一長一短です。
    }
    \p{
      HTML+CSSは構造と体裁がよく分離されており，CSSによる体裁の変更等も柔軟ですが，
      記法が冗長で，またマクロ定義機能も存在していない\footnote{おそらく意図的に取り入れられていないのでしょう。}ため，
      直接人間の手で文書を記述するには適しているとは思えません。
      Markdown，AsciiDoc，その他ローカルなWiki記法など，HTMLを専用にラップする軽量マークアップ言語も数多くありますが，
      用途が限られている傾向にあり，表現力は乏しいと言わざるを得ないでしょう。
    }
    \p{
      一方の\LaTeX;は比較的平易な記法でマクロ定義機能が備わっており，先達による高度なパッケージも充実し，
      そして何よりもソフトウェアとしての\TeX;が高品質な組版結果を出力してくれますが，
      構造と体裁が明示的に分離されていないため体裁を扱うには或る程度のリテラシーが必要であったり，
      柔軟なマクロを創るには\TeX; on \LaTeX;の知識が必要で，これが相当非直感的な仕様であるため，
      大多数の人を寄せつけない様相を呈しています。
    }
    \p{
      これらの欠点を解決し，またWebページとPDFを共通の規格で記述できるようにすべく，
      Macrodownの制作に手をつけました。
      記法は“OCamlと\LaTeX;のハーフ”であり，
      “意味論が綺麗な\LaTeX;的記法”を目指したといってもよいかもしれません。
    }
  }
  \section{実用的な例}{
    \subsection{クラス名・ID名オプション}{
      \p{
        クラス名・ID名オプション機能を使うと，
        例えば

        \mcrd-display```
          \div{The quick brown fox jumps over the lazy dog.}
          \div .quote {色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。}
          \div .quote #tori {鳥啼く声す，夢覚ませ。見よ明け亘る，東を。}
        ```

        から

        \mcrd-display```
          <div>
            The quick brown fox jumps over the lazy dog.
          </div>
          <div class="quote">
            色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。
          </div>
          <div class="quote" id="tori">
            鳥啼く声す，夢覚ませ。見よ明け亘る，東を。
          </div>
        ```
            %有為の奥山今日越えて，浅き夢見じ，酔いもせず。
            %空色映えて，沖つ辺に，帆船群れゐぬ，靄の内。

        を得るようなマクロ\code{\synt`\div`}を定義することができます。
        クラス名・ID名オプション機能はHTMLの影響で実装したものですが，
        HTMLに限らず「マークアップ上大きな意味はないが小さい分岐をさせたいとき」に利用できます。
        函数・マクロ定義の項目で後述します。
      }
    }
  }
  \section{字句解析の厳密な仕様}{
    \subsection{概要}{
      \p{
        Macrodownは大きく分けて
        \itemize{
          | テキスト階層
          | プログラム階層
          | アクティヴ階層
          | リテラル階層
          | コメント階層
          |}
        を行き来しながらソースコードをトークンとして解釈します。
        文書（拡張子が.mcrdのもの）はテキスト階層で読み込みが開始され，一方で
        ヘッダ（拡張子が.mcrdhのもの）はプログラム階層で読み込みが開始されます。
      }
    }
    \subsection{テキスト階層}{
      \p{
        マクロではなく文書そのものを書いているときは，
        このテキスト階層を中心に意識していれば良いでしょう。
      }
      \p{
        大小ラテン文字とアラビア数字とハイフンを\newword{基本文字}，その他の文字を\newword{非基本文字}，
        基本文字のみからなり先頭が大小ラテン文字である文字列を\newword{名前文字列}と呼ぶことにすると，
        テキスト階層では文字列を以下にマッチするようにトークン化します。
        ただし + は1回以上の繰り返しを表します。
        複数通りのマッチがある場合はより長い文字列ほど優先し，
        同一の文字列が複数のトークンにマッチする場合は表で上位に掲げられているものほど優先されます。
      }
      \description{
        |\d-item{\mcrd`\`（名前文字列）}{\math{\token-cs;}：\newword{制御綴トークン}}
        |\d-item{\mcrd`@`}{\math{\token-var;}：\newword{文字列中変数参照トークン}}
        |\d-item{\mcrd`{`}{\math{\token-bgrp;}：\newword{ブロック開始トークン}}
        |\d-item{\mcrd`}`}{\math{\token-egrp;}：\newword{ブロック終了トークン}・\newword{テキスト終了トークン}}
        |\d-item{\mcrd`|`}{\math{\token-sep;}：\newword{区切りトークン}}
        |\d-item{\mcrd`\`（非基本文字）}{\math{\token-char;}：エスケープされた\newword{文字トークン}}
        |\d-item{\mcrd`` ` ``+}{\math{\token-opnqt;}：\newword{リテラル開始トークン}}
        |\d-item{\mcrd`%`}{\newword{コメント開始トークン}}
        |\d-item{（空白文字）または（タブ文字）}{\math{\token-space;}}：\newword{空白トークン}
        |\d-item{（改行文字）}{\math{\token-break;}}：\newword{改行トークン}
        |\d-item{（1文字）}{\math{\token-char;}：\newword{文字トークン}}
        |}
      \p{
        表からわかるように，
        \mcrd`%`，\mcrd`\`，\mcrd`@`，\mcrd`{`，\mcrd`}`，\mcrd`|`，\mcrd`` ` ``
        はそのまま書くことができず，\mcrd`\` を手前につけてエスケープしなければならない文字です。
      }
      \p{
        ただし，空白文字，タブ文字，改行文字をまとめて\newword{空白類文字}と呼ぶことにすると，
        \itemize{
          | 行頭の空白類文字
          | 空白類文字の直後の空白類文字
          | \mcrd`{` の直後の空白類文字
          | \mcrd`}` の手前に連続して並んでいる空白類文字
          |}
        はいずれも空白トークンおよび改行トークンと認識されることなく読み捨てられます。
        したがって \mcrd`{` の直後での改行やインデントなどを比較的自由に入れることができます。
      }
      \p{
        また制御綴トークンと変数名トークンは，認識されると直後に字句解析器がアクティヴ階層に遷移します。
        同様に，リテラル開始トークンが認識されると直後にリテラル階層に，
        コメント開始トークンが認識されるとこのコメント開始トークンは即座に読み捨てられてコメント階層に遷移します。
        その他のトークンを認識した直後はテキスト階層を維持して次のトークンの認識に移ります。
      }
      \p{
        \mcrd`}` は基本的に\newword{ブロック終了トークン}ですが，
        場合によっては\newword{テキスト終了トークン}となります。
        プログラム階層で後述しますが，
        プログラム階層からテキスト階層に入る\newword{テキスト開始トークン}の \mcrd`{` と釣り合う \mcrd`}` は
        テキスト終了トークンとなり，これが認識されるとテキスト階層を出てプログラム階層に戻ります。
      }
    }
    \subsection{プログラム階層}{
      \p{
        プログラム階層は，\newword{マクロ}や\newword{函数}の定義に用います。
        全体的にML風の構文をとっています。
      }
      \description{
        | \d-item{\mcrd`(`}{
            \math{\token-lparen;}：\newword{開括弧トークン}}
        | \d-item{\mcrd`)`}{
            \math{\token-rparen;}：\newword{閉括弧トークン}・%
            \math{\token-clsprog;}：\newword{プログラム終了トークン}}
        | \d-item{\mcrd`[`}{
            \math{\token-blist;}：\newword{リスト開括弧トークン}}
        | \d-item{\mcrd`]`}{
            \math{\token-elist;}：\newword{リスト閉括弧トークン}}
        | \d-item{\mcrd`;`}{
            \math{\token-listpunct;}：\newword{リスト区切りトークン}}
        | \d-item{（二項演算子）}{
            \math{\token-bin;}：\newword{二項演算子トークン}}
        | \d-item{\mcrd`let`}{
            \math{\token-let;}：\newword{letトークン}}
        | \d-item{\mcrd`and`}{
            \math{\token-and;}：\newword{andトークン}}
        | \d-item{\mcrd`in`}{
            \math{\token-in;}：\newword{inトークン}}
        | \d-item{\mcrd`if`}{
            \math{\token-if;}：\newword{ifトークン}}
        | \d-item{\mcrd`then`}{
            \math{\token-then;}：\newword{thenトークン}}
        | \d-item{\mcrd`else`}{
            \math{\token-else;}：\newword{elseトークン}}
        | \d-item{\mcrd`finish`}{
            \math{\token-finish;}：\newword{finishトークン}}
        | \d-item{（名前文字列）}{
            \math{\token-ident;}：\newword{項トークン}}
        | \d-item{（整数文字列）}{
            \math{\token-int;}：\newword{整数トークン}}
        | \d-item{\mcrd`{`}{
            \math{\token-opnstr;}：\newword{テキスト開始トークン}}
        | \d-item{\mcrd`` ` ``}{
            \math{\token-opnqt;}：\newword{リテラル開始トークン}}
        | \d-item{\mcrd`%`}{\newword{コメント開始トークン}}
        |}
      \p{
        テキスト開始トークン \mcrd`{` を認識すると，直後にテキスト階層に入ります。
        テキスト階層で釣り合う \mcrd`}` を見つけると，再びプログラム階層に戻ってきます。
      }
      \p{
        \mcrd`)` は基本的に\newword{閉括弧トークン}となりますが，
        アクティヴ階層でプログラム開始トークン \mcrd`(` を認識してプログラム階層に入ってきていたとき，
        釣り合う \mcrd`)` を\newword{プログラム終了トークン}と認識し，直後にアクティヴ階層に戻ります。
      }
      \p{
        finishトークンはヘッダファイルを終了させるトークンで，
        このfinishトークンが評価されたときの環境が次のファイルの読み込みに引き継がれます。
      }
    }
    \subsection{アクティヴ階層}{
      \p{
        アクティヴ階層は，
        テキスト階層内で制御綴トークンと変数名トークン直後にのみ現れる，
        テキスト階層から出ることなく整数値などを扱うための例外的な部分です。
        とは言いつつも文書中で直接プログラムを書くということは普通避けたいので，
        実際には整数値をマクロに引数として渡すなど短い記述で完結することがほとんどです。
      }
      \description{
        | \d-item{\mcrd`(`}{
            \math{\token-opnprog;}：\newword{プログラム開始トークン}}
        | \d-item{\mcrd`#`（名前文字列）}{
            \math{\token-id;}：\newword{ID名トークン}}
        | \d-item{\mcrd`.`（名前文字列）}{
            \math{\token-class;}：\newword{クラス名トークン}}
        | \d-item{\mcrd`{`}{
            \math{\token-bgrp;}：\newword{ブロック開始トークン}}
        | \d-item{\mcrd`` ` ``}{
            \math{\token-opnqt;}：\newword{リテラル開始トークン}}
        |}
      \p{
        プログラム開始トークン \mcrd`(` を認識すると，直後にプログラム階層に入ります。
        プログラム階層内で釣り合う \mcrd`)` を認識すると，アクティヴ階層に戻ってきます。
        これにより制御綴の引数として文字列だけでなく整数値などを扱うことができるようになっています。
      }
      \p{
        ブロック開始トークン \mcrd`{` を認識すると，直後にアクティヴ階層を出てテキスト階層に戻ります。
        同様にリテラル開始トークン \mcrd`` ` `` を認識すると
        直後にアクティヴ階層を出てさらに即座にリテラル階層に入り，
        リテラル階層を出るとテキスト階層に戻ります。
        つまり，アクティヴ階層は最初に現れる \mcrd`{` か \mcrd`` ` `` で終了するということになります。
      }
    }
    \subsection{リテラル階層}{
      \p{
        リテラル階層は書いた文字列をそのまま出力するための特殊なブロックです。
        \mcrd`` ` `` が\math{n}個連なる文字列をそのまま出したい場合，\math{n + 1} 個以上で左右同数の
        \mcrd`` ` `` で括るとリテラル階層となります。
        したがって，リテラル階層は入ってきたときのリテラル開始トークンと同じ個数の
        連続した \mcrd`` ` `` を認識するともともといた階層に戻る，という動作をします。
      }
    }
    \subsection{コメント階層}{
      \p{
        コメント階層では，改行文字が現れるまで全ての文字を読み飛ばします。
        そして改行文字を認識すると，
        その改行文字も含めてそこまでがコメントだったとしてコメント階層を離れ，
        入る前にいたもとの階層に戻ります。
        特にテキスト階層からコメント階層に入ってきて再びテキスト階層に戻るとき，
        改行文字は出力されず，
        さらにコメント階層から抜けた直後は行頭なので空白類文字が無視されることに注意してください。
      }
    }
  \section{構文木化}{
    \math-dp-gather{
      | \cfl{P}{
          | \token-let; \token-ident; A B \token-defeq; P M \token-in; P
          | \token-let; \token-cs; A B \token-defeq; P M \token-in; P
          | \token-let; \token-var; \token-defeq; P \token-in; P
          |*br*
          | \token-if; P \token-then; P \token-else; P
          | P \token-bin; P
          | P P
          |*br*
          | \token-ident;
          | \token-int;
          | \token-opnstr; S \token-clsstr;
          | \token-opnqt; L \token-clsqt;
          |}
      | \cfl{S}{| C S |}
      | \cfl{C}{
          | \token-char;
          | \token-var; \token-end;
          | \token-cs; \token-end;
          | \token-cs; G H
          |}
      | \cfl{A}{| \epsilon; | \token-ident; A |}
      | \cfl{B}{| \epsilon; | \token-var; B |}
      | \cfl{G}{| \token-bgrp; L \token-egrp; |}
      | \cfl{H}{| \epsilon; | G H |}
      |}
  }
  \section{変数・函数・マクロの基本}{
      \p{
        Macrodownは手続き的記述よりも函数的記述に特化しています。
        変数には基本的に破壊的代入の機能がなく，
        したがって純粋函数型プログラミングに近い性質をしています。
      }
      \p{
        函数とマクロは基本的にほとんど同様に扱えるもので，
        単に制御綴で書かれるものをマクロ，
        制御綴でない普通の変数名のように書かれるものを函数と便宜的に呼び分けているだけです。
        制御綴はテキスト階層で，函数はプログラム階層で用いるようになっています。
        以降はプログラム階層を基本にして例を掲げていきましょう。
        したがって，慣れるまではヘッダファイルのみを処理することがしばらく続きます。
      }
      \p{
        まず，名前のない函数が
        \code-dp{
          \synt`(function` \meta{nv1} \metadots; \meta{nvN}
          \synt`->` \meta{Expr} \synt`)`
        }
        で定義できます。
      }
      \p{
        以下のような\newword{定義式}

        \code-dp{
          \synt`let` \meta{hoge} %
            \meta{nvar1} \metadots; \meta{nvarN}
            \synt`=` \meta{ExprA} \synt`in` \meta{ExprB}
        }

        および

        \code-dp{
          \synt`let` \synt`\`\meta{piyo} %
            \meta{var1} \metadots; \meta{varN}
            \synt`=` \meta{ExprA} \synt`in` \meta{ExprB}
        }

        で引数を\math{N}個伴う函数\code{\meta{hoge}}およびマクロ\code{\synt`\`\meta{piyo}}
        が定義されます。

        \code-dp{
          \synt`\`\meta{hoge}\ %
            \synt`{`\meta{Arg1}\synt`}`\metadots;\synt`{`\meta{ArgN}\synt`}`
        }

        で各\code{\meta{varI}}に\code{\meta{ArgI}}が格納された上で定義式の\code{\meta{Expr}}が評価されます。
        変数\code{\meta{piyo}}に格納された中身を文字列中で取り出すには
        \code{\synt`@`\meta{piyo}\synt`;`}とします。例えば

        \mcrd-display```
          let \test x y = {Ma@x;r@y;down} in
            {\test{c}{o}, \test{}{k}}
        ```

        に対する出力は

        \mcrd-display```
          Macrodown, Markdown
        ```

        となります。引数のないマクロも定義でき，これは使用時にセミコロンをつけます。例えば

        \mcrd-display```
          let \mcrd {Macrodown} in {Hello, \mcrd;!}
        ```

        に対する出力は

        \mcrd-display```
          Hello, Macrodown!
        ```

        となります。
      }
    }
    \subsection{リスト}{
      \p{
        具体的なリストは，基本的に
        
        \mcrd-display```
          [3; 1; 4; 1; 5; 9; 2]
        ```

        のように\code{\synt`[`}と\code{\synt`]`}で括って各要素を\code{\synt`;`}で区切って書きます。
        リストでは，全ての要素の型が一致していなければなりません。
        \type-synt{'t}型の要素を持つリストの型は\type-synt{'t list}であり，
        例えば\type-synt{int}型のリストは\type-synt{int list}型になります。
        \type-synt{string}型のリストだけは，

        \mcrd-display```
          [{hoge}; {piyo}; {fuga}; {moge}]
        ```

        と書くところを

        \mcrd-display```
          {|hoge|piyo|fuga|moge|}
        ```

        と省略して書くことができます。
        \code{\synt`[`}と\code{\synt`]`}で括る方法はプログラム階層でしか使えませんが，
        この\type-synt{string}型の省略記法はテキスト階層でのマクロ引数でも使うことができるので便利です。
      }
      \p{
        リストの要素を取り出す操作を見ていきましょう。
        まずリストの先頭要素を取り出す函数が\mcrd-type`list-head`{'a list -> 'a}，
        先頭を除いたリストを得る函数が\mcrd-type`list-tail`{'a list -> 'a list}です。
        例えば\mcrd`list-head [2; 4; 6; 9; 11]`は\mcrd`2`に，
        \mcrd`list-tail [2; 4; 6; 9; 11]`は\mcrd`[4; 6; 9; 11]`にそれぞれ評価されます。
      }
      \p{
        では，\mcrd`list-head`および\mcrd`list-tail`に空のリスト\mcrd`[]`を渡すとどうなるかというと，
        これは実行時エラーで終了してしまいます。
        そこで，リストが空かどうか判定する函数\mcrd-type`is-empty`{'a list -> bool}を使うことになります。
      }
      \p{
        リストを扱う例を見てみましょう。
        文字列のリストを受け取り，それぞれを文字\mcrd`(`と\mcrd`)`で括って並べるマクロ，
        \mcrd-type`\enclose-each`{string list -> string}を定義します。

        \mcrd-display```
          let enclose-each lst =
            if is-empty lst then {} else
              let hd = list-head lst in
              let tl = list-tail lst in
                {(@hd;)} ^ (enclose-each tl) in
          let \enclose-each = enclose-each in
          in {\enclose-each{|bd|gfn|\enclose-each{|me|ip|}|}}
        ```

        に対する出力は

        \mcrd-display```
          (bd)(gfn)((me)(ip))
        ```

        となります。より実用的な例としては

        \mcrd-display```
          let sub-ul lst =
            if is-empty lst then {} else
              let hd = list-head lst in
              let tl = list-tail lst in
                {<li>@head;</li>\break;} ^ (sub-ul tl)
          in
          let \ul lst = {<ul>\deeper(sub-ul lst);</ul>}
          in
            {\ul{|hoge|piyo|fuga|moge|}}
        ```

        に対する出力は
        
        \mcrd-display```
          <ul>
            <li>hoge</li>
            <li>piyo</li>
            <li>fuga</li>
            <li>moge</li>
          </ul>
        ```
        
        となります。
      }
      \p{
        このほか，空列かどうかを判定する条件分岐機能\mcrd`\ifempty`があり，
      }
      \code-dp{
        \synt{\bksl;ifempty}%
          \synt{\lbrace;} \meta{ExprB} \synt{\rbrace;}%
          \synt{\lbrace;} \meta{ExprT} \synt{\rbrace;}%
          \synt{\lbrace;} \meta{ExprF} \synt{\rbrace;}%
      }
      \p{
        で\code{\meta{ExprB}}が空列のときは\code{\meta{ExprT}}を評価し，
        空列でない時は\code{\meta{ExprF}}を評価します。
        これを用いると例えば
      }
      \mcrd-display```
        \macro \enum-comma @list {
          \pop @head @tail {@list;}{
            @head;\ifempty{@tail;}{}{, \enum-comma{@tail;}}
          }
        }%
        \enum-comma{un|deux|trois}
      ```
      \p{
        により
      }
      \mcrd-display```
        un, deux, trois
      ```
      \p{
        を得ることができます。また，2つのトークン列が同一の出力となるかどうかを判定する条件分岐機能%
        \mcrd`\ifsame`は
      }
      \code-dp{
        \synt{\bksl;ifsame}\synt{\lbrace;} \meta{ExprA} \synt{\rbrace;}%
          \synt{\lbrace;} \meta{ExprB} \synt{\rbrace;}%
          \synt{\lbrace;} \meta{ExprT} \synt{\rbrace;}%
          \synt{\lbrace;} \meta{ExprF} \synt{\rbrace;}
      }
      \p{
        という形で使い，\code{\meta{ExprA}}と\code{\meta{ExprB}}が同一出力となる場合は
        \code{\meta{ExprT}}を，互いに異なる出力となる場合は\code{\meta{ExprF}}を評価します。
      }
    }
  }
}
